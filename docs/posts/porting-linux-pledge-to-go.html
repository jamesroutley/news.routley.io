<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/porting-linux-pledge-to-go">Original</a>
    <h1>Porting Linux Pledge to Go</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>I like using <a href="https://man.openbsd.org/pledge">pledge</a> and <a href="https://man.openbsd.org/unveil">unveil</a> in my web apps. Especially unveil offers a nice degree of protection against common web app problems, like the dreaded double dot traversal. For go, I use a <a href="https://humungus.tedunangst.com/r/honk/v/2c1c506b8517/f/unveil.go">simple wrapper</a> which gets pasted into each project.</p><p>But what of the unfortunate linux users left out there?<br/></p><h3>linux pledge</h3><p>There is a version of <a href="https://justine.lol/pledge/">pledge ported to linux</a>. Using that, I can make a go module, which should work anywhere. Well, it will work on OpenBSD, mostly work on Linux, and cheerfully pretend to work everywhere else. Good enough.</p><p>The trick is we need to integrate this into go’s build process, without wrangling with another libc on the system.</p><p>The upstream for linux pledge we’re using is tied up in cosmopolitan libc, but there’s a <a href="https://github.com/jart/pledge">standalone version</a> extracted from it. From that, I extracted another, even simpler version. Double distilled, extra smooth.</p><p>A few quick hacks, and it all came together.<br/></p><h3>cosmo pledge</h3><p>A few notes on behavioral differences using cosmo pledge.</p><p>At first, a <i>pledge</i> violation would only hang the go process. Apparently this is what happens when only a thread disappears unexpectedly. The <a href="https://humungus.tedunangst.com/r/pledge/v/a7d8365123c2">easy fix</a> was to switch to killing the process.</p><p>I also noticed <i>unveil</i> didn’t seem to work. As documented in the source, a null call is required to commit and seal the changes. On OpenBSD, they apply immediately, allowing one to skip the final unveil call and simply use pledge to prevent further changes. I just have the wrapper handle this.</p><p>There’s another difference regarding unveil and threads on linux, and I’m not entirely sure how it affects go. <a href="https://github.com/landlock-lsm/go-landlock#applying-landlock-to-all-goroutines">Ugh</a>.<br/></p><h3>rseq</h3><p>Linux has a system call <i>rseq</i>. What a name. Apparently glibc likes to use it, and if you don’t let it, it gets very cranky. “Fatal glibc error: rseq registration failed”</p><p>Looks like we will be <a href="https://humungus.tedunangst.com/r/pledge/v/15ccfeb65930">punching a hole</a> for that.</p><p>As documented by justine, glibc also wants to do some other tricksy business, which the linux port addresses by injecting a shared library. None of that code is here in the go port. Hopefully, we’re less reliant on glibc.<br/></p><h3>status</h3><p>It’s <a href="https://humungus.tedunangst.com/r/pledge">close to done</a>. Have <a href="https://humungus.tedunangst.com/r/honk/v/edd66c58c7b1">switched honk</a> to using this module, likely upping the protection level from 50% of users to 99% of users. See what breaks.</p><p>I have some lingering concerns that the linux version can be bypassed in sneaky ways by someone with more knowledge of glibc.
</p></div><div><p>
Posted 25 Oct 2023 17:15 by tedu Updated: 26 Oct 2023 21:14 
</p></div></div>
  </body>
</html>
