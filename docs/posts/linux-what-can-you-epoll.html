<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://darkcoding.net/software/linux-what-can-you-epoll/">Original</a>
    <h1>Linux: What Can You Epoll?</h1>
    
    <div id="readability-page-1" class="page"><section>
      <p>At the start of this year I argued that <a href="https://darkcoding.net/software/epoll-the-api-that-powers-the-modern-internet/">epoll is the API that powers the modern Internet</a>, but what can you actually do with <code>epoll</code>?</p>
<p>Once we structure our application around an epoll event loop or use an async engine such as Go or Rust’s tokio, it becomes really useful to integrate everything else into that event loop.</p>
<ul>
<li>What types of file descriptors can you add to <code>epoll_ctl</code>?</li>
<li>What can you turn into a file descriptor?</li>
</ul>
<p>I was not able to find a comprehensive list of epoll-compatible APIs on the Internet, so I made one.</p>
<h2 id="network-sockets">Network sockets </h2>
<p>Network sockets are the reason we want and use <code>epoll</code>. These are nearly always IP sockets (TCP and UDP), but it also works with less common families such as UNIX, PACKET, NETLINK and many others. Indeed it should work with any of the protocol families that <a href="https://man7.org/linux/man-pages/man2/socket.2.html">socket</a> accepts, although I have not tested all of them.</p>
<h2 id="timers">Timers </h2>
<p><a href="https://man7.org/linux/man-pages/man2/timerfd_create.2.html">timerfd_create</a> allows us to create a one-shot or repeating timer and get a file descriptor for it, which becomes ready when the timer fires. Ideal for async <code>sleep</code> or timeout.</p>
<h2 id="signals">Signals </h2>
<p><a href="https://man7.org/linux/man-pages/man2/signalfd.2.html">signalfd</a> gives us a file descriptor that becomes ready when an operating system signal fires. Example uses include asking a program to reload it’s configuration on SIGHUP, or logging debug info on SIGUSR1.</p>
<h2 id="filesystem-events">Filesystem events </h2>
<p>The <a href="https://man7.org/linux/man-pages/man7/inotify.7.html">inotify</a> API allows us to monitor the file system for events such as file creation and modification. The file descriptor returned by <code>inotify_init</code> can be polled with epoll. Example uses include reloading a config file when it changes, and waking up when new data appears in a directory.</p>
<h2 id="child-processes">Child processes </h2>
<p>We can get a file descriptor for a child process either by setting the <a href="https://man7.org/linux/man-pages/man2/clone.2.html">CLONE_PIDFD flag on clone</a> or by calling <a href="https://man7.org/linux/man-pages/man2/pidfd_open.2.html">pidfd_open</a>. It becomes ready when the process exits. Useful for monitoring sub-processes and preventing them becoming zombies. If we need the exit code we would call <a href="https://man7.org/linux/man-pages/man2/waitid.2.html">waitid</a> once epoll says it’s exited.</p>
<h2 id="terminals">Terminals </h2>
<p>epoll accepts fd’s from terminals and pseudo-terminals. It accepts fd 0 (stdin), 1 (stdout) and 2 (stderr). This is useful for programs designed to be used in a cmd line pipe, or as a sub-process where the parent writes to it’s stdin and reads from it’s stdout.</p>
<p>It also allows giving our servers an interactive operator / debug mode and wiring that into the main event loop. It’s also quite fun to experiment with.</p>
<h2 id="epoll-inception">Epoll inception </h2>
<p><code>epoll_create</code> returns a file descriptor which can itself be monitored via <code>epoll_ctl</code>. This allows building a multi-level hierarchy of epoll listeners.</p>
<h2 id="notifications-the-everything-else-plan">Notifications: The everything-else plan </h2>
<p>If our async engine cannot ask the kernel for asynchronous (epoll-able) notification when a task completes, we have to run that task on a different thread. All we need then is a way for that thread to notify the event loop upon completion. There are four epoll-able ways for processes or threads to communicate:</p>
<ul>
<li>
<p>POSIX message queues: See <a href="https://man7.org/linux/man-pages/man7/mq_overview.7.html">man 7 mq_overview</a>.</p>
</li>
<li>
<p>UNIX socket pairs: <a href="https://man7.org/linux/man-pages/man2/socketpair.2.html">man socketpair</a>.</p>
</li>
<li>
<p>Pipes (or FIFOs aka named pipe): <a href="https://man7.org/linux/man-pages/man7/pipe.7.html">man 7 pipe</a>.</p>
</li>
<li>
<p>eventfd: Designed for exactly our use case, eventfd is a modern alternative to pipes for epoll-able signalling. Has optional semaphore semantics. From <a href="https://man7.org/linux/man-pages/man2/eventfd.2.html">man eventfd</a>:</p>
</li>
</ul>
<blockquote>
<p>Applications can use an eventfd file descriptor instead of a pipe in all cases where a pipe is used simply to signal events.  The kernel overhead of an eventfd file descriptor is much lower than that of a pipe, and only one file descriptor is required (versus the two required for a pipe).</p>
</blockquote>
<h2 id="and-what-you-cant-epoll-regular-files">And what you can’t epoll: regular files </h2>
<p>Calling <code>epoll_ctl</code> with a regular (disk) file will return error <code>EPERM</code>:</p>
<blockquote>
<p>EPERM  The target file fd does not support epoll.  This error can occur if fd refers to, for example, a regular file or a directory.</p>
</blockquote>
<p>On Linux <code>write</code> to a regular file never blocks. Writing to a file copies data from our user space buffer to the kernel buffer and returns immediately. At some later point in time the kernel will send it to the disk. A regular file is hence always ready for writing and epoll wouldn’t add anything.</p>
<p>A file <code>read</code> is a copy from kernel buffer to user buffer. The kernel does try to anticipate our reads by prefetching disk data, but if the data is not available our thread will very much block, going into uninterruptible sleep. There are edge cases where this could block indefinitely, such as some NTFS failures and <a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a> setups (e.g. sshfs).</p>
<table>
<tbody><tr>
<td>
Aside
</td>
<td>
By &#39;blocking&#39; above I mean blocking I/O, particularly I/O that could block indefinitely such as reading from a socket. Copying data from user space to kernel space does indeed block our thread, but that doesn&#39;t count here. It is both very fast compared to I/O, and most importantly not indefinite.
</td>
</tr>
</tbody></table>
<p>File reads don’t fit epoll particularly well because knowing that a file is ready to read (as indicated by <code>epoll_wait</code>) isn’t useful unless we know the offset at which we can read. We may only want the last 100 bytes of an enormouse file. Still, it would be really nice to integrate disk reads with our event loop.</p>
<p>Linux does have two facilities for true async disk I/O: <a href="https://pagure.io/libaio">libaio</a> and <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a>. Neither of them work directly with epoll. They could be integrated thanks to <code>eventfd</code>, or io_uring could become the event loop and monitor the epoll fd.</p>
<h2 id="in-pratice">In pratice </h2>
<p>I had a quick look at <a href="https://tokio.rs/">tokio</a> and <a href="https://tokio.rs/">Go</a> to see how much of this they are using. They both always use epoll and start multiple threads (num CPU * 2 seems standard). Go uses a pipe (<code>pipe2</code> syscall). Tokio uses <a href="https://docs.rs/mio/0.8.4/mio/struct.Waker.html">eventfd via mio</a>. Neither appears to use timerfd or signalfd. Tokio handles events (epoll) via Mio, and there are crates to extend Mio for all of the above APIs.</p>

    </section></div>
  </body>
</html>
