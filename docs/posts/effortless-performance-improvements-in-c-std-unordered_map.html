<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://julien.jorge.st/posts/en/effortless-performance-improvements-in-cpp-std-unordered_map/">Original</a>
    <h1>Effortless Performance Improvements in C&#43;&#43;: std:unordered_map</h1>
    
    <div id="readability-page-1" class="page"><div>
          
          
          
          
          <p>This is the second post in the series about effortless performance
improvements in C++. Check <a href="https://julien.jorge.st/posts/en/effortless-performance-improvements-in-cpp">the first
post</a> to get the
full story!</p>
<p>Last time we observed that our hotspots were mostly located in the
standard library, and we concluded that we may be using it wrong. The
top offender being a function from <code>std::map</code>, let’s dig into that.</p>

<p>In our initial implementation we have a single map, used to store the
key-value pairs obtained from the input. We are doing three lookups in
this map. The first one is obvious: it is when we process a <code>&#34;value&#34;</code>
record, where we need to check if the provided key has been set:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>else</span> <span>if</span> (tokens[<span>0</span>] <span>==</span> <span>&#34;value&#34;</span>)
</span></span><span><span>  {
</span></span><span><span>    <span>// Obvious lookup in the map.
</span></span></span><span><span><span></span>    <span>if</span> (entries.find(tokens[<span>1</span>]) <span>!=</span> entries.end())
</span></span><span><span>    <span>/* … */</span>
</span></span></code></pre></div><p>But there is also two less-obvious searches. Just one line below the
previous scan:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>else</span> <span>if</span> (tokens[<span>0</span>] <span>==</span> <span>&#34;value&#34;</span>)
</span></span><span><span>  {
</span></span><span><span>    <span>if</span> (entries.find(tokens[<span>1</span>]) <span>!=</span> entries.end())
</span></span><span><span>      <span>// Less obvious lookup in the map, via operator[].
</span></span></span><span><span><span></span>      result <span>+=</span> <span>&#34;value:&#34;</span> <span>+</span> entries[tokens[<span>1</span>]] <span>+</span> <span>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>That’s right, calling <code>std::map::operator[]</code> does a lookup like <code>find</code>
to check if there is already an entry with the given key. But since we
did a search just above, couldn’t it be optimized by the compiler?
Well, it’s complicated, but the answer is no.</p>
<p>Before showing the solution for this point, here is the third lookup,
in the processing of a <code>&#34;set&#34;</code> record:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>else</span> <span>if</span> (tokens[<span>0</span>] <span>==</span> <span>&#34;set&#34;</span>)
</span></span><span><span>  <span>// Another lookup in the map, via operator[]
</span></span></span><span><span><span></span>  entries[tokens[<span>1</span>]] <span>=</span> tokens[<span>2</span>];
</span></span></code></pre></div><p>Again, the call to <code>std::map::operator[]</code> does a lookup.</p>

<p>There is not so much we can do to avoid the search in the processing
of a <code>&#34;set&#34;</code> record. We could use <code>std::map::emplace</code> to save the
overwritting of an existing key, but it would change the behavior of
our program. So we are going to leave it as it is.</p>
<p>In the processing of <code>&#34;value&#34;</code> we could abuse the fact that accessing
a non-existent key via <code>std::map::operator[]</code> creates a new value
using the default constructor of its type. In our case it would be an
empty string, so the output would be the same:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>else</span> <span>if</span> (tokens[<span>0</span>] <span>==</span> <span>&#34;value&#34;</span>)
</span></span><span><span>  {
</span></span><span><span>    <span>// entries[tokens[1]] is the existing value if any, or an empty
</span></span></span><span><span><span></span>    <span>// string if none.
</span></span></span><span><span><span></span>    result <span>+=</span> <span>&#34;value:&#34;</span> <span>+</span> entries[tokens[<span>1</span>]] <span>+</span> <span>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>But by doing so we would insert a new entry in the map for each
non-existent key we test! This is not what we want.</p>
<p>The proper solution to get an optional value associated with the key
is to keep the iterator returned by <code>std::map::find()</code>:</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>else</span> <span>if</span> (tokens[<span>0</span>] <span>==</span> <span>&#34;value&#34;</span>)
</span></span><span><span>  {
</span></span><span><span>    <span>// Single search in the map
</span></span></span><span><span><span></span>    <span>const</span> entry_map<span>::</span>const_iterator it <span>=</span> entries.find(tokens[<span>1</span>]);
</span></span><span><span>
</span></span><span><span>    <span>if</span> (it <span>!=</span> entries.end())
</span></span><span><span>      <span>// Here we can access the value via the iterator.
</span></span></span><span><span><span></span>      result <span>+=</span> <span>&#34;value:&#34;</span> <span>+</span> it<span>-&gt;</span>second <span>+</span> <span>&#39;\n&#39;</span>;
</span></span><span><span>    <span>else</span>
</span></span><span><span>      result <span>+=</span> <span>&#34;value:</span><span>\n</span><span>&#34;</span>;
</span></span><span><span>
</span></span><span><span>    <span>++</span>line_count;
</span></span><span><span>  }
</span></span></code></pre></div><p>Just like in the initial code, we search the map using
<code>std::map::find</code>, but now we store the result in a local variable. The
result is an iterator that we can compare with <code>entries.end()</code>, as
before. Now, if the iterator is not the end iterator, then we can get
the value from the map by dereferencing the iterator and accessing its
<code>second</code> member.</p>
<p>This is not a huge change, what difference can it make?</p>
<p><img src="https://julien.jorge.st/posts/en/effortless-performance-improvements-in-cpp-std-unordered_map/images/relative-1.png" alt=""/></p>
<p>Ouch! 5 to 9% faster with such a small change! Quite good isn’t it?
Let’s check again the hotspots with <code>perf</code>:</p>
<ul>
<li>26% in <code>std::map&lt;std::string, std::string&gt;::find</code>.
<ul>
<li>Under which the top offender is <code>std::string::operator&lt;</code>.</li>
</ul>
</li>
<li>15% in <code>tokenize</code>.
<ul>
<li>Mostly in <code>std::vector&lt;std::string&gt;::push_back</code>.</li>
</ul>
</li>
<li>10% in <code>std::map&lt;std::string, std::string&gt;::operator[]</code>.
<ul>
<li>Again with <code>std::string::operator&lt;</code> as the top offender.</li>
</ul>
</li>
<li>6% in <code>std::getline</code>.</li>
<li>5% in <code>replace</code>.
<ul>
<li>With <code>std::string::find</code> as the top offender.</li>
</ul>
</li>
</ul>
<p>The time spent in <code>std::map::operator[]</code> went down from 15% to
10%. This is now less of a problem than the call to <code>tokenize</code> but we
still have <code>std::map::find</code> at the top. As we saw before, there’s not
so much we can do to avoid these calls, so let’s see if there would be
different approach as a more efficient replacement.</p>

<p>The implementation of <code>std::map</code> is a binary tree, where each node
points to two sub-trees: one where the items are smaller than the one
in the current node, and one where the items are
greater. Conceptually, it looks like this:</p>
<p><img src="https://julien.jorge.st/posts/en/effortless-performance-improvements-in-cpp-std-unordered_map/images/map.png" alt=""/></p>
<p>The algorithmic complexity for searching, inserting, or removing an
entry is <em>O(log<!-- raw HTML omitted -->2<!-- raw HTML omitted -->(n))</em>, where <em>n</em> is the number of items in
the container.</p>
<p>Since C++11 the standard library provides another associative table in
the form of <code>std::unordered_map</code>. Its implementation is a hash table:
an integral hash is computed for each item, then this hash is used as
an index in a table where the items are stored. If many items end up
in the same slot, they are chained, as in a linked list. Conceptually,
it looks like this:</p>
<p><img src="https://julien.jorge.st/posts/en/effortless-performance-improvements-in-cpp-std-unordered_map/images/hash-map.png" alt=""/></p>
<p>The algorithmic complexity for searching, inserting, or removing an
entry is <em>O(1)</em>, which is clearly better than the one of <code>std::map</code>.</p>
<p>Hidden in the cost of <code>std::map&lt;std::string, T&gt;</code> is the comparison of
the strings as we scan the map. On the other hand,
<code>std::hash_map&lt;std::string, T&gt;</code> has to compute a hash of the provided
strings.</p>

<p>Let’s apply the following changes in our program and see how it
impacts its performance.</p>
<div><pre tabindex="0"><code data-lang="diff"><span><span> -5,5 +5,5
</span></span><span><span> #include &#34;tokenize.hpp&#34;
</span></span><span><span>
</span></span><span><span><span>-#include &lt;map&gt;
</span></span></span><span><span><span></span><span>+#include &lt;unordered_map&gt;
</span></span></span><span><span><span></span> #include &lt;sstream&gt;
</span></span><span><span>
</span></span><span><span> -27,5 +27,5
</span></span><span><span>  std::string result;
</span></span><span><span>  std::uint64_t next_date = 0;
</span></span><span><span><span>- std::map&lt;std::string, std::string&gt; entries;
</span></span></span><span><span><span></span><span>+ std::unordered_map&lt;std::string, std::string&gt; entries;
</span></span></span><span><span><span></span>
</span></span><span><span>  while (std::getline(iss, line))
</span></span></code></pre></div><p>Very easy modification. What difference does it make?</p>
<p><img src="https://julien.jorge.st/posts/en/effortless-performance-improvements-in-cpp-std-unordered_map/images/relative-2.png" alt=""/></p>
<p>Up to 30% improvements over the baseline, and 23% compared with the
previous implementation! Note that it does not matter if the map is
small or large, it is always a win to use <code>std::unordered_map</code> here.</p>
<p>Let’s look at the <code>perf</code> profile.</p>
<ul>
<li>17% in <code>std::unordered_map&lt;std::string, std::string&gt;::operator[]</code>.</li>
<li>17% in <code>tokenize</code>.
<ul>
<li>Mostly in <code>std::vector&lt;std::string&gt;::push_back</code>.</li>
</ul>
</li>
<li>12% in <code>std::unordered_map&lt;std::string, std::string&gt;::find</code>.</li>
<li>7% in <code>replace</code>.
<ul>
<li>With <code>std::string::find</code> as the top offender.</li>
</ul>
</li>
<li>6% in <code>std::getline</code>.</li>
</ul>
<p>Looks like our maps are less of a problem now, and <code>tokenize</code> is going
up with its uses of <code>std::vector</code>. <!-- raw HTML omitted -->
We will see if we can do something about it in next week’s post. Stay
tuned!</p>

        </div></div>
  </body>
</html>
