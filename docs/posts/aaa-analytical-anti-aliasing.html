<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.frost.kiwi/analytical-anti-aliasing/">Original</a>
    <h1>AAA ‚Äì Analytical Anti-Aliasing</h1>
    
    <div id="readability-page-1" class="page"><div><p>Today‚Äôs journey is <a href="https://en.wikipedia.org/wiki/Spatial_anti-aliasing">Anti-Aliasing</a> and the destination is <strong>Analytical Anti-Aliasing</strong>. Getting rid of rasterization <a href="https://en.wikipedia.org/wiki/Jaggies">jaggies</a> is an art-form with decades upon decades of maths, creative techniques and non-stop innovation. With so many years of research and development, there are many flavors.</p><p>From the simple but resource intensive <a href="https://en.wikipedia.org/wiki/Supersampling"><strong>SSAA</strong></a>, over theory dense <a href="https://www.iryoku.com/smaa/"><strong>SMAA</strong></a>, to using machine learning with <a href="https://en.wikipedia.org/wiki/Deep_learning_anti-aliasing"><strong>DLAA</strong></a>. Same goal - <strong><em>vastly</em></strong> different approaches. We‚Äôll take a look at how they work, before introducing a new way to look a the problem - the ‚ú®<em><strong>analytical</strong></em>üåü way. The perfect Anti-Aliasing exists and is simpler than you think.</p><blockquote><p>Having <a href="https://mirrorball.frost.kiwi">implemented</a> it multiple times over the years, I&#39;ll also share some juicy secrets I have never read anywhere before.</p><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"/></blockquote><h2 id="the-setup" tabindex="-1">The Setup <a href="#the-setup">#</a></h2><p>To understand the Anti-Aliasing algorithms, we will implement them along the way! Following <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">WebGL canvases</a> draw a moving circle. Anti-Aliasing <em>cannot</em> be fully understood with just images, movement is <em>essential</em>. The red box has 4x zoom. Rendering is done at <a href="https://en.wikipedia.org/wiki/1:1_pixel_mapping">native</a> resolution of your device, important to judge sharpness.</p><blockquote><p>Please pixel-peep to judge sharpness and aliasing closely. Resolution of your screen too high to see aliasing? Lower the resolution with the following buttons, which will <a href="https://tanalin.com/en/articles/integer-scaling/">integer-scale</a> the rendering.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"/></blockquote><div><p> <label for="native">Native<p>Resolution</p></label></p><p> <label for="half">¬Ω<p>Resolution</p></label></p><p> <label for="quarter">¬º<p>Resolution</p></label></p><p> <label for="eight">‚Öõ<p>Resolution</p></label></p></div><canvas id="canvasSimple" width="100%" height="400px"></canvas><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/simple.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/simple.png" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle.vs">circle.vs</a></summary><pre><code>
<span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec3</span> col<span>;</span>


<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>varying</span> <span>vec3</span> color<span>;</span>


<span>uniform</span> <span>float</span> aspect_ratio<span>;</span>

<span>uniform</span> <span>vec2</span> offset<span>;</span>

<span>uniform</span> <span>float</span> size<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	
	uv <span>=</span> vtx<span>;</span>
	
	color <span>=</span> col<span>;</span>

	<span>vec2</span> vertex <span>=</span> vtx<span>;</span>
	
	vertex<span>.</span>x <span>*=</span> aspect_ratio<span>;</span>
	
	vertex <span>*=</span> size<span>;</span>
	
	vertex <span>+=</span> offset<span>;</span>

	
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vertex<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle.fs">circle.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>varying</span> <span>vec3</span> color<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
	<span>vec3</span> finalColor <span>=</span> color <span>+</span> <span>clamp</span><span>(</span> <span>-</span> uv<span>.</span>y <span>*</span> <span>0.4</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>

	
	<span>if</span> <span>(</span><span>length</span><span>(</span>uv<span>)</span> <span>&lt;</span> <span>1.0</span><span>)</span>
		gl_FragColor <span>=</span> <span>vec4</span><span>(</span>finalColor<span>,</span> <span>1.0</span><span>)</span><span>;</span>
	<span>else</span>
		<span>discard</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleSimple.js">circleSimple.js</a></summary><pre><code><span>function</span> <span>setupSimple</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> simpleColorFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>,</span> radioName<span>,</span> showQuadOpt</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> circleDrawFramebuffer<span>,</span> frameTexture<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> showQuad <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span><span>,</span>
		<span>}</span>
	<span>)</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	<span>const</span> showQuadOption <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>showQuadOpt<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	showQuadOption<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;false&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			showQuad <span>=</span> <span>(</span>event<span>.</span>target<span>.</span>value <span>===</span> <span>&#34;true&#34;</span><span>)</span><span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>const</span> circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> simpleColorShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> simpleColorFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationSimple <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>simpleColorShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircleSimple <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>simpleColorShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircleSimple <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>simpleColorShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> circleOffsetAnim <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>0.0</span><span>,</span> <span>0.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>
	gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation<span>,</span> aspect_ratio<span>)</span><span>;</span>
		<span>var</span> radius <span>=</span> <span>0.1</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		circleOffsetAnim<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		circleOffsetAnim<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle<span>,</span> circleSize<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		<span>if</span> <span>(</span>showQuad<span>)</span> <span>{</span>
			gl<span>.</span><span>useProgram</span><span>(</span>simpleColorShd<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationSimple<span>,</span> aspect_ratio<span>)</span><span>;</span>
			gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircleSimple<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircleSimple<span>,</span> circleSize<span>)</span><span>;</span>
			gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationPost<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> <span>(</span><span>1.0</span> <span>/</span> aspect_ratio<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationRed<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> <span>1.0</span> <span>/</span> <span>(</span>width <span>/</span> height<span>)</span><span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>
	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><p>Let‚Äôs start out simple. Using <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> Shaders we tell the GPU of your device to draw a circle in the most simple and naive way possible, as seen in <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circle.fs">circle.fs</a> above: If the <a href="https://docs.gl/sl4/length"><code>length()</code></a> from the middle point is bigger than 1.0, we <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader#Special_operations"><code>discard</code></a> the pixel.</p><p>The circle is blocky, especially at smaller resolutions. More painfully, there is strong ‚Äúpixel crawling‚Äù, an artifact that‚Äôs very obvious when there is any kind of movement. As the circle moves, rows of pixels pop in and out of existence and the stair steps of the pixelation move along the side of the circle like beads of different speeds.</p><blockquote><p>The low ¬º and ‚Öõ resolutions aren&#39;t just there for extreme pixel-peeping, but also to represent small elements or ones at large distance in 3D.</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"/></blockquote><p>At lower resolutions these artifacts come together to destroy the circular form. The combination of slow movement and low resolution causes one side‚Äôs pixels to come into existence, before the other side‚Äôs pixels disappear, causing a wobble. Axis-alignment with the pixel grid causes ‚Äúplateaus‚Äù of pixels at every 90¬∞ and 45¬∞ position.</p><h3 id="technical-breakdown" tabindex="-1">Technical breakdown <a href="#technical-breakdown">#</a></h3><blockquote><p>Understanding the GPU code is not necessary to follow this article, but will help to grasp whats happening when we get to the analytical bits.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"/></blockquote><p>4 vertices making up a quad are sent to the GPU in the vertex shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circle.vs">circle.vs</a>, where they are received as <code>attribute vec2 vtx</code>. The coordinates are of a ‚Äúunit quad‚Äù, meaning the coordinates look like the following image. With <a href="https://www.copetti.org/writings/consoles/sega-saturn/#segas-offering">one famous exception</a>, all GPUs use triangles, so the quad is actually made up of two triangles.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/unit.svg" alt="Schematic make-up of the unit quad"/><figcaption>Schematic make-up of the unit quad</figcaption></figure><p>The vertices <a href="https://blog.frost.kiwi/analytical-anti-aliasing/utility.js">here</a> are given to the fragment shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circle.fs">circle.fs</a> via <code>varying vec2 uv</code>. The fragment shader is called per <a href="https://www.khronos.org/opengl/wiki/Fragment">fragment</a> (here fragments are pixel-sized) and the <a href="http://learnwebgl.brown37.net/12_shader_language/glsl_data_types.html#storage-qualifiers"><code>varying</code></a> is interpolated linearly with <a href="https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping">perspective corrected</a>, <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a>, giving us a <code>uv</code> coordinate per pixel from <code>-1</code> to <code>+1</code> with zero at the center.</p><p>By performing the check <code>if (length(uv) &lt; 1.0)</code> we draw our color for fragments inside the circle and reject fragments outside of it. What we are doing is known as ‚ÄúAlpha testing‚Äù. Without diving too deeply and just to hint at what‚Äôs to come, what we have created with <code>length(uv)</code> is the <a href="https://en.wikipedia.org/wiki/Signed_distance_function#Applications">signed distance field</a> of a point.</p><blockquote><p>Just to clarify, the circle isn&#39;t &#34;drawn with geometry&#34;, which would have finite resolution of the shape, depending on how many vertices we use. It&#39;s &#34;drawn by the shader&#34;.</p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"/></blockquote><h2 id="ssaa" tabindex="-1">SSAA <a href="#ssaa">#</a></h2><p>SSAA stands for <a href="https://en.wikipedia.org/wiki/Supersampling">Super Sampling Anti-Aliasing</a>. Render it bigger, downsample to be smaller. The idea is as old as 3D rendering itself. In fact, the first movies with CGI all relied on this with the most naive of implementations. One example is the 1986 movie ‚Äú<a href="https://en.wikipedia.org/wiki/Flight_of_the_Navigator">Flight of the Navigator</a>‚Äù, as covered by <a href="https://www.youtube.com/@CaptainDisillusion">Captain Disillusion</a> in the video below.</p><figure><video controls="" height="540" poster="vid/flight_thumb.jpg" width="960"><source src="vid/flight.mp4" type="video/mp4"/></video><figcaption>SSAA as used in &#34;Flight of the Navigator&#34; (1986)</figcaption></figure><blockquote><p>1986 did it, so can we. Implemented in mere seconds. <b>Easy</b>, right?</p><img src="https://blog.frost.kiwi/assets/kiwis/ice.svg"/></blockquote><div><p> <label for="nativeSSAA">Native<p>Resolution</p></label></p><p> <label for="halfSSAA">¬Ω<p>Resolution</p></label></p><p> <label for="quarterSSAA">¬º<p>Resolution</p></label></p><p> <label for="eightSSAA">‚Öõ<p>Resolution</p></label></p></div><canvas id="canvasSSAA" width="100%" height="400px"></canvas><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/ssaa.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/ssaa.png" alt="image"/></p></details><details><summary>SSAA buffer Fragment Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/post.fs">post.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>uniform</span> <span>sampler2D</span> u_texture<span>;</span>
<span>varying</span> <span>vec2</span> texCoord<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	gl_FragColor <span>=</span> <span>texture2D</span><span>(</span>u_texture<span>,</span> texCoord<span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleSSAA.js">circleSSAA.js</a></summary><pre><code><span>function</span> <span>setupSSAA</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> postVtxSrc<span>,</span> postFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>,</span> radioName</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> frameTexture<span>,</span> circleDrawFramebuffer<span>,</span> frameTextureLinear<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span><span>,</span>
			<span>premultipliedAlpha</span><span>:</span> <span>true</span>
		<span>}</span>
	<span>)</span><span>;</span>

	
	<span>let</span> renderbuffer <span>=</span> <span>null</span><span>;</span>
	<span>let</span> resolveFramebuffer <span>=</span> <span>null</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>const</span> circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> postShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> postVtxSrc<span>,</span> postFragSrc<span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> circleOffsetAnim <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>0.0</span><span>,</span> <span>0.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>

	gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>resolveFramebuffer<span>)</span><span>;</span>
		resolveFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>

		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		frameTextureLinear <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> <span>(</span>canvas<span>.</span>width <span>/</span> resDiv<span>)</span> <span>*</span> <span>2</span><span>,</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span> <span>*</span> <span>2</span><span>,</span> frameTextureLinear<span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTextureLinear<span>,</span> <span>0</span><span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>(</span>canvas<span>.</span>width <span>/</span> resDiv<span>)</span> <span>*</span> <span>2</span><span>,</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span> <span>*</span> <span>2</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation<span>,</span> aspect_ratio<span>)</span><span>;</span>
		<span>var</span> radius <span>=</span> <span>0.1</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		circleOffsetAnim<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		circleOffsetAnim<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle<span>,</span> circleSize<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>postShd<span>)</span><span>;</span>
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>ONE</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>

		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTextureLinear<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>)</span><span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationPost<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> <span>(</span><span>1.0</span> <span>/</span> aspect_ratio<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationRed<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> <span>1.0</span> <span>/</span> <span>(</span>width <span>/</span> height<span>)</span><span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>deleteRenderbuffer</span><span>(</span>renderbuffer<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>resolveFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><p><a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleSSAA.js">circleSSAA.js</a> draws at twice the resolution to a texture, which fragment shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/post.fs">post.fs</a> reads from at standard resolution with <a href="https://docs.gl/es2/glTexParameter">GL_LINEAR</a> to perform SSAA. So we have <em>four</em> input pixels for every <em>one</em> output pixel we draw to the screen. But it‚Äôs somewhat strange: There is definitely Anti-Aliasing happening, but less than expected.</p><blockquote><p>There should be 4 steps of transparency, but we only get two!</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"/></blockquote><p>Especially at lower resolutions, we can see the circle <em>does</em> actually have 4 steps of transparency, but mainly at the 45¬∞ ‚Äúdiagonals‚Äù of the circle. A circle has of course no sides, but at the axis-aligned ‚Äúbottom‚Äù there are only 2 steps of transparency: Fully Opaque and 50% transparent, the 25% and 75% transparency steps are missing.</p><h3 id="conceptually-simple%2C-actually-hard" tabindex="-1">Conceptually simple, actually hard <a href="#conceptually-simple%2C-actually-hard">#</a></h3><p>We aren‚Äôt sampling against the circle shape at twice the resolution, we are sampling against the quantized result of the circle shape. Twice the resolution, but discrete pixels nonetheless. The combination of pixelation and sample placement doesn‚Äôt hold enough information where we need it the most: at the axis-aligned ‚Äúflat parts‚Äù.</p><blockquote><p>Four times the memory <b>and</b> four times the calculation requirement, but only a half-assed result.</p><img src="https://blog.frost.kiwi/assets/kiwis/facepalm.svg"/></blockquote><p>Implementing SSAA properly is a minute craft. Here we are drawing to a 2x resolution texture and down-sampling it with linear interpolation. So actually, this implementation needs 5x the amount of VRAM. A proper implementation samples the scene multiple times and combines the result without an intermediary buffer.</p><blockquote><p>With our implementation, we can&#39;t even do more than 2xSSAA with one texture read, as linear interpolation happens <a href="https://stackoverflow.com/questions/53896032/">only with 2x2 samples</a>.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"/></blockquote><p>To combat axis-alignment artifacts like with our circle above, we need to place our SSAA samples better. There are <a href="https://en.wikipedia.org/wiki/Supersampling#Supersampling_patterns">multiple ways to do so</a>, all with pros and cons. To implement SSAA properly, we need deep integration with the rendering pipeline. For 3D primitives, this happens below API or engine, in the realm of vendors and drivers.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/sample-patterns.svg" alt="SAA sample patterns"/><figcaption>SSAA sample patterns. <a href="https://en.wikipedia.org/wiki/Supersampling#Supersampling_patterns">Source</a></figcaption></figure><p>In fact, some of the best implementations were <a href="https://web.archive.org/web/20180716171211/https://naturalviolence.webs.com/sgssaa.htm">discovered by vendors on accident</a>, like <a href="https://www.youtube.com/watch?v=ntlYwrbUlWo">SGSSAA</a>. There are also ways in which SSAA can make your scene look <em>worse</em>. Depending on implementation, SSAA messes with <a href="https://en.wikipedia.org/wiki/Mipmap">mip-map</a> calculations. As a result the mip-map lod-bias may need adjustment, as explained in the <a href="https://web.archive.org/web/20180716171211/https://naturalviolence.webs.com/sgssaa.htm">article above</a>.</p><blockquote><p>WebXR UI package <a href="https://github.com/felixmariotto/three-mesh-ui">three-mesh-ui</a>, a package mature enough to be <a href="https://developers.meta.com/horizon/blog/project-flowerbed-a-webxr-case-study/">used by Meta</a>, uses shader-based rotated grid super sampling to achieve sharp text rendering in VR, <a href="https://github.com/felixmariotto/three-mesh-ui/blob/b9c19e542e5234bc964a44c1e7aa4eeb16676757/build/three-mesh-ui.module.js#L2964">as seen in the code</a>.</p><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"/></blockquote><h2 id="msaa" tabindex="-1">MSAA <a href="#msaa">#</a></h2><p><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">MSAA</a> is super sampling, but only at the silhouette of models, overlapping geometry, and texture edges if ‚Äú<a href="https://bgolus.medium.com/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Alpha to Coverage</a>‚Äù is enabled. MSAA is implemented by the graphics card in-hardware by the graphics vendors and what is supported depends on hardware. In the select box below you can choose different MSAA levels for our circle.</p><p><a href="https://opengl.gpuinfo.org/displaycapability.php?name=GL_MAX_SAMPLES">There is up to MSAA x64</a>, but what is available is implementation defined. WebGL 1 has no support, which is why the next canvas initializes a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext">WebGL 2</a> context. In WebGL, NVIDIA limits MSAA to 8x on Windows, even if more is supported, whilst on Linux no such limit is in place. On smartphones you will only get exactly 4x, as discussed below.</p><div><p> <label for="nativeMSAA">Native<p>Resolution</p></label></p><p> <label for="halfMSAA">¬Ω<p>Resolution</p></label></p><p> <label for="quarterMSAA">¬º<p>Resolution</p></label></p><p> <label for="eightMSAA">‚Öõ<p>Resolution</p></label></p></div><canvas id="canvasMSAA" width="100%" height="400px"></canvas><div><p> <label for="1pxMSAA"><svg aria-hidden="true" height="2.3ex" viewBox="0 -750 1728 1000" width="3.9ex" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path d="M94 612q78 4 117 20t73 46h23V73h123V0H88v73h125v244l-1 243q-2-2-15-6t-42-8-59-6l-13-1v73h11Z" id="x"></path><path d="M166 404q28 20 75 35t96 16h4q69 0 110-85 32-63 32-148 0-94-50-163T306-10q-24 0-46 5T222 7t-28 14-18 12-8 5v-232H75v638h90v-20l1-20Zm224-182q0 65-36 109t-88 45-89-36l-9-8V118q32-52 89-52 56 0 94 46t39 110Z" id="y"></path><path d="M187 229 6 444h101l120-150 117 150h49l49-1q-3-6-143-175l-32-39L460 0H359l-65 88-32 43-26 35-9 11L100 0H0l47 58 93 113q47 56 47 58Z" id="z"></path></defs><g data-mml-node="math" fill="currentColor" stroke="currentColor" stroke-width="0"><g data-mml-node="mstyle"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mtable"><g data-mml-node="mtr"><g data-mml-node="mtd"><use data-c="1D7E3" xlink:href="#x" transform="scale(1 -1)" data-mml-node="mn"></use><g data-mml-node="mtext" transform="matrix(1 0 0 -1 500 0)"><use data-c="1D5C9" xlink:href="#y" transform="translate(250)"></use><use data-c="1D5D1" xlink:href="#z" transform="translate(767)"></use></g></g></g></g></g></g></g></svg><p>edge smoothing</p></label></p><p> <label for="sqrt2pxMSAA"><svg aria-hidden="true" height="3.1ex" viewBox="0 -934 8030 1368" width="18.2ex" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path d="m263 249 52-119 102-238q51-119 53-120l255 530 257 537q7 11 19 11 7 0 12-6t7-12v-6L741 243 540-176l-71-148q-10-21-16-24-4-2-17-2l-12 1L315-96 205 156l-34-26-34-26-26 26 152 119Z" id="d"></path><path d="M94 612q78 4 117 20t73 46h23V73h123V0H88v73h125v244l-1 243q-2-2-15-6t-42-8-59-6l-13-1v73h11Z" id="a"></path><path d="M222 599q-32 0-56-14t-38-35-20-41-11-35-4-15l-26 33-25 34 5 13q25 69 73 103t105 35q79 0 130-33 94-65 94-190 0-81-88-164l-46-40q-36-30-116-106l-62-59 156 1h156V0H50v79l166 163q68 60 101 107t34 107q0 61-36 102t-93 41Z" id="b"></path><path d="M56 237v13l14 20h299v150l1 150q10 13 19 13 13 0 20-15V270h298q15-8 15-20t-15-20H409V-68q-8-14-18-14h-4q-12 0-18 14v298H70q-14 7-14 20Z" id="c"></path><path d="M56 350q0 13 14 20h637q15-8 15-20 0-11-14-19l-318-1H72q-16 5-16 20Zm0-200q0 15 16 20h636q14-10 14-20 0-12-15-20H70q-14 7-14 20Z" id="e"></path><path d="M95 178q-6 0-14 8t-9 14 31 30 66 50 38 29q2 2 5 2h1q6 0 14-17t54-117l31-69 85-185 104 213 206 429q103 216 107 221 6 14 20 14 7 0 12-6t7-12v-6L620 293 385-193q-4-7-19-7-9 0-12 3L256 15l-96 210-16-11-31-24q-16-12-18-12Z" id="f"></path><path d="M166 404q28 20 75 35t96 16h4q69 0 110-85 32-63 32-148 0-94-50-163T306-10q-24 0-46 5T222 7t-28 14-18 12-8 5v-232H75v638h90v-20l1-20Zm224-182q0 65-36 109t-88 45-89-36l-9-8V118q32-52 89-52 56 0 94 46t39 110Z" id="h"></path><path d="M187 229 6 444h101l120-150 117 150h49l49-1q-3-6-143-175l-32-39L460 0H359l-65 88-32 43-26 35-9 11L100 0H0l47 58 93 113q47 56 47 58Z" id="i"></path></defs><g data-mml-node="math" fill="currentColor" stroke="currentColor" stroke-width="0"><g data-mml-node="mstyle"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mtable"><g data-mml-node="mtr"><g data-mml-node="mtd"><g data-mml-node="msqrt"><g data-mml-node="msup"><use data-c="1D7E3" xlink:href="#a" transform="matrix(1 0 0 -1 1020 184)" data-mml-node="mn"></use><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><use data-c="1D7E4" xlink:href="#b" transform="matrix(.707 0 0 -.707 1553 -105)" data-mml-node="mn"></use></g></g><use data-c="2B" xlink:href="#c" transform="matrix(1 0 0 -1 2179 184)" data-mml-node="mo"></use><g data-mml-node="msup"><use data-c="1D7E3" xlink:href="#a" transform="matrix(1 0 0 -1 3179 184)" data-mml-node="mn"></use><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><use data-c="1D7E4" xlink:href="#b" transform="matrix(.707 0 0 -.707 3712 -105)" data-mml-node="mn"></use></g></g><use data-c="221A" xlink:href="#d" transform="matrix(1 0 0 -1 0 -24)" data-mml-node="mo"></use><path d="M1020-814h3096v-60H1020z" stroke="none"></path></g><use data-c="3D" xlink:href="#e" transform="matrix(1 0 0 -1 4393 184)" data-mml-node="mo"></use><g data-mml-node="msqrt"><use data-c="1D7E4" xlink:href="#b" transform="matrix(1 0 0 -1 6302 184)" data-mml-node="mn"></use><use data-c="221A" xlink:href="#f" transform="matrix(1 0 0 -1 5449 30)" data-mml-node="mo"></use><path d="M6302-710h500v-60h-500z" stroke="none"></path></g><g data-mml-node="mtext" transform="matrix(1 0 0 -1 6802 184)"><use data-c="A0" xlink:href="#g"></use><use data-c="1D5C9" xlink:href="#h" transform="translate(250)"></use><use data-c="1D5D1" xlink:href="#i" transform="translate(767)"></use></g></g></g></g></g></g></g></svg><p>edge smoothing</p></label></p></div><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/msaa.png">MSAA 4x Screenshot</a>, in case WebGL 2 doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/msaa.png" alt="image"/></p></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleMSAA.js">circleMSAA.js</a></summary><pre><code><span>function</span> <span>setupMSAA</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> circleSimpleFragSrc<span>,</span> postVtxSrc<span>,</span> postFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>,</span> radioName<span>,</span> radioSmoothSize</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> frameTexture<span>,</span> circleDrawFramebuffer<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>let</span> pixelSmoothSize <span>=</span> <span>1</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl2&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span><span>,</span>
			<span>premultipliedAlpha</span><span>:</span> <span>true</span>
		<span>}</span>
	<span>)</span><span>;</span>

	
	<span>let</span> samples <span>=</span> <span>1</span><span>;</span>
	<span>let</span> renderbuffer <span>=</span> <span>null</span><span>;</span>
	<span>let</span> resolveFramebuffer <span>=</span> <span>null</span><span>;</span>

	<span>const</span> maxSamples <span>=</span> gl<span>.</span><span>getParameter</span><span>(</span>gl<span>.</span><span>MAX_SAMPLES</span><span>)</span><span>;</span>

	
	<span>const</span> msaaSelect <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#34;MSAA&#34;</span><span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>let</span> option <span>of</span> msaaSelect<span>.</span>options<span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>parseInt</span><span>(</span>option<span>.</span>value<span>)</span> <span>&lt;=</span> maxSamples<span>)</span> <span>{</span>
			option<span>.</span>disabled <span>=</span> <span>false</span><span>;</span>
		<span>}</span>
	<span>}</span>
	samples <span>=</span> <span>parseInt</span><span>(</span>msaaSelect<span>.</span>value<span>)</span><span>;</span>

	
	msaaSelect<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		
		samples <span>=</span> <span>parseInt</span><span>(</span>msaaSelect<span>.</span>value<span>)</span><span>;</span>
		<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	<span>const</span> radiosSmooth <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioSmoothSize<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radiosSmooth<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			pixelSmoothSize <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>const</span> circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelSizeCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;pixelSize&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>
	<span>const</span> circleShd_step <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleSimpleFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocation_step <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd_step<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircle_step <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd_step<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircle_step <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd_step<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> postShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> postVtxSrc<span>,</span> postFragSrc<span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> circleOffsetAnim <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>0.0</span><span>,</span> <span>0.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		gl<span>.</span><span>deleteRenderbuffer</span><span>(</span>renderbuffer<span>)</span><span>;</span>
		renderbuffer <span>=</span> gl<span>.</span><span>createRenderbuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindRenderbuffer</span><span>(</span>gl<span>.</span><span>RENDERBUFFER</span><span>,</span> renderbuffer<span>)</span><span>;</span>
		<span>const</span> errorMessageElement <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;sampleErrorMessage&#39;</span><span>)</span><span>;</span>
		
		<span>if</span> <span>(</span>samples <span>!=</span> <span>1</span><span>)</span> <span>{</span>
			gl<span>.</span><span>renderbufferStorageMultisample</span><span>(</span>gl<span>.</span><span>RENDERBUFFER</span><span>,</span> samples<span>,</span> gl<span>.</span><span>RGBA8</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>
			gl<span>.</span><span>framebufferRenderbuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>RENDERBUFFER</span><span>,</span> renderbuffer<span>)</span><span>;</span>

			<span>const</span> actualSamples <span>=</span> gl<span>.</span><span>getRenderbufferParameter</span><span>(</span>
				gl<span>.</span><span>RENDERBUFFER</span><span>,</span>
				gl<span>.</span><span>RENDERBUFFER_SAMPLES</span>
			<span>)</span><span>;</span>
			<span>if</span> <span>(</span>samples <span>!==</span> actualSamples<span>)</span> <span>{</span>
				errorMessageElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;block&#39;</span><span>;</span>
				errorMessageElement<span>.</span>textContent <span>=</span> <span><span>`</span><span>‚ö†Ô∏è You chose MSAAx</span><span><span>${</span>samples<span>}</span></span><span>, but the graphics driver forced it to MSAAx</span><span><span>${</span>actualSamples<span>}</span></span><span>. You are probably on a mobile GPU, where this behavior is expected.</span><span>`</span></span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				errorMessageElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
			<span>}</span>
		<span>}</span> <span>else</span> <span>{</span>
			errorMessageElement<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>resolveFramebuffer<span>)</span><span>;</span>
		resolveFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>DRAW_FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>DRAW_FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		gl<span>.</span><span>disable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>
		gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>SAMPLE_ALPHA_TO_COVERAGE</span><span>)</span><span>;</span>
		
		<span>if</span> <span>(</span>samples <span>==</span> <span>1</span><span>)</span>
			gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>
		<span>else</span>
			gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>samples <span>==</span> <span>1</span><span>)</span>
			gl<span>.</span><span>useProgram</span><span>(</span>circleShd_step<span>)</span><span>;</span>
		<span>else</span>
			gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>

		
		<span>var</span> radius <span>=</span> <span>0.1</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		circleOffsetAnim<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		circleOffsetAnim<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>
		<span>if</span> <span>(</span>samples <span>==</span> <span>1</span><span>)</span> <span>{</span>
			
			gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle_step<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation_step<span>,</span> aspect_ratio<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle_step<span>,</span> circleSize<span>)</span><span>;</span>
		<span>}</span>
		<span>else</span> <span>{</span>
			gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation<span>,</span> aspect_ratio<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle<span>,</span> circleSize<span>)</span><span>;</span>
			gl<span>.</span><span>uniform1f</span><span>(</span>pixelSizeCircle<span>,</span> <span>(</span><span>2.0</span> <span>/</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>)</span> <span>*</span> pixelSmoothSize<span>)</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>disable</span><span>(</span>gl<span>.</span><span>SAMPLE_ALPHA_TO_COVERAGE</span><span>)</span><span>;</span>
		gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		<span>if</span> <span>(</span>samples <span>!==</span> <span>1</span><span>)</span> <span>{</span>
			gl<span>.</span><span>useProgram</span><span>(</span>postShd<span>)</span><span>;</span>
			gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>ONE</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>

			
			gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>READ_FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
			gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>DRAW_FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>
			gl<span>.</span><span>blitFramebuffer</span><span>(</span>
				<span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>,</span>
				<span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>,</span>
				gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>,</span> gl<span>.</span><span>LINEAR</span>
			<span>)</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationPost<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> <span>(</span><span>1.0</span> <span>/</span> aspect_ratio<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationRed<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> <span>1.0</span> <span>/</span> <span>(</span>width <span>/</span> height<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>deleteRenderbuffer</span><span>(</span>renderbuffer<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>resolveFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><blockquote><p>What is edge smoothing and how does MSAA even know what to sample against? For now we skip the shader code and implementation. First let&#39;s take a look at MSAA&#39;s pros and cons in general.</p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"/></blockquote><h3 id="implementation-specific-headaches" tabindex="-1">Implementation specific headaches <a href="#implementation-specific-headaches">#</a></h3><p>We rely on hardware to do the Anti-Aliasing, which obviously leads to the problem that user hardware may not support what we need. The sampling patterns MSAA uses may also do things we don‚Äôt expect. Depending on what your hardware does, you may see the circle‚Äôs edge transparency steps appearing ‚Äúin the wrong order‚Äù.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/outoforder.png" alt="Sample pattern and circle shape clash: pixels are seemingly &#39;checkerboxed&#39;"/><figcaption>Sample pattern and circle shape clash: pixels are seemingly &#34;checkerboxed&#34;</figcaption></figure><p>When MSAA became required with <a href="https://en.wikipedia.org/wiki/OpenGL#OpenGL_3.0">OpenGL 3</a> &amp; <a href="https://en.wikipedia.org/wiki/DirectX#DirectX_10">DirectX 10</a> era of hardware, support was especially hit &amp; miss. Even latest <a href="https://en.wikipedia.org/wiki/Intel_GMA#GMA_4500">Intel GMA</a> iGPUs expose the OpenGL extension <a href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_framebuffer_multisample.txt"><code>EXT_framebuffer_multisample</code></a>, but don‚Äôt in-fact support MSAA, <a href="https://community.khronos.org/t/yet-another-intel-multisample-thread/69614/2">which led to confusion</a>. But also in more recent smartphones, support just <a href="https://issues.chromium.org/issues/40114751">wasn‚Äôt that clear-cut</a>.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/iOSroundedMSAA.png" alt="iOS 2xMSAA, created by rounding transparency of 4xMSAA"/><figcaption>Double edges - iOS 2xMSAA, created by iOS rounding transparency of 4xMSAA</figcaption></figure><p>Mobile chips support <em>exactly</em> MSAAx4 and things are weird. Android will let you pick 2x, but the driver will force 4x anyways. iPhones &amp; iPads do something rather stupid: Choosing 2x will make it 4x, but transparency will be rounded to nearest 50% multiple, leading to double edges in our example. There is hardware specific reason:</p><h3 id="performance-cost%3A-(maybe)-zero" tabindex="-1">Performance cost: (maybe) Zero <a href="#performance-cost%3A-(maybe)-zero">#</a></h3><p>Looking at modern video games, one might believe that MSAA is of the past. It usually brings a hefty performance penalty after all. Surprisingly, it‚Äôs still the king under certain circumstances and in very specific situations, even performance free.</p><blockquote><p>As a gamer, this goes against instinct...</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"/></blockquote><figure><video controls="" height="540" poster="vid/MSAA-PerformanceFree_thumb.jpg" width="960"><source src="vid/MSAA-PerformanceFree.mp4" type="video/mp4"/></video><figcaption>Video: MSAA 4x is performance free in certain contexts</figcaption></figure><blockquote><p><a href="https://www.linkedin.com/in/rahulprasad2/">Rahul Prasad:</a> Use MSAA [‚Ä¶] It‚Äôs actually not as expensive on mobile as it is on desktop, it‚Äôs one of the nice things you get on mobile. [‚Ä¶] On some (mobile) GPUs 4x (MSAA) is free, so use it when you have it.</p></blockquote><p>As explained by <a href="https://www.linkedin.com/in/rahulprasad2/">Rahul Prasad</a> in the above talk, in VR 4xMSAA is a must and may come free on certain mobile GPUs. The specific reason would derail the blog post, but in case you want to go down that particular rabbit hole, here is Epic Games‚Äô <a href="https://www.linkedin.com/in/niklas-smedberg-a96466/">Niklas Smedberg</a> giving a run-down.</p><figure><video controls="" height="540" poster="vid/tile-based-gpus_thumb.jpg" width="960"><source src="vid/tile-based-gpus.mp4" type="video/mp4"/></video><figcaption>Video: Tiled based rendering GPU architecture</figcaption></figure><p>In short, this is possible under the condition of <a href="https://gamedevelopment.tutsplus.com/forward-rendering-vs-deferred-rendering--gamedev-12342a">forward rendering</a> with geometry that is not too dense and the GPU having <a href="https://developer.arm.com/documentation/102662/0100/Tile-based-GPUs">tiled-based rendering architecture</a>, which allows the GPU to perform MSAA calculations without heavy memory access and thus <a href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/#performance-cost%3A-zero">latency hiding</a> the cost of the calculation. Here‚Äôs <a href="https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/msaa#color-resolve">deep dive</a>, if you are interested.</p><h3 id="a-complex-toolbox" tabindex="-1">A complex toolbox <a href="#a-complex-toolbox">#</a></h3><p>MSAA <a href="https://docs.gl/gl3/glGetMultisample">gives you access</a> to the samples, making <a href="https://therealmjp.github.io/posts/msaa-resolve-filters/">custom MSAA filtering curves</a> a possibility. It also allows you to <a href="https://bgolus.medium.com/rendering-a-sphere-on-a-quad-13c92025570c">merge both standard mesh-based and signed-distance-field rendering</a> via <a href="https://bgolus.medium.com/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">alpha to coverage</a>. This complex features set made possible the most out-of-the-box thinking I ever witnessed in graphics programming:</p><p><a href="https://en.wikipedia.org/wiki/Assassin%27s_Creed_Unity">Assassin‚Äôs Creed Unity</a> used MSAA to render at half resolution and reconstruct only some buffers to full-res from MSAA samples, as described on page 48 of the talk ‚Äú<a href="https://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf">GPU-Driven Rendering Pipelines</a>‚Äù by <a href="https://www.linkedin.com/in/ulrich-haar-730407218">Ulrich Haar</a> and <a href="https://x.com/SebAaltonen">Sebastian Aaltonen</a>. Kinda like <a href="https://developer.nvidia.com/vrworks/graphics/variablerateshading">variable rate shading</a>, but implemented with duct-tape and without vendor support.</p><blockquote><p>The brain-melting lengths to which graphics programmers go to utilize hardware acceleration to the last drop has me sometimes in awe.</p><img src="https://blog.frost.kiwi/assets/kiwis/surprised.svg"/></blockquote><h2 id="post-process-anti-aliasing" tabindex="-1">Post-Process Anti-Aliasing <a href="#post-process-anti-aliasing">#</a></h2><p>In 2009 a <a href="https://web.archive.org/web/20141205052029/http://visual-computing.intel-research.net/publications/papers/2009/mlaa/mlaa.pdf">paper</a> by <a href="https://research.nvidia.com/person/alexander-reshetov">Alexander Reshetov</a> struck the graphics programming world like a ton of bricks: take the blocky, aliased result of the rendered image, find edges and classify the pixels into tetris-like shapes with per-shape filtering rules and remove the blocky edge. Anti-Aliasing based on the <a href="https://en.wikipedia.org/wiki/Mathematical_morphology">morphology</a> of pixels - <a href="https://www.iryoku.com/mlaa/">MLAA</a> was born.</p><p>Computationally cheap, easy to implement. Later it was refined with more emphasis on removing sub-pixel artifacts to become <a href="https://www.iryoku.com/smaa/">SMAA</a>. It became a fan favorite, with <a href="https://mrhaandi.blogspot.com/p/injectsmaa.html?m=1">an injector being developed early on</a> to put SMAA into games that didn‚Äôt support it. Some considered these too blurry, the saying ‚Äúvaseline on the screen‚Äù was coined.</p><blockquote><p>It was the future, a sign of things to come. No more shaky hardware support. Like <a href="https://en.wikipedia.org/wiki/Fixed-function">Fixed-Function pipelines</a> died in favor of programmable shaders Anti-Aliasing too became &#34;shader based&#34;.</p><img src="https://blog.frost.kiwi/assets/kiwis/book.svg"/></blockquote><h3 id="fxaa" tabindex="-1">FXAA <a href="#fxaa">#</a></h3><p>We‚Äôll take a close look at an algorithm that was inspired by MLAA, developed by <a href="https://x.com/NOTimothyLottes">Timothy Lottes</a>. ‚ÄúFast approximate anti-aliasing‚Äù, <a href="https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf">FXAA</a>. In fact, when it came into wide circulation, it received some incredible press. <a href="https://www.realtimerendering.com/blog/fxaa-rules-ok/">Among others</a>, <a href="https://blog.codinghorror.com/about-me/">Jeff Atwood</a> pulled neither bold fonts nor punches in his <a href="https://blog.codinghorror.com/fast-approximate-anti-aliasing-fxaa/">2011 blog post</a>, later <a href="http://kotaku.com/5866780/">republished by Kotaku</a>.</p><blockquote><p><a href="https://blog.codinghorror.com/about-me/"><strong>Jeff Atwood</strong></a>: The FXAA method is so good, in fact, it makes all other forms of full-screen anti-aliasing pretty much obsolete overnight. <strong>If you have an FXAA option in your game, you should enable it immediately</strong> and ignore any other AA options.</p></blockquote><p>Let‚Äôs see what the hype was about. The final version publicly released was FXAA 3.11 on <a href="https://web.archive.org/web/20120121124756/http://timothylottes.blogspot.com/2011/08/fxaa-311-bug-fixes-for-360.html">August 12th 2011</a> and the following demos are based on this. First, let‚Äôs take a look at our circle with FXAA doing the Anti-Aliasing at default settings.</p><div><p> <label for="nativeFXAA">Native<p>Resolution</p></label></p><p> <label for="halfFXAA">¬Ω<p>Resolution</p></label></p><p> <label for="quarterFXAA">¬º<p>Resolution</p></label></p><p> <label for="eightFXAA">‚Öõ<p>Resolution</p></label></p></div><canvas id="canvasFXAA" width="100%" height="400px"></canvas><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/fxaa.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/fxaa.png" alt="image"/></p></details><details><summary>WebGL FXAA Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/post-FXAA.fs">post-FXAA.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>uniform</span> <span>sampler2D</span> u_texture<span>;</span>
<span>varying</span> <span>vec2</span> texCoord<span>;</span>

<span>uniform</span> <span>vec2</span> RcpFrame<span>;</span>



<span>float</span> <span>FxaaLuma</span><span>(</span><span>vec4</span> rgba<span>)</span> <span>{</span> <span>return</span> rgba<span>.</span>w<span>;</span> <span>}</span>
<span>vec4</span> <span>FxaaPixelShader</span><span>(</span>
	<span>vec2</span> pos<span>,</span>
	<span>sampler2D</span> tex<span>,</span>
	<span>vec2</span> fxaaQualityRcpFrame<span>,</span>
	<span>float</span> fxaaQualitySubpix<span>,</span>
	<span>float</span> fxaaQualityEdgeThreshold<span>,</span>
	<span>float</span> fxaaQualityEdgeThresholdMin<span>)</span>
<span>{</span>
	<span>vec2</span> posM<span>;</span>
	posM<span>.</span>x <span>=</span> pos<span>.</span>x<span>;</span>
	posM<span>.</span>y <span>=</span> pos<span>.</span>y<span>;</span>
	<span>vec4</span> rgbyM <span>=</span> <span>texture2D</span><span>(</span>tex<span>,</span> posM<span>)</span><span>;</span>

	<span>float</span> lumaS <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> lumaE <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> lumaN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> lumaW <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>

	<span>float</span> maxSM <span>=</span> <span>max</span><span>(</span>lumaS<span>,</span> rgbyM<span>.</span>w<span>)</span><span>;</span>
	<span>float</span> minSM <span>=</span> <span>min</span><span>(</span>lumaS<span>,</span> rgbyM<span>.</span>w<span>)</span><span>;</span>
	<span>float</span> maxESM <span>=</span> <span>max</span><span>(</span>lumaE<span>,</span> maxSM<span>)</span><span>;</span>
	<span>float</span> minESM <span>=</span> <span>min</span><span>(</span>lumaE<span>,</span> minSM<span>)</span><span>;</span>
	<span>float</span> maxWN <span>=</span> <span>max</span><span>(</span>lumaN<span>,</span> lumaW<span>)</span><span>;</span>
	<span>float</span> minWN <span>=</span> <span>min</span><span>(</span>lumaN<span>,</span> lumaW<span>)</span><span>;</span>
	<span>float</span> rangeMax <span>=</span> <span>max</span><span>(</span>maxWN<span>,</span> maxESM<span>)</span><span>;</span>
	<span>float</span> rangeMin <span>=</span> <span>min</span><span>(</span>minWN<span>,</span> minESM<span>)</span><span>;</span>
	<span>float</span> rangeMaxScaled <span>=</span> rangeMax <span>*</span> fxaaQualityEdgeThreshold<span>;</span>
	<span>float</span> range <span>=</span> rangeMax <span>-</span> rangeMin<span>;</span>
	<span>float</span> rangeMaxClamped <span>=</span> <span>max</span><span>(</span>fxaaQualityEdgeThresholdMin<span>,</span> rangeMaxScaled<span>)</span><span>;</span>
	<span>bool</span> earlyExit <span>=</span> range <span>&lt;</span> rangeMaxClamped<span>;</span>

	<span>if</span> <span>(</span>earlyExit<span>)</span>
		<span>return</span> rgbyM<span>;</span>

	<span>float</span> lumaNW <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> lumaSE <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> lumaNE <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> lumaSW <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>

	<span>float</span> lumaNS <span>=</span> lumaN <span>+</span> lumaS<span>;</span>
	<span>float</span> lumaWE <span>=</span> lumaW <span>+</span> lumaE<span>;</span>
	<span>float</span> subpixRcpRange <span>=</span> <span>1.0</span> <span>/</span> range<span>;</span>
	<span>float</span> subpixNSWE <span>=</span> lumaNS <span>+</span> lumaWE<span>;</span>
	<span>float</span> edgeHorz1 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> rgbyM<span>.</span>w<span>)</span> <span>+</span> lumaNS<span>;</span>
	<span>float</span> edgeVert1 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> rgbyM<span>.</span>w<span>)</span> <span>+</span> lumaWE<span>;</span>

	<span>float</span> lumaNESE <span>=</span> lumaNE <span>+</span> lumaSE<span>;</span>
	<span>float</span> lumaNWNE <span>=</span> lumaNW <span>+</span> lumaNE<span>;</span>
	<span>float</span> edgeHorz2 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaE<span>)</span> <span>+</span> lumaNESE<span>;</span>
	<span>float</span> edgeVert2 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaN<span>)</span> <span>+</span> lumaNWNE<span>;</span>

	<span>float</span> lumaNWSW <span>=</span> lumaNW <span>+</span> lumaSW<span>;</span>
	<span>float</span> lumaSWSE <span>=</span> lumaSW <span>+</span> lumaSE<span>;</span>
	<span>float</span> edgeHorz4 <span>=</span> <span>(</span><span>abs</span><span>(</span>edgeHorz1<span>)</span> <span>*</span> <span>2.0</span><span>)</span> <span>+</span> <span>abs</span><span>(</span>edgeHorz2<span>)</span><span>;</span>
	<span>float</span> edgeVert4 <span>=</span> <span>(</span><span>abs</span><span>(</span>edgeVert1<span>)</span> <span>*</span> <span>2.0</span><span>)</span> <span>+</span> <span>abs</span><span>(</span>edgeVert2<span>)</span><span>;</span>
	<span>float</span> edgeHorz3 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaW<span>)</span> <span>+</span> lumaNWSW<span>;</span>
	<span>float</span> edgeVert3 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaS<span>)</span> <span>+</span> lumaSWSE<span>;</span>
	<span>float</span> edgeHorz <span>=</span> <span>abs</span><span>(</span>edgeHorz3<span>)</span> <span>+</span> edgeHorz4<span>;</span>
	<span>float</span> edgeVert <span>=</span> <span>abs</span><span>(</span>edgeVert3<span>)</span> <span>+</span> edgeVert4<span>;</span>

	<span>float</span> subpixNWSWNESE <span>=</span> lumaNWSW <span>+</span> lumaNESE<span>;</span>
	<span>float</span> lengthSign <span>=</span> fxaaQualityRcpFrame<span>.</span>x<span>;</span>
	<span>bool</span> horzSpan <span>=</span> edgeHorz <span>&gt;=</span> edgeVert<span>;</span>
	<span>float</span> subpixA <span>=</span> subpixNSWE <span>*</span> <span>2.0</span> <span>+</span> subpixNWSWNESE<span>;</span>

	<span>if</span> <span>(</span><span>!</span>horzSpan<span>)</span>
		lumaN <span>=</span> lumaW<span>;</span>
	<span>if</span> <span>(</span><span>!</span>horzSpan<span>)</span>
		lumaS <span>=</span> lumaE<span>;</span>
	<span>if</span> <span>(</span>horzSpan<span>)</span>
		lengthSign <span>=</span> fxaaQualityRcpFrame<span>.</span>y<span>;</span>
	<span>float</span> subpixB <span>=</span> <span>(</span>subpixA <span>*</span> <span>(</span><span>1.0</span> <span>/</span> <span>12.0</span><span>)</span><span>)</span> <span>-</span> rgbyM<span>.</span>w<span>;</span>

	<span>float</span> gradientN <span>=</span> lumaN <span>-</span> rgbyM<span>.</span>w<span>;</span>
	<span>float</span> gradientS <span>=</span> lumaS <span>-</span> rgbyM<span>.</span>w<span>;</span>
	<span>float</span> lumaNN <span>=</span> lumaN <span>+</span> rgbyM<span>.</span>w<span>;</span>
	<span>float</span> lumaSS <span>=</span> lumaS <span>+</span> rgbyM<span>.</span>w<span>;</span>
	<span>bool</span> pairN <span>=</span> <span>abs</span><span>(</span>gradientN<span>)</span> <span>&gt;=</span> <span>abs</span><span>(</span>gradientS<span>)</span><span>;</span>
	<span>float</span> gradient <span>=</span> <span>max</span><span>(</span><span>abs</span><span>(</span>gradientN<span>)</span><span>,</span> <span>abs</span><span>(</span>gradientS<span>)</span><span>)</span><span>;</span>
	<span>if</span> <span>(</span>pairN<span>)</span>
		lengthSign <span>=</span> <span>-</span>lengthSign<span>;</span>
	<span>float</span> subpixC <span>=</span> <span>clamp</span><span>(</span><span>abs</span><span>(</span>subpixB<span>)</span> <span>*</span> subpixRcpRange<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>

	<span>vec2</span> posB<span>;</span>
	posB<span>.</span>x <span>=</span> posM<span>.</span>x<span>;</span>
	posB<span>.</span>y <span>=</span> posM<span>.</span>y<span>;</span>
	<span>vec2</span> offNP<span>;</span>
	offNP<span>.</span>x <span>=</span> <span>(</span><span>!</span>horzSpan<span>)</span> <span>?</span> <span>0.0</span> <span>:</span> fxaaQualityRcpFrame<span>.</span>x<span>;</span>
	offNP<span>.</span>y <span>=</span> <span>(</span>horzSpan<span>)</span> <span>?</span> <span>0.0</span> <span>:</span> fxaaQualityRcpFrame<span>.</span>y<span>;</span>
	<span>if</span> <span>(</span><span>!</span>horzSpan<span>)</span>
		posB<span>.</span>x <span>+=</span> lengthSign <span>*</span> <span>0.5</span><span>;</span>
	<span>if</span> <span>(</span>horzSpan<span>)</span>
		posB<span>.</span>y <span>+=</span> lengthSign <span>*</span> <span>0.5</span><span>;</span>

	<span>vec2</span> posN<span>;</span>
	posN<span>.</span>x <span>=</span> posB<span>.</span>x <span>-</span> offNP<span>.</span>x <span>*</span> <span>1.0</span><span>;</span>
	posN<span>.</span>y <span>=</span> posB<span>.</span>y <span>-</span> offNP<span>.</span>y <span>*</span> <span>1.0</span><span>;</span>
	<span>vec2</span> posP<span>;</span>
	posP<span>.</span>x <span>=</span> posB<span>.</span>x <span>+</span> offNP<span>.</span>x <span>*</span> <span>1.0</span><span>;</span>
	posP<span>.</span>y <span>=</span> posB<span>.</span>y <span>+</span> offNP<span>.</span>y <span>*</span> <span>1.0</span><span>;</span>
	<span>float</span> subpixD <span>=</span> <span>(</span><span>(</span><span>-</span><span>2.0</span><span>)</span> <span>*</span> subpixC<span>)</span> <span>+</span> <span>3.0</span><span>;</span>
	<span>float</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>)</span><span>)</span><span>;</span>
	<span>float</span> subpixE <span>=</span> subpixC <span>*</span> subpixC<span>;</span>
	<span>float</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>)</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span><span>!</span>pairN<span>)</span>
		lumaNN <span>=</span> lumaSS<span>;</span>
	<span>float</span> gradientScaled <span>=</span> gradient <span>*</span> <span>1.0</span> <span>/</span> <span>4.0</span><span>;</span>
	<span>float</span> lumaMM <span>=</span> rgbyM<span>.</span>w <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
	<span>float</span> subpixF <span>=</span> subpixD <span>*</span> subpixE<span>;</span>
	<span>bool</span> lumaMLTZero <span>=</span> lumaMM <span>&lt;</span> <span>0.0</span><span>;</span>

	lumaEndN <span>-=</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
	lumaEndP <span>-=</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
	<span>bool</span> doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
	<span>bool</span> doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
	<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
		posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> <span>1.5</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
		posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> <span>1.5</span><span>;</span>
	<span>bool</span> doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
		posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> <span>1.5</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
		posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> <span>1.5</span><span>;</span>

	<span>if</span> <span>(</span>doneNP<span>)</span>
	<span>{</span>
		<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
			lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
			lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
			lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
			lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
		doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
		doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
			posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> <span>2.0</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
			posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> <span>2.0</span><span>;</span>
		doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
			posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> <span>2.0</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
			posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> <span>2.0</span><span>;</span>

		<span>if</span> <span>(</span>doneNP<span>)</span>
		<span>{</span>
			<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
				lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
				lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
				lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
				lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
			doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
			doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
				posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> <span>4.0</span><span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
				posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> <span>4.0</span><span>;</span>
			doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
				posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> <span>4.0</span><span>;</span>
			<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
				posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> <span>4.0</span><span>;</span>

			<span>if</span> <span>(</span>doneNP<span>)</span>
			<span>{</span>
				<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
					lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
					lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
					lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
					lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
				doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
				doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
					posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> <span>12.0</span><span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneN<span>)</span>
					posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> <span>12.0</span><span>;</span>
				doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
					posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> <span>12.0</span><span>;</span>
				<span>if</span> <span>(</span><span>!</span>doneP<span>)</span>
					posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> <span>12.0</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>float</span> dstN <span>=</span> posM<span>.</span>x <span>-</span> posN<span>.</span>x<span>;</span>
	<span>float</span> dstP <span>=</span> posP<span>.</span>x <span>-</span> posM<span>.</span>x<span>;</span>
	<span>if</span> <span>(</span><span>!</span>horzSpan<span>)</span>
		dstN <span>=</span> posM<span>.</span>y <span>-</span> posN<span>.</span>y<span>;</span>
	<span>if</span> <span>(</span><span>!</span>horzSpan<span>)</span>
		dstP <span>=</span> posP<span>.</span>y <span>-</span> posM<span>.</span>y<span>;</span>

	<span>bool</span> goodSpanN <span>=</span> <span>(</span>lumaEndN <span>&lt;</span> <span>0.0</span><span>)</span> <span>!=</span> lumaMLTZero<span>;</span>
	<span>float</span> spanLength <span>=</span> <span>(</span>dstP <span>+</span> dstN<span>)</span><span>;</span>
	<span>bool</span> goodSpanP <span>=</span> <span>(</span>lumaEndP <span>&lt;</span> <span>0.0</span><span>)</span> <span>!=</span> lumaMLTZero<span>;</span>
	<span>float</span> spanLengthRcp <span>=</span> <span>1.0</span> <span>/</span> spanLength<span>;</span>

	<span>bool</span> directionN <span>=</span> dstN <span>&lt;</span> dstP<span>;</span>
	<span>float</span> dst <span>=</span> <span>min</span><span>(</span>dstN<span>,</span> dstP<span>)</span><span>;</span>
	<span>bool</span> goodSpan <span>=</span> directionN <span>?</span> goodSpanN <span>:</span> goodSpanP<span>;</span>
	<span>float</span> subpixG <span>=</span> subpixF <span>*</span> subpixF<span>;</span>
	<span>float</span> pixelOffset <span>=</span> <span>(</span>dst <span>*</span> <span>(</span><span>-</span>spanLengthRcp<span>)</span><span>)</span> <span>+</span> <span>0.5</span><span>;</span>
	<span>float</span> subpixH <span>=</span> subpixG <span>*</span> fxaaQualitySubpix<span>;</span>

	<span>float</span> pixelOffsetGood <span>=</span> goodSpan <span>?</span> pixelOffset <span>:</span> <span>0.0</span><span>;</span>
	<span>float</span> pixelOffsetSubpix <span>=</span> <span>max</span><span>(</span>pixelOffsetGood<span>,</span> subpixH<span>)</span><span>;</span>
	<span>if</span> <span>(</span><span>!</span>horzSpan<span>)</span>
		posM<span>.</span>x <span>+=</span> pixelOffsetSubpix <span>*</span> lengthSign<span>;</span>
	<span>if</span> <span>(</span>horzSpan<span>)</span>
		posM<span>.</span>y <span>+=</span> pixelOffsetSubpix <span>*</span> lengthSign<span>;</span>

	<span>return</span> <span>vec4</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM<span>)</span><span>.</span>xyz<span>,</span> rgbyM<span>.</span>w<span>)</span><span>;</span>
<span>}</span>


<span>void</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	gl_FragColor <span>=</span> <span>FxaaPixelShader</span><span>(</span>
		texCoord<span>,</span> u_texture<span>,</span> RcpFrame<span>,</span> <span>0.75</span><span>,</span> <span>0.166</span><span>,</span> <span>0.0833</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleFXAA.js">circleFXAA.js</a></summary><pre><code><span>function</span> <span>setupFXAA</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> postVtxSrc<span>,</span> postFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>,</span> radioName</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> frameTexture<span>,</span> circleDrawFramebuffer<span>,</span> frameTextureLinear<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span><span>,</span>
			<span>premultipliedAlpha</span><span>:</span> <span>true</span>
		<span>}</span>
	<span>)</span><span>;</span>

	
	<span>let</span> samples <span>=</span> <span>1</span><span>;</span>
	<span>let</span> renderbuffer <span>=</span> <span>null</span><span>;</span>
	<span>let</span> resolveFramebuffer <span>=</span> <span>null</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>const</span> circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> postShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> postVtxSrc<span>,</span> postFragSrc<span>)</span><span>;</span>
	<span>const</span> rcpFrameLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>postShd<span>,</span> <span>&#34;RcpFrame&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> circleOffsetAnim <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>0.0</span><span>,</span> <span>0.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>resolveFramebuffer<span>)</span><span>;</span>
		resolveFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>

		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		frameTextureLinear <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTextureLinear<span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTextureLinear<span>,</span> <span>0</span><span>)</span><span>;</span>

		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>
		
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation<span>,</span> aspect_ratio<span>)</span><span>;</span>
		<span>var</span> radius <span>=</span> <span>0.1</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		circleOffsetAnim<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		circleOffsetAnim<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle<span>,</span> circleSize<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>postShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>rcpFrameLocation<span>,</span> <span>1.0</span> <span>/</span> <span>(</span>canvas<span>.</span>width <span>/</span> resDiv<span>)</span><span>,</span> <span>1.0</span> <span>/</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>)</span><span>;</span>
		gl<span>.</span><span>disable</span><span>(</span>gl<span>.</span><span>SAMPLE_ALPHA_TO_COVERAGE</span><span>)</span><span>;</span>
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>ONE</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>

		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTextureLinear<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> resolveFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>


		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationPost<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> <span>(</span><span>1.0</span> <span>/</span> aspect_ratio<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationRed<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> <span>1.0</span> <span>/</span> <span>(</span>width <span>/</span> height<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>
	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>deleteRenderbuffer</span><span>(</span>renderbuffer<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>resolveFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><p>A bit of a weird result. It looks good if the circle wouldn‚Äôt move. Perfectly smooth edges. But the circle distorts as it moves. The axis-aligned top and bottom especially have a little nub that appears and disappears. And switching to lower resolutions, the circle even loses its round shape, <a href="https://www.youtube.com/watch?v=x8TO-nrUtSI">wobbling like Play Station 1 graphics</a>.</p><p>Per-pixel, FXAA considers only the 3x3 neighborhood, so it can‚Äôt possibly know that this area is part of a big shape. But it also doesn‚Äôt just ‚Äúblur edges‚Äù, as often said. As explained in the <a href="https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf">official whitepaper</a>, it finds the edge‚Äôs direction and shifts the pixel‚Äôs coordinates to let the performance free linear interpolation do the blending.</p><p>For our demo here, wrong tool for the job. Really, we didn‚Äôt do FXAA justice with our example. FXAA was created for another use case and has many settings and presets. It was created to anti-alias more complex scenes. Let‚Äôs give it a fair shot!</p><h4 id="fxaa-full-demo" tabindex="-1">FXAA full demo <a href="#fxaa-full-demo">#</a></h4><p>A scene from my favorite piece of software in existence: <a href="https://store.steampowered.com/app/244630/NEOTOKYO/">NeoTokyo¬∞</a>. I created a bright area light in an NT¬∞ map and moved a bench to create an area of strong aliasing. The following demo uses the aliased output from <a href="https://store.steampowered.com/app/244630/NEOTOKYO/">NeoTokyo¬∞</a>, calculates the required luminance channel and applies FXAA. All FXAA presets and settings at your finger tips.</p><blockquote><p>This has fixed resolution and will only be at you device&#39;s native resolution, if your device has no dpi scaling and the browser is at 100% zoom.</p><img src="https://blog.frost.kiwi/assets/kiwis/speak.svg"/></blockquote><p><span><label> Enable FXAA</label> </span><span><label> Enable Red Box</label> </span><span><label> Play / Pause</label></span></p><table><tbody><tr><td colspan="4"></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>FXAA_QUALITY_PRESET</code></td></tr><tr><td><code>FXAA_QUALITY_PRESET</code></td><td colspan="2"></td><td></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>fxaaQualitySubpix</code></td></tr><tr><td><code>fxaaQualitySubpix</code></td><td></td><td><output id="fxaaQualitySubpixValue">0.75</output></td><td></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>fxaaQualityEdgeThreshold</code></td></tr><tr><td><code>fxaaQualityEdgeThreshold</code></td><td></td><td><output id="fxaaQualityEdgeThresholdValue">0.166</output></td><td></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>fxaaQualityEdgeThresholdMin</code></td></tr><tr><td><code>fxaaQualityEdgeThresholdMin</code></td><td></td><td><output id="fxaaQualityEdgeThresholdMinValue">0.0833</output></td><td></td></tr><tr><td colspan="4"></td></tr></tbody></table><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/fxaainteractive.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/fxaainteractive.png" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/FXAA-interactive.vs">FXAA-interactive.vs</a></summary><pre><code>
<span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	
	uv <span>=</span> vtx <span>*</span> <span>vec2</span><span>(</span><span>0.5</span><span>,</span> <span>-</span><span>0.5</span><span>)</span> <span>+</span> <span>0.5</span><span>;</span>
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/FXAA-interactive.fs">FXAA-interactive.fs</a></summary><pre><code><span>precision</span> <span>highp</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>uniform</span> <span>sampler2D</span> texture<span>;</span>
<span>uniform</span> <span>vec2</span> RcpFrame<span>;</span>
<span>uniform</span> <span>float</span> u_fxaaQualitySubpix<span>;</span>
<span>uniform</span> <span>float</span> u_fxaaQualityEdgeThreshold<span>;</span>
<span>uniform</span> <span>float</span> u_fxaaQualityEdgeThresholdMin<span>;</span>



<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>10</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>3</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>3.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>12.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>11</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>4</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>3.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>12.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>12</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>12.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>13</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>6</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>12.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>14</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>7</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>12.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>15</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>8</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>12.0</span></span></span>
<span><span>#</span><span>endif</span></span>


<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>20</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>3</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>21</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>4</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>22</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>23</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>6</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>24</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>7</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>3.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>25</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>8</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>26</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>9</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P8</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>27</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>10</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P8</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P9</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>28</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>11</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P8</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P9</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P10</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>

<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>29</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>12</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P8</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P9</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P10</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P11</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>


<span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PRESET <span>==</span> <span>39</span><span>)</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_PS</span> <span><span>12</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P0</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P1</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P2</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P3</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P4</span> <span><span>1.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P5</span> <span><span>1.5</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P6</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P7</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P8</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P9</span> <span><span>2.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P10</span> <span><span>4.0</span></span></span>
    <span><span>#</span><span>define</span> <span>FXAA_QUALITY_P11</span> <span><span>8.0</span></span></span>
<span><span>#</span><span>endif</span></span>



<span><span>#</span><span>if</span> <span><span>(</span>FXAA_GREEN_AS_LUMA <span>==</span> <span>0</span><span>)</span></span></span>
    <span>float</span> <span>FxaaLuma</span><span>(</span><span>vec4</span> rgba<span>)</span> <span>{</span> <span>return</span> rgba<span>.</span>w<span>;</span> <span>}</span>
<span><span>#</span><span>else</span></span>
    <span>float</span> <span>FxaaLuma</span><span>(</span><span>vec4</span> rgba<span>)</span> <span>{</span> <span>return</span> rgba<span>.</span>y<span>;</span> <span>}</span>
<span><span>#</span><span>endif</span>    </span>


<span>vec4</span> <span>FxaaPixelShader</span><span>(</span>
    
    
    
    <span>vec2</span> pos<span>,</span>
    
    
    
    
    
    <span>sampler2D</span> tex<span>,</span>
    
    
    
    
    
    <span>vec2</span> fxaaQualityRcpFrame<span>,</span>
    
    
    
    
    
    
    
    
    
    
    
    <span>float</span> fxaaQualitySubpix<span>,</span>
    
    
    
    
    
    
    
    
    
    
    <span>float</span> fxaaQualityEdgeThreshold<span>,</span>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <span>float</span> fxaaQualityEdgeThresholdMin
<span>)</span> <span>{</span>

    <span>vec2</span> posM<span>;</span>
    posM<span>.</span>x <span>=</span> pos<span>.</span>x<span>;</span>
    posM<span>.</span>y <span>=</span> pos<span>.</span>y<span>;</span>
    <span>vec4</span> rgbyM <span>=</span> <span>texture2D</span><span>(</span>tex<span>,</span> posM<span>)</span><span>;</span>
    <span><span>#</span><span>if</span> <span><span>(</span>FXAA_GREEN_AS_LUMA <span>==</span> <span>0</span><span>)</span></span></span>
        <span><span>#</span><span>define</span> <span>lumaM</span> <span>rgbyM<span>.</span>w</span></span>
    <span><span>#</span><span>else</span></span>
        <span><span>#</span><span>define</span> <span>lumaM</span> <span>rgbyM<span>.</span>y</span></span>
    <span><span>#</span><span>endif</span></span>
    <span>float</span> lumaS <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span> <span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>float</span> lumaE <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>float</span> lumaN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span> <span>0</span><span>,</span><span>-</span><span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>float</span> lumaW <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>

    <span>float</span> maxSM <span>=</span> <span>max</span><span>(</span>lumaS<span>,</span> lumaM<span>)</span><span>;</span>
    <span>float</span> minSM <span>=</span> <span>min</span><span>(</span>lumaS<span>,</span> lumaM<span>)</span><span>;</span>
    <span>float</span> maxESM <span>=</span> <span>max</span><span>(</span>lumaE<span>,</span> maxSM<span>)</span><span>;</span>
    <span>float</span> minESM <span>=</span> <span>min</span><span>(</span>lumaE<span>,</span> minSM<span>)</span><span>;</span>
    <span>float</span> maxWN <span>=</span> <span>max</span><span>(</span>lumaN<span>,</span> lumaW<span>)</span><span>;</span>
    <span>float</span> minWN <span>=</span> <span>min</span><span>(</span>lumaN<span>,</span> lumaW<span>)</span><span>;</span>
    <span>float</span> rangeMax <span>=</span> <span>max</span><span>(</span>maxWN<span>,</span> maxESM<span>)</span><span>;</span>
    <span>float</span> rangeMin <span>=</span> <span>min</span><span>(</span>minWN<span>,</span> minESM<span>)</span><span>;</span>
    <span>float</span> rangeMaxScaled <span>=</span> rangeMax <span>*</span> fxaaQualityEdgeThreshold<span>;</span>
    <span>float</span> range <span>=</span> rangeMax <span>-</span> rangeMin<span>;</span>
    <span>float</span> rangeMaxClamped <span>=</span> <span>max</span><span>(</span>fxaaQualityEdgeThresholdMin<span>,</span> rangeMaxScaled<span>)</span><span>;</span>
    <span>bool</span> earlyExit <span>=</span> range <span>&lt;</span> rangeMaxClamped<span>;</span>

    <span>if</span><span>(</span>earlyExit<span>)</span>
        <span>return</span> rgbyM<span>;</span>

    <span>float</span> lumaNW <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>-</span><span>1</span><span>,</span><span>-</span><span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>float</span> lumaSE <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>float</span> lumaNE <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span> <span>1</span><span>,</span><span>-</span><span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>
    <span>float</span> lumaSW <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM <span>+</span> <span>(</span><span>vec2</span><span>(</span><span>ivec2</span><span>(</span><span>-</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>)</span> <span>*</span> fxaaQualityRcpFrame<span>.</span>xy<span>)</span><span>)</span><span>)</span><span>;</span>

    <span>float</span> lumaNS <span>=</span> lumaN <span>+</span> lumaS<span>;</span>
    <span>float</span> lumaWE <span>=</span> lumaW <span>+</span> lumaE<span>;</span>
    <span>float</span> subpixRcpRange <span>=</span> <span>1.0</span><span>/</span>range<span>;</span>
    <span>float</span> subpixNSWE <span>=</span> lumaNS <span>+</span> lumaWE<span>;</span>
    <span>float</span> edgeHorz1 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaM<span>)</span> <span>+</span> lumaNS<span>;</span>
    <span>float</span> edgeVert1 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaM<span>)</span> <span>+</span> lumaWE<span>;</span>

    <span>float</span> lumaNESE <span>=</span> lumaNE <span>+</span> lumaSE<span>;</span>
    <span>float</span> lumaNWNE <span>=</span> lumaNW <span>+</span> lumaNE<span>;</span>
    <span>float</span> edgeHorz2 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaE<span>)</span> <span>+</span> lumaNESE<span>;</span>
    <span>float</span> edgeVert2 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaN<span>)</span> <span>+</span> lumaNWNE<span>;</span>

    <span>float</span> lumaNWSW <span>=</span> lumaNW <span>+</span> lumaSW<span>;</span>
    <span>float</span> lumaSWSE <span>=</span> lumaSW <span>+</span> lumaSE<span>;</span>
    <span>float</span> edgeHorz4 <span>=</span> <span>(</span><span>abs</span><span>(</span>edgeHorz1<span>)</span> <span>*</span> <span>2.0</span><span>)</span> <span>+</span> <span>abs</span><span>(</span>edgeHorz2<span>)</span><span>;</span>
    <span>float</span> edgeVert4 <span>=</span> <span>(</span><span>abs</span><span>(</span>edgeVert1<span>)</span> <span>*</span> <span>2.0</span><span>)</span> <span>+</span> <span>abs</span><span>(</span>edgeVert2<span>)</span><span>;</span>
    <span>float</span> edgeHorz3 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaW<span>)</span> <span>+</span> lumaNWSW<span>;</span>
    <span>float</span> edgeVert3 <span>=</span> <span>(</span><span>-</span><span>2.0</span> <span>*</span> lumaS<span>)</span> <span>+</span> lumaSWSE<span>;</span>
    <span>float</span> edgeHorz <span>=</span> <span>abs</span><span>(</span>edgeHorz3<span>)</span> <span>+</span> edgeHorz4<span>;</span>
    <span>float</span> edgeVert <span>=</span> <span>abs</span><span>(</span>edgeVert3<span>)</span> <span>+</span> edgeVert4<span>;</span>

    <span>float</span> subpixNWSWNESE <span>=</span> lumaNWSW <span>+</span> lumaNESE<span>;</span>
    <span>float</span> lengthSign <span>=</span> fxaaQualityRcpFrame<span>.</span>x<span>;</span>
    <span>bool</span> horzSpan <span>=</span> edgeHorz <span>&gt;=</span> edgeVert<span>;</span>
    <span>float</span> subpixA <span>=</span> subpixNSWE <span>*</span> <span>2.0</span> <span>+</span> subpixNWSWNESE<span>;</span>

    <span>if</span><span>(</span><span>!</span>horzSpan<span>)</span> lumaN <span>=</span> lumaW<span>;</span>
    <span>if</span><span>(</span><span>!</span>horzSpan<span>)</span> lumaS <span>=</span> lumaE<span>;</span>
    <span>if</span><span>(</span>horzSpan<span>)</span> lengthSign <span>=</span> fxaaQualityRcpFrame<span>.</span>y<span>;</span>
    <span>float</span> subpixB <span>=</span> <span>(</span>subpixA <span>*</span> <span>(</span><span>1.0</span><span>/</span><span>12.0</span><span>)</span><span>)</span> <span>-</span> lumaM<span>;</span>

    <span>float</span> gradientN <span>=</span> lumaN <span>-</span> lumaM<span>;</span>
    <span>float</span> gradientS <span>=</span> lumaS <span>-</span> lumaM<span>;</span>
    <span>float</span> lumaNN <span>=</span> lumaN <span>+</span> lumaM<span>;</span>
    <span>float</span> lumaSS <span>=</span> lumaS <span>+</span> lumaM<span>;</span>
    <span>bool</span> pairN <span>=</span> <span>abs</span><span>(</span>gradientN<span>)</span> <span>&gt;=</span> <span>abs</span><span>(</span>gradientS<span>)</span><span>;</span>
    <span>float</span> gradient <span>=</span> <span>max</span><span>(</span><span>abs</span><span>(</span>gradientN<span>)</span><span>,</span> <span>abs</span><span>(</span>gradientS<span>)</span><span>)</span><span>;</span>
    <span>if</span><span>(</span>pairN<span>)</span> lengthSign <span>=</span> <span>-</span>lengthSign<span>;</span>
    <span>float</span> subpixC <span>=</span> <span>clamp</span><span>(</span><span>abs</span><span>(</span>subpixB<span>)</span> <span>*</span> subpixRcpRange<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>

    <span>vec2</span> posB<span>;</span>
    posB<span>.</span>x <span>=</span> posM<span>.</span>x<span>;</span>
    posB<span>.</span>y <span>=</span> posM<span>.</span>y<span>;</span>
    <span>vec2</span> offNP<span>;</span>
    offNP<span>.</span>x <span>=</span> <span>(</span><span>!</span>horzSpan<span>)</span> <span>?</span> <span>0.0</span> <span>:</span> fxaaQualityRcpFrame<span>.</span>x<span>;</span>
    offNP<span>.</span>y <span>=</span> <span>(</span> horzSpan<span>)</span> <span>?</span> <span>0.0</span> <span>:</span> fxaaQualityRcpFrame<span>.</span>y<span>;</span>
    <span>if</span><span>(</span><span>!</span>horzSpan<span>)</span> posB<span>.</span>x <span>+=</span> lengthSign <span>*</span> <span>0.5</span><span>;</span>
    <span>if</span><span>(</span> horzSpan<span>)</span> posB<span>.</span>y <span>+=</span> lengthSign <span>*</span> <span>0.5</span><span>;</span>

    <span>vec2</span> posN<span>;</span>
    posN<span>.</span>x <span>=</span> posB<span>.</span>x <span>-</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P0<span>;</span>
    posN<span>.</span>y <span>=</span> posB<span>.</span>y <span>-</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P0<span>;</span>
    <span>vec2</span> posP<span>;</span>
    posP<span>.</span>x <span>=</span> posB<span>.</span>x <span>+</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P0<span>;</span>
    posP<span>.</span>y <span>=</span> posB<span>.</span>y <span>+</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P0<span>;</span>
    <span>float</span> subpixD <span>=</span> <span>(</span><span>(</span><span>-</span><span>2.0</span><span>)</span><span>*</span>subpixC<span>)</span> <span>+</span> <span>3.0</span><span>;</span>
    <span>float</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>)</span><span>)</span><span>;</span>
    <span>float</span> subpixE <span>=</span> subpixC <span>*</span> subpixC<span>;</span>
    <span>float</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>)</span><span>)</span><span>;</span>

    <span>if</span><span>(</span><span>!</span>pairN<span>)</span> lumaNN <span>=</span> lumaSS<span>;</span>
    <span>float</span> gradientScaled <span>=</span> gradient <span>*</span> <span>1.0</span><span>/</span><span>4.0</span><span>;</span>
    <span>float</span> lumaMM <span>=</span> lumaM <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
    <span>float</span> subpixF <span>=</span> subpixD <span>*</span> subpixE<span>;</span>
    <span>bool</span> lumaMLTZero <span>=</span> lumaMM <span>&lt;</span> <span>0.0</span><span>;</span>

    lumaEndN <span>-=</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
    lumaEndP <span>-=</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
    <span>bool</span> doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
    <span>bool</span> doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P1<span>;</span>
    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P1<span>;</span>
    <span>bool</span> doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P1<span>;</span>
    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P1<span>;</span>

    <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
        doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
        doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P2<span>;</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P2<span>;</span>
        doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P2<span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P2<span>;</span>

        <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>3</span><span>)</span></span></span>
        <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
            doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
            doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P3<span>;</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P3<span>;</span>
            doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P3<span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P3<span>;</span>

            <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>4</span><span>)</span></span></span>
            <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P4<span>;</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P4<span>;</span>
                doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P4<span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P4<span>;</span>

                <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>5</span><span>)</span></span></span>
                <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                    doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                    doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P5<span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P5<span>;</span>
                    doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P5<span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P5<span>;</span>

                    <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>6</span><span>)</span></span></span>
                    <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                        doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                        doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P6<span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P6<span>;</span>
                        doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P6<span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P6<span>;</span>

                        <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>7</span><span>)</span></span></span>
                        <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                            doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                            doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P7<span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P7<span>;</span>
                            doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P7<span>;</span>
                            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P7<span>;</span>

    <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>8</span><span>)</span></span></span>
    <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
        doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
        doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P8<span>;</span>
        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P8<span>;</span>
        doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P8<span>;</span>
        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P8<span>;</span>

        <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>9</span><span>)</span></span></span>
        <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
            doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
            doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P9<span>;</span>
            <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P9<span>;</span>
            doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P9<span>;</span>
            <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P9<span>;</span>

            <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>10</span><span>)</span></span></span>
            <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P10<span>;</span>
                <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P10<span>;</span>
                doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P10<span>;</span>
                <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P10<span>;</span>

                <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>11</span><span>)</span></span></span>
                <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                    doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                    doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P11<span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P11<span>;</span>
                    doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P11<span>;</span>
                    <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P11<span>;</span>

                    <span><span>#</span><span>if</span> <span><span>(</span>FXAA_QUALITY_PS <span>&gt;</span> <span>12</span><span>)</span></span></span>
                    <span>if</span><span>(</span>doneNP<span>)</span> <span>{</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posN<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> <span>FxaaLuma</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posP<span>.</span>xy<span>)</span><span>)</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> lumaEndN <span>=</span> lumaEndN <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> lumaEndP <span>=</span> lumaEndP <span>-</span> lumaNN <span>*</span> <span>0.5</span><span>;</span>
                        doneN <span>=</span> <span>abs</span><span>(</span>lumaEndN<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                        doneP <span>=</span> <span>abs</span><span>(</span>lumaEndP<span>)</span> <span>&gt;=</span> gradientScaled<span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>x <span>-=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P12<span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneN<span>)</span> posN<span>.</span>y <span>-=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P12<span>;</span>
                        doneNP <span>=</span> <span>(</span><span>!</span>doneN<span>)</span> <span>||</span> <span>(</span><span>!</span>doneP<span>)</span><span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>x <span>+=</span> offNP<span>.</span>x <span>*</span> FXAA_QUALITY_P12<span>;</span>
                        <span>if</span><span>(</span><span>!</span>doneP<span>)</span> posP<span>.</span>y <span>+=</span> offNP<span>.</span>y <span>*</span> FXAA_QUALITY_P12<span>;</span>

                    <span>}</span>
                    <span><span>#</span><span>endif</span></span>

                <span>}</span>
                <span><span>#</span><span>endif</span></span>

            <span>}</span>
            <span><span>#</span><span>endif</span></span>

        <span>}</span>
        <span><span>#</span><span>endif</span></span>

    <span>}</span>
    <span><span>#</span><span>endif</span></span>

                        <span>}</span>
                        <span><span>#</span><span>endif</span></span>

                    <span>}</span>
                    <span><span>#</span><span>endif</span></span>

                <span>}</span>
                <span><span>#</span><span>endif</span></span>

            <span>}</span>
            <span><span>#</span><span>endif</span></span>

        <span>}</span>
        <span><span>#</span><span>endif</span></span>

    <span>}</span>

    <span>float</span> dstN <span>=</span> posM<span>.</span>x <span>-</span> posN<span>.</span>x<span>;</span>
    <span>float</span> dstP <span>=</span> posP<span>.</span>x <span>-</span> posM<span>.</span>x<span>;</span>
    <span>if</span><span>(</span><span>!</span>horzSpan<span>)</span> dstN <span>=</span> posM<span>.</span>y <span>-</span> posN<span>.</span>y<span>;</span>
    <span>if</span><span>(</span><span>!</span>horzSpan<span>)</span> dstP <span>=</span> posP<span>.</span>y <span>-</span> posM<span>.</span>y<span>;</span>

    <span>bool</span> goodSpanN <span>=</span> <span>(</span>lumaEndN <span>&lt;</span> <span>0.0</span><span>)</span> <span>!=</span> lumaMLTZero<span>;</span>
    <span>float</span> spanLength <span>=</span> <span>(</span>dstP <span>+</span> dstN<span>)</span><span>;</span>
    <span>bool</span> goodSpanP <span>=</span> <span>(</span>lumaEndP <span>&lt;</span> <span>0.0</span><span>)</span> <span>!=</span> lumaMLTZero<span>;</span>
    <span>float</span> spanLengthRcp <span>=</span> <span>1.0</span><span>/</span>spanLength<span>;</span>

    <span>bool</span> directionN <span>=</span> dstN <span>&lt;</span> dstP<span>;</span>
    <span>float</span> dst <span>=</span> <span>min</span><span>(</span>dstN<span>,</span> dstP<span>)</span><span>;</span>
    <span>bool</span> goodSpan <span>=</span> directionN <span>?</span> goodSpanN <span>:</span> goodSpanP<span>;</span>
    <span>float</span> subpixG <span>=</span> subpixF <span>*</span> subpixF<span>;</span>
    <span>float</span> pixelOffset <span>=</span> <span>(</span>dst <span>*</span> <span>(</span><span>-</span>spanLengthRcp<span>)</span><span>)</span> <span>+</span> <span>0.5</span><span>;</span>
    <span>float</span> subpixH <span>=</span> subpixG <span>*</span> fxaaQualitySubpix<span>;</span>

    <span>float</span> pixelOffsetGood <span>=</span> goodSpan <span>?</span> pixelOffset <span>:</span> <span>0.0</span><span>;</span>
    <span>float</span> pixelOffsetSubpix <span>=</span> <span>max</span><span>(</span>pixelOffsetGood<span>,</span> subpixH<span>)</span><span>;</span>
    <span>if</span><span>(</span><span>!</span>horzSpan<span>)</span> posM<span>.</span>x <span>+=</span> pixelOffsetSubpix <span>*</span> lengthSign<span>;</span>
    <span>if</span><span>(</span> horzSpan<span>)</span> posM<span>.</span>y <span>+=</span> pixelOffsetSubpix <span>*</span> lengthSign<span>;</span>
    <span>return</span> <span>vec4</span><span>(</span><span>texture2D</span><span>(</span>tex<span>,</span> posM<span>)</span><span>.</span>xyz<span>,</span> lumaM<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	<span><span>#</span><span>if</span> <span><span>(</span>FXAA_LUMA<span>)</span></span></span>
		<span><span>#</span><span>if</span> <span><span>(</span>FXAA_GREEN_AS_LUMA<span>)</span></span></span>
				gl_FragColor <span>=</span> <span>vec4</span><span>(</span><span>texture2D</span><span>(</span>texture<span>,</span> uv<span>)</span><span>.</span>ggg<span>,</span> <span>1.0</span><span>)</span><span>;</span>
			<span><span>#</span><span>else</span>		</span>
				gl_FragColor <span>=</span> <span>vec4</span><span>(</span><span>texture2D</span><span>(</span>texture<span>,</span> uv<span>)</span><span>.</span>aaa<span>,</span> <span>1.0</span><span>)</span><span>;</span>
		<span><span>#</span><span>endif</span></span>
	<span><span>#</span><span>elif</span> <span><span>(</span>FXAA_ENABLE<span>)</span></span></span>
		gl_FragColor <span>=</span> <span>FxaaPixelShader</span><span>(</span>
			uv<span>,</span> texture<span>,</span> RcpFrame<span>,</span> u_fxaaQualitySubpix<span>,</span> u_fxaaQualityEdgeThreshold<span>,</span> u_fxaaQualityEdgeThresholdMin<span>)</span><span>;</span>
	<span><span>#</span><span>else</span></span>
		gl_FragColor <span>=</span> <span>vec4</span><span>(</span><span>texture2D</span><span>(</span>texture<span>,</span> uv<span>)</span><span>.</span>rgb<span>,</span> <span>1.0</span><span>)</span><span>;</span>
	<span><span>#</span><span>endif</span></span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/FXAA-interactive.js">FXAA-interactive.js</a></summary><pre><code><span>&#34;use strict&#34;</span><span>;</span>
<span>async</span> <span>function</span> <span>loadFrame</span><span>(</span><span>gl<span>,</span> path</span><span>)</span> <span>{</span>
	<span>const</span> response <span>=</span> <span>await</span> <span>fetch</span><span>(</span>path<span>)</span><span>;</span>
	<span>const</span> blob <span>=</span> <span>await</span> response<span>.</span><span>blob</span><span>(</span><span>)</span><span>;</span>
	<span>const</span> bitmap <span>=</span> <span>await</span> <span>createImageBitmap</span><span>(</span>blob<span>,</span> <span>{</span> <span>colorSpaceConversion</span><span>:</span> <span>&#39;none&#39;</span> <span>}</span><span>)</span><span>;</span>

	<span>const</span> target <span>=</span> gl<span>.</span><span>createTexture</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> target<span>)</span><span>;</span>

	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MIN_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_MAG_FILTER</span><span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_S</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>
	gl<span>.</span><span>texParameteri</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> gl<span>.</span><span>TEXTURE_WRAP_T</span><span>,</span> gl<span>.</span><span>CLAMP_TO_EDGE</span><span>)</span><span>;</span>

	gl<span>.</span><span>texImage2D</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> <span>0</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>RGB</span><span>,</span> gl<span>.</span><span>UNSIGNED_BYTE</span><span>,</span> bitmap<span>)</span><span>;</span>

	bitmap<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
	<span>return</span> target<span>;</span>
<span>}</span>

<span>async</span> <span>function</span> <span>loadAllFrames</span><span>(</span><span>gl<span>,</span> start<span>,</span> end</span><span>)</span> <span>{</span>
	<span>const</span> framePromises <span>=</span> <span>[</span><span>]</span><span>;</span>
	<span>const</span> totalFrames <span>=</span> end <span>-</span> start <span>+</span> <span>1</span><span>;</span>
	<span>let</span> loadedFrames <span>=</span> <span>0</span><span>;</span>

	<span>const</span> loadingOverlay <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;loading-overlay&#39;</span><span>)</span><span>;</span>

	loadingOverlay<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;flex&#39;</span><span>;</span>
	<span>function</span> <span>updateLoadingProgress</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> percentage <span>=</span> Math<span>.</span><span>floor</span><span>(</span><span>(</span>loadedFrames <span>/</span> totalFrames<span>)</span> <span>*</span> <span>100</span><span>)</span><span>;</span>
		loadingOverlay<span>.</span>innerHTML <span>=</span> <span><span>`</span><span>Loading... </span><span><span>${</span>percentage<span>}</span></span><span>%</span><span>`</span></span><span>;</span>
		<span>if</span> <span>(</span>loadedFrames <span>===</span> totalFrames<span>)</span>
			loadingOverlay<span>.</span>style<span>.</span>display <span>=</span> <span>&#39;none&#39;</span><span>;</span>
	<span>}</span>

	<span>for</span> <span>(</span><span>let</span> i <span>=</span> start<span>;</span> i <span>&lt;=</span> end<span>;</span> i<span>++</span><span>)</span> <span>{</span>
		<span>const</span> path <span>=</span> <span><span>`</span><span>frames/</span><span><span>${</span>i<span>}</span></span><span>.png</span><span>`</span></span><span>;</span>
		<span>const</span> framePromise <span>=</span> <span>loadFrame</span><span>(</span>gl<span>,</span> path<span>)</span><span>.</span><span>then</span><span>(</span><span>texture</span> <span>=&gt;</span> <span>{</span>
			loadedFrames<span>++</span><span>;</span>
			<span>updateLoadingProgress</span><span>(</span><span>)</span><span>;</span>
			<span>return</span> texture<span>;</span>
		<span>}</span><span>)</span><span>;</span>
		framePromises<span>.</span><span>push</span><span>(</span>framePromise<span>)</span><span>;</span>
	<span>}</span>

	<span>const</span> textures <span>=</span> <span>await</span> Promise<span>.</span><span>all</span><span>(</span>framePromises<span>)</span><span>;</span>
	<span>return</span> textures<span>;</span>
<span>}</span>

<span>function</span> <span>setupFXAAInteractive</span><span>(</span><span>canvasId<span>,</span> simpleVtxSrc<span>,</span> simpleFragSrc<span>,</span> vertexLumaSrc<span>,</span> lumaFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>false</span><span>,</span>
			<span>premultipliedAlpha</span><span>:</span> <span>false</span>
		<span>}</span>
	<span>)</span><span>;</span>

	<span>let</span> lumaBuffer<span>,</span> lumaTexture<span>,</span> blitBuffer<span>,</span> blitTexture<span>;</span>
	<span>let</span> enableFXAA <span>=</span> <span>true</span><span>;</span>
	<span>let</span> enableRed <span>=</span> <span>true</span><span>;</span>
	<span>let</span> showLuma <span>=</span> <span>false</span><span>;</span>
	<span>let</span> greenLuma <span>=</span> <span>false</span><span>;</span>
	<span>let</span> pause <span>=</span> <span>false</span><span>;</span>
	<span>let</span> fxaaQualityPreset <span>=</span> <span>12</span><span>;</span>

	
	
	<span>let</span> fxaaShd<span>;</span>
	<span>let</span> rcpFrameLocation<span>;</span>
	<span>let</span> fxaaQualitySubpixLocation<span>;</span>
	<span>let</span> fxaaQualityEdgeThresholdLocation<span>;</span>
	<span>let</span> fxaaQualityEdgeThresholdMinLocation<span>;</span>

	<span>function</span> <span>updateFXAAShader</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>fxaaShd<span>)</span> <span>{</span>
			gl<span>.</span><span>deleteProgram</span><span>(</span>fxaaShd<span>)</span><span>;</span>
		<span>}</span>

		<span>const</span> prefix <span>=</span> <span><span>`</span><span>
        #define FXAA_QUALITY_PRESET </span><span><span>${</span>fxaaQualityPreset<span>}</span></span><span>
        #define FXAA_GREEN_AS_LUMA </span><span><span>${</span>greenLuma <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>}</span></span><span>
        #define FXAA_ENABLE </span><span><span>${</span>enableFXAA <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>}</span></span><span>
        #define FXAA_LUMA </span><span><span>${</span>showLuma <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>}</span></span><span>
	    </span><span>`</span></span><span>;</span>

		fxaaShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> simpleVtxSrc<span>,</span> simpleFragSrc<span>,</span> prefix<span>)</span><span>;</span>

		rcpFrameLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>fxaaShd<span>,</span> <span>&#34;RcpFrame&#34;</span><span>)</span><span>;</span>
		fxaaQualitySubpixLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>fxaaShd<span>,</span> <span>&#34;u_fxaaQualitySubpix&#34;</span><span>)</span><span>;</span>
		fxaaQualityEdgeThresholdLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>fxaaShd<span>,</span> <span>&#34;u_fxaaQualityEdgeThreshold&#34;</span><span>)</span><span>;</span>
		fxaaQualityEdgeThresholdMinLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>fxaaShd<span>,</span> <span>&#34;u_fxaaQualityEdgeThresholdMin&#34;</span><span>)</span><span>;</span>
	<span>}</span>

	<span>updateFXAAShader</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> lumaShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> vertexLumaSrc<span>,</span> lumaFragSrc<span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	
	<span>let</span> framesLoaded <span>=</span> <span>false</span><span>;</span>
	<span>let</span> textures <span>=</span> <span>[</span><span>]</span><span>;</span>

	
	<span>const</span> unitQuad <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>-</span><span>1.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>1.0</span><span>,</span> <span>1.0</span><span>,</span>
		<span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
		<span>-</span><span>1.0</span><span>,</span> <span>-</span><span>1.0</span><span>,</span>
	<span>]</span><span>)</span><span>;</span>

	<span>const</span> trackedCoords <span>=</span> <span>[</span>
		<span>[</span><span>357.250</span><span>,</span> <span>206.375</span><span>]</span><span>,</span>
		<span>[</span><span>356.602</span><span>,</span> <span>207.301</span><span>]</span><span>,</span>
		<span>[</span><span>356.309</span><span>,</span> <span>207.559</span><span>]</span><span>,</span>
		<span>[</span><span>354.832</span><span>,</span> <span>208.711</span><span>]</span><span>,</span>
		<span>[</span><span>353.121</span><span>,</span> <span>209.863</span><span>]</span><span>,</span>
		<span>[</span><span>350.578</span><span>,</span> <span>211.102</span><span>]</span><span>,</span>
		<span>[</span><span>347.594</span><span>,</span> <span>212.336</span><span>]</span><span>,</span>
		<span>[</span><span>343.457</span><span>,</span> <span>214.652</span><span>]</span><span>,</span>
		<span>[</span><span>338.086</span><span>,</span> <span>216.977</span><span>]</span><span>,</span>
		<span>[</span><span>332.803</span><span>,</span> <span>219.934</span><span>]</span><span>,</span>
		<span>[</span><span>327.791</span><span>,</span> <span>222.625</span><span>]</span><span>,</span>
		<span>[</span><span>324.259</span><span>,</span> <span>224.398</span><span>]</span><span>,</span>
		<span>[</span><span>319.233</span><span>,</span> <span>227.902</span><span>]</span><span>,</span>
		<span>[</span><span>315.627</span><span>,</span> <span>231.492</span><span>]</span><span>,</span>
		<span>[</span><span>315.381</span><span>,</span> <span>233.305</span><span>]</span><span>,</span>
		<span>[</span><span>314.672</span><span>,</span> <span>234.145</span><span>]</span><span>,</span>
		<span>[</span><span>314.616</span><span>,</span> <span>235.363</span><span>]</span><span>,</span>
		<span>[</span><span>315.028</span><span>,</span> <span>236.508</span><span>]</span><span>,</span>
		<span>[</span><span>316.072</span><span>,</span> <span>237.676</span><span>]</span><span>,</span>
		<span>[</span><span>317.366</span><span>,</span> <span>238.301</span><span>]</span><span>,</span>
		<span>[</span><span>317.657</span><span>,</span> <span>239.703</span><span>]</span><span>,</span>
		<span>[</span><span>319.354</span><span>,</span> <span>240.016</span><span>]</span><span>,</span>
		<span>[</span><span>320.018</span><span>,</span> <span>241.277</span><span>]</span><span>,</span>
		<span>[</span><span>321.091</span><span>,</span> <span>241.785</span><span>]</span><span>,</span>
		<span>[</span><span>321.726</span><span>,</span> <span>241.777</span><span>]</span><span>,</span>
		<span>[</span><span>321.824</span><span>,</span> <span>242.117</span><span>]</span><span>,</span>
		<span>[</span><span>322.334</span><span>,</span> <span>242.109</span><span>]</span><span>,</span>
		<span>[</span><span>322.082</span><span>,</span> <span>242.965</span><span>]</span><span>,</span>
		<span>[</span><span>322.100</span><span>,</span> <span>242.965</span><span>]</span>
	<span>]</span><span>;</span>

	<span>function</span> <span>applyTrackingData</span><span>(</span><span>index<span>,</span> location</span><span>)</span> <span>{</span>
		<span>const</span> x <span>=</span> <span>(</span>trackedCoords<span>[</span>index<span>]</span><span>[</span><span>0</span><span>]</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>2</span> <span>-</span> <span>1</span><span>;</span>
		<span>const</span> y <span>=</span> <span>1</span> <span>-</span> <span>(</span>trackedCoords<span>[</span>index<span>]</span><span>[</span><span>1</span><span>]</span> <span>/</span> canvas<span>.</span>height<span>)</span> <span>*</span> <span>2</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>location<span>,</span> x<span>,</span> y<span>)</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>setupBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>lumaBuffer<span>)</span><span>;</span>
		lumaBuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> lumaBuffer<span>)</span><span>;</span>

		lumaTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>,</span> lumaTexture<span>,</span> gl<span>.</span><span>LINEAR</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lumaTexture<span>,</span> <span>0</span><span>)</span><span>;</span>

		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>blitBuffer<span>)</span><span>;</span>
		blitBuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> blitBuffer<span>)</span><span>;</span>

		blitTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>,</span> blitTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> blitTexture<span>,</span> <span>0</span><span>)</span><span>;</span>
	<span>}</span>

	<span>const</span> fxaaCheckbox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;fxaaCheck&#39;</span><span>)</span><span>;</span>
	fxaaCheckbox<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
		enableFXAA <span>=</span> fxaaCheckbox<span>.</span>checked<span>;</span>
		<span>updateFXAAShader</span><span>(</span><span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>
	<span>const</span> redCheckbox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;redCheck&#39;</span><span>)</span><span>;</span>
	redCheckbox<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
		enableRed <span>=</span> redCheckbox<span>.</span>checked<span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>
	<span>const</span> pauseCheckbox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;pauseCheck&#39;</span><span>)</span><span>;</span>
	pauseCheckbox<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
		pause <span>=</span> <span>!</span>pauseCheckbox<span>.</span>checked<span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>
	<span>const</span> lumaCheckbox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;lumaCheck&#39;</span><span>)</span><span>;</span>
	lumaCheckbox<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
		showLuma <span>=</span> lumaCheckbox<span>.</span>checked<span>;</span>
		<span>updateFXAAShader</span><span>(</span><span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>
	<span>const</span> greenCheckbox <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;greenCheck&#39;</span><span>)</span><span>;</span>
	greenCheckbox<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
		greenLuma <span>=</span> greenCheckbox<span>.</span>checked<span>;</span>
		<span>updateFXAAShader</span><span>(</span><span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	<span>const</span> fxaaQualityPresetSelect <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;FXAA_QUALITY_PRESET&#39;</span><span>)</span><span>;</span>
	fxaaQualityPresetSelect<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		fxaaQualityPreset <span>=</span> <span>parseInt</span><span>(</span>fxaaQualityPresetSelect<span>.</span>value<span>)</span><span>;</span>
		<span>updateFXAAShader</span><span>(</span><span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>let</span> fxaaQualitySubpix <span>=</span> <span>0.75</span><span>;</span>
	<span>let</span> fxaaQualityEdgeThreshold <span>=</span> <span>0.166</span><span>;</span>
	<span>let</span> fxaaQualityEdgeThresholdMin <span>=</span> <span>0.0833</span><span>;</span>

	<span>const</span> fxaaQualitySubpixRange <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;fxaaQualitySubpixRange&#39;</span><span>)</span><span>;</span>
	<span>const</span> fxaaQualityEdgeThresholdRange <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;fxaaQualityEdgeThresholdRange&#39;</span><span>)</span><span>;</span>
	<span>const</span> fxaaQualityEdgeThresholdMinRange <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;fxaaQualityEdgeThresholdMinRange&#39;</span><span>)</span><span>;</span>

	fxaaQualitySubpixRange<span>.</span><span>addEventListener</span><span>(</span><span>&#39;input&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		fxaaQualitySubpix <span>=</span> <span>parseFloat</span><span>(</span>fxaaQualitySubpixRange<span>.</span>value<span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	fxaaQualityEdgeThresholdRange<span>.</span><span>addEventListener</span><span>(</span><span>&#39;input&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		fxaaQualityEdgeThreshold <span>=</span> <span>parseFloat</span><span>(</span>fxaaQualityEdgeThresholdRange<span>.</span>value<span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	fxaaQualityEdgeThresholdMinRange<span>.</span><span>addEventListener</span><span>(</span><span>&#39;input&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		fxaaQualityEdgeThresholdMin <span>=</span> <span>parseFloat</span><span>(</span>fxaaQualityEdgeThresholdMinRange<span>.</span>value<span>)</span><span>;</span>
		<span>redraw</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>

	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>

	canvas<span>.</span>width <span>=</span> <span>684</span><span>;</span>
	canvas<span>.</span>height <span>=</span> <span>480</span><span>;</span>

	gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>684</span><span>,</span> <span>480</span><span>)</span><span>;</span>

	<span>const</span> fps <span>=</span> <span>30</span><span>;</span>
	<span>const</span> frameDuration <span>=</span> <span>1000</span> <span>/</span> fps<span>;</span>
	<span>const</span> waitBetweenFramesMs <span>=</span> <span>1000</span><span>;</span>
	<span>let</span> frameIndex <span>=</span> <span>0</span><span>;</span>
	<span>let</span> lastFrameTime <span>=</span> <span>0</span><span>;</span>
	<span>let</span> forward <span>=</span> <span>true</span><span>;</span>
	<span>let</span> delayActive <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span><span>!</span>isRendering <span>||</span> redrawActive <span>||</span> <span>!</span>framesLoaded<span>)</span>
			<span>return</span><span>;</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>

		
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> lumaBuffer<span>)</span><span>;</span>
		gl<span>.</span><span>disable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> textures<span>[</span>frameIndex<span>]</span><span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>lumaShd<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> blitBuffer<span>)</span><span>;</span>
		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> lumaTexture<span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>fxaaShd<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		
		
		gl<span>.</span><span>uniform2f</span><span>(</span>rcpFrameLocation<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>width<span>,</span> <span>1.0</span> <span>/</span> canvas<span>.</span>height<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>fxaaQualitySubpixLocation<span>,</span> fxaaQualitySubpix<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>fxaaQualityEdgeThresholdLocation<span>,</span> fxaaQualityEdgeThreshold<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>fxaaQualityEdgeThresholdMinLocation<span>,</span> fxaaQualityEdgeThresholdMin<span>)</span><span>;</span>

		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindTexture</span><span>(</span>gl<span>.</span><span>TEXTURE_2D</span><span>,</span> blitTexture<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		<span>applyTrackingData</span><span>(</span>frameIndex<span>,</span> offsetLocationPost<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> canvas<span>.</span>width <span>/</span> canvas<span>.</span>height <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
		<span>applyTrackingData</span><span>(</span>frameIndex<span>,</span> offsetLocationRed<span>)</span><span>;</span>
		<span>if</span> <span>(</span>enableRed<span>)</span>
			gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>enableRed<span>)</span>
			gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>const</span> elapsed <span>=</span> time <span>-</span> lastFrameTime<span>;</span>
			<span>if</span> <span>(</span>elapsed <span>&gt;=</span> frameDuration<span>)</span> <span>{</span>
				lastFrameTime <span>=</span> time <span>-</span> <span>(</span>elapsed <span>%</span> frameDuration<span>)</span><span>;</span>
				<span>redraw</span><span>(</span><span>)</span><span>;</span>

				<span>if</span> <span>(</span>forward<span>)</span> <span>{</span>
					<span>if</span> <span>(</span><span>!</span>pause<span>)</span>
						frameIndex<span>++</span><span>;</span>
					<span>if</span> <span>(</span>frameIndex <span>==</span> <span>29</span><span>)</span> <span>{</span>
						frameIndex <span>=</span> <span>28</span><span>;</span>
						forward <span>=</span> <span>false</span><span>;</span>

						<span>if</span> <span>(</span><span>!</span>delayActive<span>)</span> <span>{</span>
							delayActive <span>=</span> <span>true</span><span>;</span>
							<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
								delayActive <span>=</span> <span>false</span><span>;</span>
								<span>if</span> <span>(</span>isRendering<span>)</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
							<span>}</span><span>,</span> waitBetweenFramesMs<span>)</span><span>;</span>
							<span>return</span><span>;</span>
						<span>}</span>
					<span>}</span>
				<span>}</span> <span>else</span> <span>{</span>
					<span>if</span><span>(</span><span>!</span>pause<span>)</span>
						frameIndex<span>--</span><span>;</span>
					<span>if</span> <span>(</span>frameIndex <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
						forward <span>=</span> <span>true</span><span>;</span>
						frameIndex <span>=</span> <span>0</span><span>;</span>

						<span>if</span> <span>(</span><span>!</span>delayActive<span>)</span> <span>{</span>
							delayActive <span>=</span> <span>true</span><span>;</span>
							<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
								delayActive <span>=</span> <span>false</span><span>;</span>
								<span>if</span> <span>(</span>isRendering<span>)</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
							<span>}</span><span>,</span> waitBetweenFramesMs<span>)</span><span>;</span>
							<span>return</span><span>;</span>
						<span>}</span>
					<span>}</span>
				<span>}</span>
			<span>}</span>

			<span>if</span> <span>(</span><span>!</span>delayActive<span>)</span> <span>{</span>
				<span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	<span>async</span> <span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		<span>for</span> <span>(</span><span>const</span> entry <span>of</span> entries<span>)</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>{</span>
					
					isRendering <span>=</span> <span>true</span><span>;</span>

					
					textures <span>=</span> <span>await</span> <span>loadAllFrames</span><span>(</span>gl<span>,</span> <span>0</span><span>,</span> <span>28</span><span>)</span><span>;</span>
					<span>setupBuffers</span><span>(</span><span>)</span><span>;</span>
					framesLoaded <span>=</span> <span>true</span><span>;</span>

					<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
				<span>}</span>
			<span>}</span> <span>else</span> <span>{</span>
				
				isRendering <span>=</span> <span>false</span><span>;</span>
				<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
					
				<span>}</span>
				
				gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>
				
				<span>if</span> <span>(</span>framesLoaded<span>)</span> <span>{</span>
					textures<span>.</span><span>forEach</span><span>(</span><span>texture</span> <span>=&gt;</span> <span>{</span>
						gl<span>.</span><span>deleteTexture</span><span>(</span>texture<span>)</span><span>;</span>
					<span>}</span><span>)</span><span>;</span>
					gl<span>.</span><span>deleteTexture</span><span>(</span>lumaTexture<span>)</span><span>;</span>
					gl<span>.</span><span>deleteFramebuffer</span><span>(</span>lumaBuffer<span>)</span><span>;</span>
					gl<span>.</span><span>deleteTexture</span><span>(</span>blitTexture<span>)</span><span>;</span>
					gl<span>.</span><span>deleteFramebuffer</span><span>(</span>blitBuffer<span>)</span><span>;</span>
					textures <span>=</span> <span>[</span><span>]</span><span>;</span>
					framesLoaded <span>=</span> <span>false</span><span>;</span>
				<span>}</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><p>Just looking at the <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/analytical-anti-aliasing/shader/FXAA-3.11.glsl">full FXAA 3.11 source</a>, you can see the passion in every line. Portable <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/analytical-anti-aliasing/shader/FXAA-3.11.glsl#L611">across OpenGL and DirectX</a>, a <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/analytical-anti-aliasing/shader/FXAA-3.11.glsl#L716">PC version</a>, a <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/analytical-anti-aliasing/shader/FXAA-3.11.glsl#L1341">XBOX 360</a> version, two finely optimized <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/analytical-anti-aliasing/shader/FXAA-3.11.glsl#L1437">PS3 version</a> fighting for every GPU cycle, <a href="https://github.com/FrostKiwi/treasurechest/blob/main/posts/analytical-anti-aliasing/shader/FXAA-3.11.glsl#L1450">including shader disassambly</a>. Such level of professionalism and dedication, shared with the world in plain text.</p><blockquote><p>The sharing and openness is why I&#39;m in love with graphics programming.</p><img src="https://blog.frost.kiwi/assets/kiwis/love.svg"/></blockquote><p>It may be performance cheap, but only if you already have post-processing in place or do <a href="https://en.wikipedia.org/wiki/Deferred_shading">deferred shading</a>. Especially in mobile graphics, memory access is expensive, so saving the framebuffer to perform post processing is not always a given. If you need to setup render-to-texture in order to have FXAA, then the ‚ÄúF‚Äù in FXAA evaporates.</p><p>In this article we won‚Äôt jump into modern <a href="https://sugulee.wordpress.com/2021/06/21/temporal-anti-aliasingtaa-tutorial/">temporal anti-aliasing</a>, but before FXAA was even developed, <a href="https://x.com/NOTimothyLottes/status/1756732098402992584">TAA was already experimented</a> with. In fact, FXAA was supposed to <a href="https://web.archive.org/web/20120120082725/http://timothylottes.blogspot.com/2011/12/fxaa-40-stills-and-features.html">get a new version 4</a> and <a href="https://web.archive.org/web/20120120070945/http://timothylottes.blogspot.com/2011/12/big-fxaa-update-soon.html">incorporate temporal anti aliasing</a> in addition <a href="https://web.archive.org/web/20120120072820/http://timothylottes.blogspot.com/2011/12/fxaa-40-will-have-new-spatial-only.html">to the standard spatial one</a>, but instead it evolved further and rebranded into <a href="https://web.archive.org/web/20210116205348/https://www.nvidia.com/en-gb/geforce/technologies/txaa/technology/">TXAA</a>.</p><h2 id="analytical-anti-aliasing" tabindex="-1">Analytical Anti Aliasing <a href="#analytical-anti-aliasing">#</a></h2><p>Now we get to the good stuff. Analytical Anti-Aliasing approaches the problem backwards - it knows the shape you need and draws the pixel already Anti-Aliased to the screen. Whilst drawing the 2D or 3D shape you need, it fades the shape‚Äôs border by exactly one pixel.</p><div><p> <label for="nativeAnalytical">Native<p>Resolution</p></label></p><p> <label for="halfAnalytical">¬Ω<p>Resolution</p></label></p><p> <label for="quarterAnalytical">¬º<p>Resolution</p></label></p><p> <label for="eightAnalytical">‚Öõ<p>Resolution</p></label></p></div><div><p> <label for="1pxAAA"><svg aria-hidden="true" height="2.3ex" viewBox="0 -750 1728 1000" width="3.9ex" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path d="M94 612q78 4 117 20t73 46h23V73h123V0H88v73h125v244l-1 243q-2-2-15-6t-42-8-59-6l-13-1v73h11Z" id="x"></path><path d="M166 404q28 20 75 35t96 16h4q69 0 110-85 32-63 32-148 0-94-50-163T306-10q-24 0-46 5T222 7t-28 14-18 12-8 5v-232H75v638h90v-20l1-20Zm224-182q0 65-36 109t-88 45-89-36l-9-8V118q32-52 89-52 56 0 94 46t39 110Z" id="y"></path><path d="M187 229 6 444h101l120-150 117 150h49l49-1q-3-6-143-175l-32-39L460 0H359l-65 88-32 43-26 35-9 11L100 0H0l47 58 93 113q47 56 47 58Z" id="z"></path></defs><g data-mml-node="math" fill="currentColor" stroke="currentColor" stroke-width="0"><g data-mml-node="mstyle"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mtable"><g data-mml-node="mtr"><g data-mml-node="mtd"><use data-c="1D7E3" xlink:href="#x" transform="scale(1 -1)" data-mml-node="mn"></use><g data-mml-node="mtext" transform="matrix(1 0 0 -1 500 0)"><use data-c="1D5C9" xlink:href="#y" transform="translate(250)"></use><use data-c="1D5D1" xlink:href="#z" transform="translate(767)"></use></g></g></g></g></g></g></g></svg><p>edge smoothing</p></label></p><p> <label for="sqrt2pxAAA"><svg aria-hidden="true" height="3.1ex" viewBox="0 -934 8030 1368" width="18.2ex" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path d="m263 249 52-119 102-238q51-119 53-120l255 530 257 537q7 11 19 11 7 0 12-6t7-12v-6L741 243 540-176l-71-148q-10-21-16-24-4-2-17-2l-12 1L315-96 205 156l-34-26-34-26-26 26 152 119Z" id="d"></path><path d="M94 612q78 4 117 20t73 46h23V73h123V0H88v73h125v244l-1 243q-2-2-15-6t-42-8-59-6l-13-1v73h11Z" id="a"></path><path d="M222 599q-32 0-56-14t-38-35-20-41-11-35-4-15l-26 33-25 34 5 13q25 69 73 103t105 35q79 0 130-33 94-65 94-190 0-81-88-164l-46-40q-36-30-116-106l-62-59 156 1h156V0H50v79l166 163q68 60 101 107t34 107q0 61-36 102t-93 41Z" id="b"></path><path d="M56 237v13l14 20h299v150l1 150q10 13 19 13 13 0 20-15V270h298q15-8 15-20t-15-20H409V-68q-8-14-18-14h-4q-12 0-18 14v298H70q-14 7-14 20Z" id="c"></path><path d="M56 350q0 13 14 20h637q15-8 15-20 0-11-14-19l-318-1H72q-16 5-16 20Zm0-200q0 15 16 20h636q14-10 14-20 0-12-15-20H70q-14 7-14 20Z" id="e"></path><path d="M95 178q-6 0-14 8t-9 14 31 30 66 50 38 29q2 2 5 2h1q6 0 14-17t54-117l31-69 85-185 104 213 206 429q103 216 107 221 6 14 20 14 7 0 12-6t7-12v-6L620 293 385-193q-4-7-19-7-9 0-12 3L256 15l-96 210-16-11-31-24q-16-12-18-12Z" id="f"></path><path d="M166 404q28 20 75 35t96 16h4q69 0 110-85 32-63 32-148 0-94-50-163T306-10q-24 0-46 5T222 7t-28 14-18 12-8 5v-232H75v638h90v-20l1-20Zm224-182q0 65-36 109t-88 45-89-36l-9-8V118q32-52 89-52 56 0 94 46t39 110Z" id="h"></path><path d="M187 229 6 444h101l120-150 117 150h49l49-1q-3-6-143-175l-32-39L460 0H359l-65 88-32 43-26 35-9 11L100 0H0l47 58 93 113q47 56 47 58Z" id="i"></path></defs><g data-mml-node="math" fill="currentColor" stroke="currentColor" stroke-width="0"><g data-mml-node="mstyle"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mtable"><g data-mml-node="mtr"><g data-mml-node="mtd"><g data-mml-node="msqrt"><g data-mml-node="msup"><use data-c="1D7E3" xlink:href="#a" transform="matrix(1 0 0 -1 1020 184)" data-mml-node="mn"></use><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><use data-c="1D7E4" xlink:href="#b" transform="matrix(.707 0 0 -.707 1553 -105)" data-mml-node="mn"></use></g></g><use data-c="2B" xlink:href="#c" transform="matrix(1 0 0 -1 2179 184)" data-mml-node="mo"></use><g data-mml-node="msup"><use data-c="1D7E3" xlink:href="#a" transform="matrix(1 0 0 -1 3179 184)" data-mml-node="mn"></use><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><use data-c="1D7E4" xlink:href="#b" transform="matrix(.707 0 0 -.707 3712 -105)" data-mml-node="mn"></use></g></g><use data-c="221A" xlink:href="#d" transform="matrix(1 0 0 -1 0 -24)" data-mml-node="mo"></use><path d="M1020-814h3096v-60H1020z" stroke="none"></path></g><use data-c="3D" xlink:href="#e" transform="matrix(1 0 0 -1 4393 184)" data-mml-node="mo"></use><g data-mml-node="msqrt"><use data-c="1D7E4" xlink:href="#b" transform="matrix(1 0 0 -1 6302 184)" data-mml-node="mn"></use><use data-c="221A" xlink:href="#f" transform="matrix(1 0 0 -1 5449 30)" data-mml-node="mo"></use><path d="M6302-710h500v-60h-500z" stroke="none"></path></g><g data-mml-node="mtext" transform="matrix(1 0 0 -1 6802 184)"><use data-c="A0" xlink:href="#g"></use><use data-c="1D5C9" xlink:href="#h" transform="translate(250)"></use><use data-c="1D5D1" xlink:href="#i" transform="translate(767)"></use></g></g></g></g></g></g></g></svg><p>edge smoothing</p></label></p></div><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/analytical.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/analytical.png" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analytical.vs">circle-analytical.vs</a></summary><pre><code>
<span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec3</span> col<span>;</span>


<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>varying</span> <span>vec3</span> color<span>;</span>

<span>varying</span> <span>float</span> pixelSizeAdjusted<span>;</span>


<span>uniform</span> <span>float</span> aspect_ratio<span>;</span>

<span>uniform</span> <span>vec2</span> offset<span>;</span>

<span>uniform</span> <span>float</span> size<span>;</span>

<span>uniform</span> <span>float</span> pixelSize<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	
	uv <span>=</span> vtx<span>;</span>
	
	color <span>=</span> col<span>;</span>

	<span>vec2</span> vertex <span>=</span> vtx<span>;</span>
	
	vertex<span>.</span>x <span>*=</span> aspect_ratio<span>;</span>
	
	vertex <span>*=</span> size <span>+</span> pixelSize<span>;</span>
	
	pixelSizeAdjusted <span>=</span> pixelSize <span>/</span> <span>(</span>size <span>+</span> pixelSize<span>)</span><span>;</span>
	
	vertex <span>+=</span> offset<span>;</span>

	
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vertex<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analytical.fs">circle-analytical.fs</a></summary><pre><code><span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>varying</span> <span>vec3</span> color<span>;</span>

<span>varying</span> <span>float</span> pixelSizeAdjusted<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
	<span>float</span> dist <span>=</span> <span>length</span><span>(</span>uv<span>)</span><span>;</span>

	
	dist <span>+=</span> pixelSizeAdjusted <span>*</span> <span>0.5</span><span>;</span>
	
	
	<span>float</span> alpha <span>=</span> <span>(</span><span>1.0</span> <span>-</span> dist<span>)</span> <span>/</span> pixelSizeAdjusted<span>;</span>

	
    gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color <span>+</span> <span>clamp</span><span>(</span> <span>-</span> uv<span>.</span>y <span>*</span> <span>0.4</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>,</span> alpha<span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleAnalytical.js">circleAnalytical.js</a></summary><pre><code><span>function</span> <span>setupAnalytical</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>,</span> radioName<span>,</span> radioSmoothSize</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> circleDrawFramebuffer<span>,</span> frameTexture<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>let</span> pixelSmoothSize <span>=</span> <span>1</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span>
		<span>}</span>
	<span>)</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	<span>const</span> radiosSmooth <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioSmoothSize<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radiosSmooth<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			pixelSmoothSize <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>const</span> circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelSizeCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;pixelSize&#34;</span><span>)</span><span>;</span>
	<span>const</span> sizeLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> circleOffsetAnim <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>0.0</span><span>,</span> <span>0.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelSizeCircle<span>,</span> <span>(</span><span>2.0</span> <span>/</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>)</span> <span>*</span> pixelSmoothSize<span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation<span>,</span> aspect_ratio<span>)</span><span>;</span>
		<span>var</span> radius <span>=</span> <span>0.1</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		circleOffsetAnim<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		circleOffsetAnim<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle<span>,</span> circleSize<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>ONE</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationPost<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> <span>(</span><span>1.0</span> <span>/</span> aspect_ratio<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationRed<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> <span>1.0</span> <span>/</span> <span>(</span>width <span>/</span> height<span>)</span><span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>
	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><p>Always smooth without artifacts and you can adjust the amount of filtering. Preserves shape even at low resolutions. No extra buffers or extra hardware requirements.</p><blockquote><p>Even runs on basic WebGL 1.0 or OpenGLES 2.0, without any extensions.</p><img src="https://blog.frost.kiwi/assets/kiwis/party.svg"/></blockquote><p>With the above buttons, you can set the smoothing to be equal to one pixel. This gives a sharp result, but comes with the caveat that axis-aligned 90¬∞ sides may still be perseved as ‚Äúflat‚Äù in specific combinations of screen resolution, size and circle position.</p><p>Filtering based on the diagonal pixel size of <code>‚àö2 px = 1.4142...</code>, ensures the ‚Äútip‚Äù of the circle in axis-aligned pixel rows and columns is always non-opaque. This removes the perception of flatness, but makes it shape ever so slightly more blurry.</p><blockquote><p>Or in other words: as soon as the border has an opaque pixel, there is already a transparent pixel &#34;in front&#34; of it.</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"/></blockquote><p>This style of Anti-Aliasing is <a href="http://www.numb3r23.net/2015/08/17/using-fwidth-for-distance-based-anti-aliasing/">usually implemented</a> with 3 ingredients:</p><ul><li>Enabled <a href="https://gamedev.stackexchange.com/a/130933">Screen Space Derivative</a> extension or having a modern graphics context</li><li>Pixel-size calculated via <a href="https://docs.gl/sl4/length"><code>length</code></a>+<a href="https://docs.gl/sl4/dFdx"><code>dFdx</code></a>+<a href="https://docs.gl/sl4/dFdy"><code>dFdy</code></a> or approximated with <a href="https://docs.gl/sl4/fwidth"><code>fwidth</code></a></li><li>Blending with <a href="https://en.wikipedia.org/wiki/Smoothstep"><code>smoothstep</code></a></li></ul><p>But if you look at the code box above, you will find <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analytical.fs">circle-analytical.fs</a> having <strong>none</strong> of those. And this is the secret sauce we will look at. Before we dive into the implementation, let‚Äôs clear the elephants in the room‚Ä¶</p><h3 id="what-even-is-%E2%80%9Canalytical%E2%80%9D%3F" tabindex="-1">What even <em>is</em> ‚ÄúAnalytical‚Äù? <a href="#what-even-is-%E2%80%9Canalytical%E2%80%9D%3F">#</a></h3><p>In graphics programming, <em>Analytical</em> refers to effects created by knowing the make-up of the intended shape beforehand and performing calculations against the rigid mathematical definition of said shape. This term is used <strong><em>very</em></strong> loosely across computer graphics, similar to super sampling referring to multiple things, depending on context.</p><blockquote><p>A picture is worth a thousand words...</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/lastOfUs.jpg" alt="Character soft-shadow from stretched spheres in The Last Of Us."/><figcaption>Character soft-shadow from stretched spheres in The Last Of Us.</figcaption></figure><p>Very soft soft-shadows which include <a href="http://wscg.zcu.cz/WSCG2012/short/B37-full.pdf">contact-hardening</a>, implemented by algorithms like <a href="https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">percentage-closer soft shadows</a> are very computationally intense and require both high resolution shadow maps and/or very aggressive filtering to not produce shimmering during movement.</p><p>This is why <a href="https://en.wikipedia.org/wiki/Naughty_Dog">Naughty Dog</a>‚Äôs <a href="https://en.wikipedia.org/wiki/The_Last_of_Us">The Last of Us</a> relied on getting soft-shadows on the main character by calculating the shadow from a rigidly defined formula of a stretched sphere, multiple of which were arranged in the shape of the main character, shown in red. An improved implementation with shader code can be seen in this <a href="https://www.shadertoy.com/view/3stcD4">Shadertoy demo</a> by <a href="https://www.shadertoy.com/user/romainguy">romainguy</a>, with the more modern <a href="https://en.wikipedia.org/wiki/Capsule_(geometry)">capsule</a>, as opposed a stretched sphere.</p><p>This is now an integral part of modern game engines, <a href="http://dev.epicgames.com/documentation/en-us/unreal-engine/capsule-shadows-overview-in-unreal-engine">like Unreal</a>. As opposed to <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">standard shadow mapping</a>, we don‚Äôt render the scene from the perspective of the light with finite resolution. We evaluate the shadow <em>per-pixel</em> against the mathematical equation of the stretched sphere or capsule. This makes capsule shadows <strong><em>analytical</em></strong>.</p><blockquote><p>A video is worth a thousand words, 30 times a second.</p><img src="https://blog.frost.kiwi/assets/kiwis/laugh.svg"/></blockquote><figure><video controls="" height="540" poster="vid/capsule-lastofus_thumb.jpg" width="960"><source src="vid/capsule-lastofus.mp4" type="video/mp4"/></video><figcaption>Capsule representation of characters in The Last of Us Part II</figcaption></figure><p>Staying with the Last of Us, <a href="https://en.wikipedia.org/wiki/The_Last_of_Us_Part_II">The Last of Us Part II</a> uses the same logic for blurry real-time reflections of the main character, where <a href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">Screen Space Reflections</a> aren‚Äôt defined. Other options like <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@8.2/manual/Ray-Traced-Reflections.html">raytracing against the scene</a>, or using a <a href="https://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/#environment-cubemap">real-time cubemap</a> like in <a href="https://en.wikipedia.org/wiki/Grand_Theft_Auto_V">GTA V</a> are either noisy and low resolution or high resolution, but low performance.</p><p>Here the reflection calculation is part of the material shader, rendering against the rigidly defined mathematical shape of the capsule <em>per-pixel</em>, multiple of which are arranged in the shape of the main character. This makes capsule reflections <strong><em>analytical</em></strong>.</p><blockquote><div><p>An online demo with is worth at least a million...</p></div><img src="https://blog.frost.kiwi/assets/kiwis/facepalm.svg"/></blockquote><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/analytical.png" alt=""/><figcaption><a href="https://www.shadertoy.com/view/4djSDy">Shadertoy demo</a> for Analytical Ambient Occlusion by <a href="https://iquilezles.org/">Inigo Quilez</a></figcaption></figure><p><a href="https://learnopengl.com/Advanced-Lighting/SSAO">Ambient Occlusion</a> is essential in modern rendering, bringing contact shadows and approximating global illumination. Another topic as deep as the ocean, with so many implementations. Usually implemented by some form of ‚Äúraytrace a bunch of rays and blur the result‚Äù.</p><p>In this <a href="https://www.shadertoy.com/view/4djSDy">Shadertoy demo</a>, the floor is evaluated <em>per-pixel</em> against the rigidly defined mathematical description of the sphere to get a soft, non-noisy, non-flickering occlusion contribution from the hovering ball. This implementation is <strong><em>analytical</em></strong>. Not just spheres, there are <a href="https://research.nvidia.com/sites/default/files/pubs/2010-06_Ambient-Occlusion-Volumes/McGuire10AOV.pdf">analytical approaches</a> also for complex geometry.</p><p>By extension, Unreal Engine has distance field approaches for <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/distance-field-soft-shadows-in-unreal-engine">Soft Shadows</a> and <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/using-distance-field-ambient-occlusion-in-unreal-engine">Ambient Occlusion</a>, though one may argue, that this type of signed distance field rendering doesn‚Äôt fit the description of <em>analytical</em>, considering the distance field is precalculated into a 3D texture.</p><h3 id="implementation" tabindex="-1">Implementation <a href="#implementation">#</a></h3><p>Let‚Äôs dive into the sauce. We work with <a href="https://www.youtube.com/watch?v=62-pRVZuS5c">signed distance fields</a>, where for every point that we sample, we know the distance to the desired shape. This information may be baked into a texture as done for <a href="https://github.com/Chlumsky/msdf-atlas-gen">SDF text rendering</a> or maybe be derived <em>per-pixel</em> from a mathematical formula for simpler shapes like <a href="https://iquilezles.org/articles/distfunctions2d/">bezier curves or hearts</a>.</p><p>Based on that distance we fade out the border of the shape. If we fade by the size of one pixel, we get perfectly smooth edges, without any strange side effects. The secret sauce is in the implementation and <a href="https://www.youtube.com/watch?v=bRL8v6--bW4">under the sauce</a> is where the magic is. <em>How</em> does the shader know the size of pixel? <em>How</em> do we blend based on distance?</p><blockquote><p>This approach gives motion-stable pixel-perfection, but doesn&#39;t work with traditional rasterization. The <b>full</b> shape requires a signed distance field.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"/></blockquote><div><p> <label for="nativeCompare">Native<p>Resolution</p></label></p><p> <label for="halfCompare">¬Ω<p>Resolution</p></label></p><p> <label for="quarterCompare">¬º<p>Resolution</p></label></p><p> <label for="eightCompare">‚Öõ<p>Resolution</p></label></p></div><table><tbody><tr><td colspan="4"><code>Pixel¬†size¬†method</code></td></tr><tr><td><code>Pixel¬†size¬†method</code></td><td colspan="2"></td><td></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>Blend¬†method</code></td></tr><tr><td><code>Blend¬†method</code></td><td colspan="2"></td><td></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>Smoothing</code></td></tr><tr><td><code>Smoothing</code></td><td></td><td><output id="SmoothingPxValue">1.0</output>px</td><td></td></tr><tr><td colspan="4"></td></tr><tr><td colspan="4"><code>Radius¬†adjust¬†</code></td></tr><tr><td><code>Radius¬†adjust¬†</code></td><td></td><td><output id="ShrinkAmountValue">0.0</output>px</td><td></td></tr><tr><td colspan="4"></td></tr></tbody></table><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/analytical.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/analytical.png" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analytical.vs">circle-analytical.vs</a></summary><pre><code>
<span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec3</span> col<span>;</span>


<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>varying</span> <span>vec3</span> color<span>;</span>

<span>varying</span> <span>float</span> pixelSizeAdjusted<span>;</span>


<span>uniform</span> <span>float</span> aspect_ratio<span>;</span>

<span>uniform</span> <span>vec2</span> offset<span>;</span>

<span>uniform</span> <span>float</span> size<span>;</span>

<span>uniform</span> <span>float</span> pixelSize<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	
	uv <span>=</span> vtx<span>;</span>
	
	color <span>=</span> col<span>;</span>

	<span>vec2</span> vertex <span>=</span> vtx<span>;</span>
	
	vertex<span>.</span>x <span>*=</span> aspect_ratio<span>;</span>
	
	vertex <span>*=</span> size <span>+</span> pixelSize<span>;</span>
	
	pixelSizeAdjusted <span>=</span> pixelSize <span>/</span> <span>(</span>size <span>+</span> pixelSize<span>)</span><span>;</span>
	
	vertex <span>+=</span> offset<span>;</span>

	
	gl_Position <span>=</span> <span>vec4</span><span>(</span>vertex<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analyticalCompare.fs">circle-analyticalCompare.fs</a></summary><pre><code><span><span>#</span><span>if</span> <span><span>defined</span><span>(</span>FWIDTH<span>)</span> <span>||</span> <span>defined</span><span>(</span>DFD<span>)</span></span></span>
	<span><span>#</span><span>extension</span> <span>GL_OES_standard_derivatives <span>:</span> enable</span></span>
<span><span>#</span><span>endif</span></span>

<span>precision</span> <span>mediump</span> <span>float</span><span>;</span>

<span>varying</span> <span>vec2</span> uv<span>;</span>

<span>varying</span> <span>vec3</span> color<span>;</span>

<span>varying</span> <span>float</span> pixelSizeAdjusted<span>;</span>

<span>uniform</span> <span>float</span> shrinkAmount<span>;</span>

<span>uniform</span> <span>float</span> smoothingAmount<span>;</span>


<span>float</span> <span>linearstep</span><span>(</span><span>float</span> edge0<span>,</span> <span>float</span> edge1<span>,</span> <span>float</span> x<span>)</span> <span>{</span>
    <span>return</span> <span>clamp</span><span>(</span><span>(</span>x <span>-</span> edge0<span>)</span> <span>/</span> <span>(</span>edge1 <span>-</span> edge0<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>


<span>float</span> <span>linearstepNoclamp</span><span>(</span><span>float</span> edge0<span>,</span> <span>float</span> edge1<span>,</span> <span>float</span> x<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>x <span>-</span> edge0<span>)</span> <span>/</span> <span>(</span>edge1 <span>-</span> edge0<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
	<span>float</span> dist <span>=</span> <span>length</span><span>(</span>uv<span>)</span><span>;</span>
	
	
	<span><span>#</span><span>if</span> <span><span>defined</span><span>(</span>SIMPLE<span>)</span></span></span>
	    <span>float</span> pixelSize <span>=</span> pixelSizeAdjusted<span>;</span>
	<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>DFD<span>)</span></span></span>
	    <span>float</span> pixelSize <span>=</span> <span>length</span><span>(</span><span>vec2</span><span>(</span><span>dFdx</span><span>(</span>dist<span>)</span><span>,</span> <span>dFdy</span><span>(</span>dist<span>)</span><span>)</span><span>)</span><span>;</span>
	<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>FWIDTH<span>)</span></span></span>
	    <span>float</span> pixelSize <span>=</span> <span>fwidth</span><span>(</span>dist<span>)</span><span>;</span>
	<span><span>#</span><span>endif</span></span>

	
	dist <span>+=</span> pixelSize <span>*</span> shrinkAmount<span>;</span>

		
	<span><span>#</span><span>if</span> <span><span>defined</span><span>(</span>DIVISION<span>)</span></span></span>
	    <span>float</span> alpha <span>=</span> <span>(</span><span>1.0</span> <span>-</span> dist<span>)</span> <span>/</span> <span>(</span>pixelSize <span>*</span> smoothingAmount<span>)</span><span>;</span>
	<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>SMOOTHSTEP<span>)</span></span></span>
	    <span>float</span> alpha <span>=</span> <span>smoothstep</span><span>(</span><span>1.0</span><span>,</span> <span>1.0</span> <span>-</span> pixelSize <span>*</span> smoothingAmount<span>,</span> dist<span>)</span><span>;</span>
	<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>LINSTEP<span>)</span></span></span>
	    <span>float</span> alpha <span>=</span> <span>linearstep</span><span>(</span><span>1.0</span><span>,</span> <span>1.0</span> <span>-</span> pixelSize <span>*</span> smoothingAmount<span>,</span> dist<span>)</span><span>;</span>
	<span><span>#</span><span>elif</span> <span><span>defined</span><span>(</span>LINSTEP_NO_CLAMP<span>)</span></span></span>
	    <span>float</span> alpha <span>=</span> <span>linearstepNoclamp</span><span>(</span><span>1.0</span><span>,</span> <span>1.0</span> <span>-</span> pixelSize <span>*</span> smoothingAmount<span>,</span> dist<span>)</span><span>;</span>
	<span><span>#</span><span>endif</span></span>

	
    gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color <span>+</span> <span>clamp</span><span>(</span> <span>-</span> uv<span>.</span>y <span>*</span> <span>0.4</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>,</span> alpha<span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleAnalyticalComparison.js">circleAnalyticalComparison.js</a></summary><pre><code><span>function</span> <span>setupAnalyticalComparison</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>,</span> radioName</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> circleDrawFramebuffer<span>,</span> frameTexture<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>let</span> shrinkAmount <span>=</span> <span>1</span><span>;</span>
	<span>let</span> smoothingAmount <span>=</span> <span>1</span><span>;</span>
	<span>let</span> pixelSizeMethod <span>=</span> <span>&#34;SIMPLE&#34;</span><span>;</span>
	<span>let</span> blendMethod <span>=</span> <span>&#34;DIVISION&#34;</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span>
		<span>}</span>
	<span>)</span><span>;</span>

	<span>let</span> DerivativesExtension <span>=</span> gl<span>.</span><span>getExtension</span><span>(</span><span>&#39;OES_standard_derivatives&#39;</span><span>)</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>const</span> pixelSizeMethodSwitch <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;pixelSizeMethod&#39;</span><span>)</span><span>;</span>
	pixelSizeMethodSwitch<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		pixelSizeMethod <span>=</span> pixelSizeMethodSwitch<span>.</span>value<span>;</span>
		<span>updateShader</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>const</span> blendMethodSwitch <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;BLENDMETHOD&#39;</span><span>)</span><span>;</span>
	blendMethodSwitch<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		blendMethod <span>=</span> blendMethodSwitch<span>.</span>value<span>;</span>
		<span>updateShader</span><span>(</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	<span>const</span> SmoothingPxRange <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;SmoothingPxRange&#39;</span><span>)</span><span>;</span>
	<span>const</span> ShrinkAmountRange <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>&#39;ShrinkAmountRange&#39;</span><span>)</span><span>;</span>

	SmoothingPxRange<span>.</span><span>addEventListener</span><span>(</span><span>&#39;input&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		smoothingAmount <span>=</span> SmoothingPxRange<span>.</span>value<span>;</span>
	<span>}</span><span>)</span><span>;</span>
	ShrinkAmountRange<span>.</span><span>addEventListener</span><span>(</span><span>&#39;input&#39;</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		shrinkAmount <span>=</span> <span>-</span>ShrinkAmountRange<span>.</span>value<span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>let</span> circleShd<span>;</span>
	<span>let</span> aspect_ratioLocation<span>;</span>
	<span>let</span> offsetLocationCircle<span>;</span>
	<span>let</span> shrinkAmountLocation<span>;</span>
	<span>let</span> smoothingAmountLocation<span>;</span>
	<span>let</span> pixelSizeCircle<span>;</span>
	<span>let</span> sizeLocationCircle<span>;</span>

	<span>function</span> <span>updateShader</span><span>(</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>circleShd<span>)</span> <span>{</span>
			gl<span>.</span><span>deleteProgram</span><span>(</span>circleShd<span>)</span><span>;</span>
		<span>}</span>

		<span>const</span> prefix <span>=</span> <span><span>`</span><span>
        #define </span><span><span>${</span>pixelSizeMethod<span>}</span></span><span>
        #define </span><span><span>${</span>blendMethod<span>}</span></span><span>
	    </span><span>`</span></span><span>;</span>

		circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> prefix<span>)</span><span>;</span>

		aspect_ratioLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
		offsetLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
		shrinkAmountLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;shrinkAmount&#34;</span><span>)</span><span>;</span>
		smoothingAmountLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;smoothingAmount&#34;</span><span>)</span><span>;</span>
		pixelSizeCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;pixelSize&#34;</span><span>)</span><span>;</span>
		sizeLocationCircle <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;size&#34;</span><span>)</span><span>;</span>
	<span>}</span>
	<span>updateShader</span><span>(</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> redShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> redVtxSrc<span>,</span> redFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>
	<span>const</span> aspect_ratioLocationRed <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;aspect_ratio&#34;</span><span>)</span><span>;</span>
	<span>const</span> thicknessLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;thickness&#34;</span><span>)</span><span>;</span>
	<span>const</span> pixelsizeLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>redShd<span>,</span> <span>&#34;pixelsize&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>const</span> circleOffsetAnim <span>=</span> <span>new</span> <span>Float32Array</span><span>(</span><span>[</span>
		<span>0.0</span><span>,</span> <span>0.0</span>
	<span>]</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelSizeCircle<span>,</span> <span>(</span><span>2.0</span> <span>/</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>)</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocation<span>,</span> aspect_ratio<span>)</span><span>;</span>
		<span>var</span> radius <span>=</span> <span>0.1</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>10000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		circleOffsetAnim<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		circleOffsetAnim<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationCircle<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>sizeLocationCircle<span>,</span> circleSize<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>shrinkAmountLocation<span>,</span> shrinkAmount<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>smoothingAmountLocation<span>,</span> smoothingAmount<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>ONE</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationPost<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>redShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>aspect_ratioLocationRed<span>,</span> <span>(</span><span>1.0</span> <span>/</span> aspect_ratio<span>)</span> <span>-</span> <span>1.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.2</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>(</span><span>1.0</span> <span>/</span> canvas<span>.</span>width<span>)</span> <span>*</span> <span>50</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.25</span><span>,</span> <span>0.25</span><span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2fv</span><span>(</span>offsetLocationRed<span>,</span> circleOffsetAnim<span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		gl<span>.</span><span>uniform1f</span><span>(</span>thicknessLocation<span>,</span> <span>0.1</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform1f</span><span>(</span>pixelsizeLocation<span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocationRed<span>,</span> <span>0.5</span><span>,</span> <span>0.5</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationRed<span>,</span> <span>-</span><span>0.75</span><span>,</span> <span>-</span><span>0.75</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> <span>1.0</span> <span>/</span> <span>(</span>width <span>/</span> height<span>)</span><span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>
	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span>
</code></pre></details></blockquote><h4 id="how-big-is-a-pixel%3F" tabindex="-1">How big is a pixel? <a href="#how-big-is-a-pixel%3F">#</a></h4><p>Specifically, by how much do we fade the border? If we hardcode a static value, eg. fade at 95% of the circle‚Äôs radius, we may get a pleasing result for that circle size at that screen resolution, but too much smoothing when the circle is bigger or closer to the camera and aliasing if the circle becomes small.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/fade.png" alt="Too much edge fading relative to this circle size"/><figcaption>Too much edge fading relative to this circle size</figcaption></figure><p>We need to know the size of a pixel. This is in part what <a href="https://gamedev.stackexchange.com/a/130933">Screen Space derivatives</a> were created for. Shader functions like <a href="https://docs.gl/sl4/dFdx"><code>dFdx</code></a>, <a href="https://docs.gl/sl4/dFdy"><code>dFdy</code></a> and <a href="https://docs.gl/sl4/fwidth"><code>fwidth</code></a> allow you to get the size of a screen pixel relative to some vector. In the above <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analyticalCompare.fs">circle-analyticalCompare.fs</a> we determine by how much the distance changes via two methods:</p><pre><code>pixelSize <span>=</span> <span>fwidth</span><span>(</span>dist<span>)</span><span>;</span>

pixelSize <span>=</span> <span>length</span><span>(</span><span>vec2</span><span>(</span><span>dFdx</span><span>(</span>dist<span>)</span><span>,</span> <span>dFdy</span><span>(</span>dist<span>)</span><span>)</span><span>)</span><span>;</span></code></pre><p>Relying on Screen Space derivatives has the benefit, that we get the pixel size delivered to us by the graphics pipeline. It properly respects any transformations we might throw at it, including 3D perspective.</p><p>The down side is that it is not supported by the WebGL 1 standard and has to be pulled in via the extension <code>GL_OES_standard_derivatives</code> or requires the jump to WebGL 2.</p><blockquote><p>Luckily I have never witnessed any device that supported WebGL 1, but not the Screen Space derivatives. Even the GMA based <a href="https://www.youtube.com/watch?v=Fs4GjDiOie8">Thinkpad X200 &amp; T500</a> I hardware modded do.</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><h5>Possibly painful</h5><p>Generally, there are some nasty pitfalls when using Screen Space derivatives: how the calculation happens is up to the implementation. This led to the split into <code>dFdxFine()</code> and <code>dFdxCoarse()</code> in later OpenGL revisions. The default case can be set via <a href="https://docs.gl/gl4/glHint"><code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code></a>, but the standard hates you:</p><blockquote><p><a href="https://docs.gl/sl4/dFdx"><strong>OpenGL Docs</strong></a>: The implementation <em><strong>may</strong></em> choose which calculation to perform based upon factors such as performance or the value of the API <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code> hint.</p></blockquote><blockquote><p>Why do we have standards again? As a graphics programmer, anything with <code>hint</code> has me traumatized.</p><img src="https://blog.frost.kiwi/assets/kiwis/tired.svg"/></blockquote><p>Luckily, neither case concerns us, as the difference doesn‚Äôt show itself in the context of Anti-Aliasing. Performance technically <a href="https://docs.gl/sl4/dFdx"><code>dFdx</code></a> and <a href="https://docs.gl/sl4/dFdy"><code>dFdy</code></a> are free (or rather, their cost is already part of the rendering pipeline), though the pixel size calculation using <code>length()</code> or <code>fwidth()</code> is not. It is performed <em>per-pixel</em>.</p><h5><a href="https://docs.gl/sl4/dFdx"><code>dFdx</code></a> + <a href="https://docs.gl/sl4/dFdy"><code>dFdy</code></a> + <a href="https://docs.gl/sl4/length"><code>length()</code></a> vs <a href="https://docs.gl/sl4/fwidth"><code>fwidth()</code></a></h5><p>This is why there exist two ways of doing this: getting the <code>length()</code> of the vector that <code>dFdx</code> and <code>dFdy</code> make up, a step involving the historically performance expensive <code>sqrt()</code> function or using <code>fwidth()</code>, which is the approximation <code>abs(dFdx()) + abs(dFdy())</code> of the above.</p><blockquote><p>It depends on context, but on semi-modern hardware a call to <code>length()</code> should be performance trivial though, even per-pixel.</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><p>To showcase the difference, the above <code>Radius adjust</code> slider works off of the <code>Pixel size method</code> and adjusts the SDF distance. If you go with <code>fwidth()</code> and a strong radius shrink, you‚Äôll see something weird.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/rhobus.png" alt="Rhombous warping at small shape sizes due to use of fwidth()"/><figcaption>Rhombous warping at small shape sizes due to use of <code>fwidth()</code></figcaption></figure><p>The diagonals shrink more than they should, as the approximation using addition scales too much diagonally. We‚Äôll talk about professional implementations further below in a moment, but using <code>fwidth()</code> for AAA is what Unity extension ‚Äú<a href="https://acegikmo.com/shapes/docs/#anti-aliasing">Shapes</a>‚Äù by <a href="https://twitter.com/FreyaHolmer/">Freya Holm√©r</a> calls ‚Äú<a href="https://acegikmo.com/shapes/docs#anti-aliasing">Fast Local Anti-Aliasing</a>‚Äù with the following text:</p><blockquote><p>Fast LAA has a slight bias in the diagonal directions, making circular shapes appear ever so slightly rhombous and have a slightly sharper curvature in the orthogonal directions, especially when small. Sometimes the edges in the diagonals are slightly fuzzy as well.</p></blockquote><p>This effects our fading, which will fade more on diagonals. Luckily, we fade by the amount of one pixel and thus the difference is really only visible when flicking between the methods. What to choose depends on what you care more about: Performance or Accuracy? But what if I told you can have your cake and eat it too‚Ä¶</p><h5>DIY</h5><p>‚Ä¶Calculate it yourself! For the 2D case, this is trivial and easily abstracted away. We know the size our context is rendering at and how big our quad is that we draw on. Calculating the size of the pixel is thus done per-object, not per-pixel. This is what happens in the above <a href="https://blog.frost.kiwi/analytical-anti-aliasing/circleAnalyticalComparison.js">circleAnalyticalComparison.js</a>.</p><pre><code>
gl<span>.</span><span>uniform1f</span><span>(</span>pixelSizeCircle<span>,</span> <span>(</span><span>2.0</span> <span>/</span> <span>(</span>canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>)</span><span>)</span><span>;</span></code></pre><blockquote><p>No WebGL 2, no extensions, works on ancient hardware.</p><img src="https://blog.frost.kiwi/assets/kiwis/party.svg"/></blockquote><p>The results are identical to the <code>dFdx</code> + <code>dFdy</code> + <code>length()</code> case, with the benefit of fully skipping the per-pixel calculation. This does become more involved, once the quad is stretched and performance-painful when perspective is involved.</p><h4 id="how-do-we-blend%3F" tabindex="-1">How do we blend? <a href="#how-do-we-blend%3F">#</a></h4><p>Ok, now we have the amount we want to blend by. The next step is to perform the adjustment of opacity. If we are doing 2D, then Alpha blending is the way to go. Straight forward, will never betray you.</p><p>Another option is using MSAA + <a href="https://bgolus.medium.com/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f">Alpha to Coverage</a>, as is done in the MSAA demo above. There are pit falls with the latter, as discussed previously and more headaches to follow below. The reason you would need this is for depth-buffer writes for <a href="https://bgolus.medium.com/rendering-a-sphere-on-a-quad-13c92025570c">correct blending in 3D scenes</a>.</p><blockquote><p>For the MSAA and AAA demos above, merely an API level switch. In both cases, the shaders are 100% <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/circle-analytical.fs">identical</a>!</p><img src="https://blog.frost.kiwi/assets/kiwis/happy.svg"/></blockquote><p>Still the alpha itself has to be faded based on distance. Here is where a ‚Äústep‚Äù function comes in. We can input a start, an end point and the function will fade between them. <a href="http://www.numb3r23.net/2015/08/17/using-fwidth-for-distance-based-anti-aliasing/">Usually</a>, this is where the graphics programmer‚Äôs favorite <code>smoothstep()</code> comes in and where this blog post‚Äôs hot take begins:</p><h5>Don‚Äôt use <a href="https://en.wikipedia.org/wiki/Smoothstep"><code>smoothstep()</code></a></h5><p>Its use is <a href="http://www.numb3r23.net/2015/08/17/using-fwidth-for-distance-based-anti-aliasing/">often associated</a> with implementing anti-aliasing in <code>GLSL</code>, but its use doesn‚Äôt make sense in this context. It performs a <a href="https://en.wikipedia.org/wiki/Smoothstep">hermite interpolation</a>, but we</p><blockquote><p>To be precise, both sampling and blending witness the smoothstep curve in the sub-pixel make-up of the edge, but the difference is tiny and can be corrected using an adjusted smoothing amount.</p><img src="https://blog.frost.kiwi/assets/kiwis/detective.svg"/></blockquote><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/smoothstep.svg" alt="Smoothstep and linear comparison"/><figcaption>Smoothstep and linear comparison</figcaption></figure><p>Even though the slight performance difference doesn‚Äôt particularly matter on modern graphics cards, wasting cycles on performing the hermite interpolation doesn‚Äôt make sense to me. Let‚Äôs DIY it! The implementation of <a href="https://en.wikipedia.org/wiki/Smoothstep"><code>smoothstep()</code></a> is up to the vendor, but for the <code>float</code> case it‚Äôs essentially just :</p><pre><code><span>float</span> <span>smoothstep</span><span>(</span><span>float</span> edge0<span>,</span> <span>float</span> edge1<span>,</span> <span>float</span> x<span>)</span> <span>{</span>
    <span>float</span> t <span>=</span> <span>clamp</span><span>(</span><span>(</span>x <span>-</span> edge0<span>)</span> <span>/</span> <span>(</span>edge1 <span>-</span> edge0<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
	<span>return</span> t <span>*</span> t <span>*</span> <span>(</span><span>3.0</span> <span>-</span> <span>2.0</span> <span>*</span> t<span>)</span><span>;</span>
<span>}</span>
<span>.</span><span>.</span><span>.</span>
<span>float</span> alpha <span>=</span> <span>smoothstep</span><span>(</span><span>1.0</span><span>,</span> <span>1.0</span> <span>-</span> pixelSize <span>*</span> smoothingAmount<span>,</span> dist<span>)</span><span>;</span></code></pre><p>We can rip out the hermite interpolation and stick to the simple linear one. If you flick between the two in the above demo, you‚Äôll see only a slight change, with pixel sized smoothing. At pixel size, the difference can easily be counter acted with an adjustment to the smoothing factor if you like one method over the other.</p><pre><code>
<span>float</span> <span>linearstep</span><span>(</span><span>float</span> edge0<span>,</span> <span>float</span> edge1<span>,</span> <span>float</span> x<span>)</span> <span>{</span>
    <span>return</span> <span>clamp</span><span>(</span><span>(</span>x <span>-</span> edge0<span>)</span> <span>/</span> <span>(</span>edge1 <span>-</span> edge0<span>)</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>
<span>.</span><span>.</span><span>.</span>
<span>float</span> alpha <span>=</span> <span>linearstep</span><span>(</span><span>1.0</span><span>,</span> <span>1.0</span> <span>-</span> pixelSize <span>*</span> smoothingAmount<span>,</span> dist<span>)</span><span>;</span></code></pre><p>But why even clamp? Alpha values below 0.0 or above 1.0 will be taken care of by the rendering pipeline during the blending step and thus no clamping is required. It <em>is</em> required when having multiple shapes on one quad, something I‚Äôll go into below. But in the one shape per quad case, we can delete it.</p><pre><code>
<span>float</span> <span>linearstepNoclamp</span><span>(</span><span>float</span> edge0<span>,</span> <span>float</span> edge1<span>,</span> <span>float</span> x<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>x <span>-</span> edge0<span>)</span> <span>/</span> <span>(</span>edge1 <span>-</span> edge0<span>)</span><span>;</span>
<span>}</span>
<span>.</span><span>.</span><span>.</span>
<span>float</span> alpha <span>=</span> <span>linearstepNoclamp</span><span>(</span><span>1.0</span><span>,</span> <span>1.0</span> <span>-</span> pixelSize <span>*</span> smoothingAmount<span>,</span> dist<span>)</span><span>;</span></code></pre><p>But wait a moment‚Ä¶ When doing Anti-Aliasing we wish to affect the border of the shape, specifically distance 1.0, so most of this function cancels out! In fact, we <strong>don‚Äôt</strong> need a step function. The blending can be performed by a simple division.</p><pre><code><span>float</span> alpha <span>=</span> <span>(</span><span>1.0</span> <span>-</span> dist<span>)</span> <span>/</span> <span>(</span>pixelSize <span>*</span> smoothingAmount<span>)</span><span>;</span></code></pre><p>I have been using this simplified term in different places for years. Performance wise, the most expensive thing still remains: the per-pixel division. Modern cards should also have no issues optimizing the hermite interpolation‚Äôs multiplication and addition down to a few <a href="https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add">Fused Multiply-Add</a> instructions. Still, I prefer the simplicity.</p><h5>What‚Äôs with the shrinking?</h5><p>There is an ellusive implementation interaction with MSAA and the rasterizer. <em>Only</em> when using this with MSAA + Alpha to Coverage (regardless of sample count), there will be exactly one side of the quad with a missing 0.5 pixels, on <strong>some</strong> hardware. This is why there is this weird 0.5 px breathing room being added.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/hardEdgeBug.png" alt="Hard edge bug with MSAA on select hardware"/><figcaption>Hard edge bug with MSAA on select hardware</figcaption></figure><p>Our circle is drawn to the very edge of the quad, which works, but only as long the graphics card doesn‚Äôt surprise us with edge cases. Specifically modern NVIDIA cards seems to eat one side of the quad too soon, though I have never seen this occur with alpha blending. To combat this, we give our SDF 0.5px of breathing room:</p><pre><code>
dist <span>+=</span> pixelSizeAdjusted <span>*</span> <span>0.5</span><span>;</span></code></pre><blockquote><p>An edge case.</p><img src="https://blog.frost.kiwi/assets/kiwis/laugh.svg"/></blockquote><h5>Drawing multiple?</h5><p>You can draw multiple shapes in one Quad and both will be Anti-Aliased, though blending will start to get more involved. In that case both shapes will need to be evaluated per-pixel and their results will need to be clamped, weighted and summed, otherwise there won‚Äôt be Anti-Aliasing when they intersect.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/multiple.jpg" alt="Aliasing free blending of multiple circle visualizations from mirrorball.frost.kiwi"/><figcaption>Aliasing free blending of multiple visualizations</figcaption></figure><p>Here is what blending looks like in my WebApp <a href="https://mirrorball.frost.kiwi">üîÆ Mathematical Magic Mirrorball</a>, a WebApp which pulls 360¬∞ panoramic projections from photos, videos and live-streams of mirror balls. There I have multiple visualizations and color overlays explaining resolution distribution of the projection. <a href="https://github.com/FrostKiwi/Mirrorball/blob/main/src/shd/crop.fs#L35">The code</a> to keep all this anti-aliased is:</p><pre><code><span>float</span> factorGreen <span>=</span> area_toggle <span>*</span> <span>clamp</span><span>(</span><span>(</span>area_f <span>-</span> lenCircle<span>)</span> <span>*</span> pxsize_rcp<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>float</span> factorRed <span>=</span> area_toggle <span>*</span> <span>clamp</span><span>(</span><span>(</span>lenCircle <span>-</span> area_b<span>)</span> <span>*</span> pxsize_rcp<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span> <span>*</span> smoothedAlpha<span>;</span>
<span>float</span> factorBlack <span>=</span> mask_toggle <span>*</span> <span>(</span><span>1.0</span> <span>-</span> smoothedAlpha<span>)</span><span>;</span>

<span>vec3</span> finalColor <span>=</span> baseColor <span>*</span> <span>(</span><span>1.0</span> <span>-</span> factorGreen <span>-</span> factorRed <span>-</span> factorBlack<span>)</span> <span>+</span>
                  greenColor <span>*</span> factorGreen <span>+</span>
                  redColor <span>*</span> factorRed <span>+</span>
                  blackColor <span>*</span> factorBlack<span>;</span></code></pre><p>All this additional stuff ‚Ä¶ why not draw color overlays in an additional pass? The cost of drawing across that area again is an order of magnitude higher than just coloring the output in the shape we need as we go. Tinting in an Anti-Aliased fashion in one draw-call is the cleanest way to do this I think.</p><h3 id="3d" tabindex="-1">3D <a href="#3d">#</a></h3><p>Everything we talked about extends to the 3D case as well. We won‚Äôt dig <a href="https://iquilezles.org/articles/distfunctions/">into 3D shapes themselves</a> and will stick to a 2D rounded square in 3D perspective with a moving camera. I use this a lot when graphics programming to create a scene with a ‚Äúground floor‚Äù where my objects live on.</p><div><p> <label for="native3D">Native<p>Resolution</p></label></p><p> <label for="half3D">¬Ω<p>Resolution</p></label></p><p> <label for="quarter3D">¬º<p>Resolution</p></label></p><p> <label for="eight3D">‚Öõ<p>Resolution</p></label></p></div><div><p> <label for="showCirclelabel3D">Draw Rounded Square</label></p><p> <label for="showQuadlabel3D">Show Quad</label></p></div><blockquote><details><summary><a href="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/3d.png">Screenshot</a>, in case WebGL doesn&#39;t work</summary><p><img src="https://blog.frost.kiwi/analytical-anti-aliasing/screenshots/3d.png" alt="image"/></p></details><details><summary>WebGL Vertex Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/3DAnalytical.vs">3DAnalytical.vs</a></summary><pre><code>
<span>attribute</span> <span>vec2</span> vtx<span>;</span>
<span>attribute</span> <span>vec3</span> col<span>;</span>

<span>varying</span> <span>vec2</span> uv<span>;</span>
<span>varying</span> <span>vec3</span> color<span>;</span>
<span>uniform</span> <span>mat4</span> perspective<span>;</span>

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	
	uv <span>=</span> vtx<span>;</span>
	
	color <span>=</span> col<span>;</span>

	
    <span>vec4</span> pos <span>=</span> <span>vec4</span><span>(</span>vtx<span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
    gl_Position <span>=</span> perspective <span>*</span> pos<span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Fragment Shader <a href="https://blog.frost.kiwi/analytical-anti-aliasing/shader/3DAnalytical.fs">3DAnalytical.fs</a></summary><pre><code><span><span>#</span><span>extension</span> <span>GL_OES_standard_derivatives <span>:</span> enable</span></span>
<span>precision</span> <span>mediump</span> <span>float</span><span>;</span>
<span>varying</span> <span>vec2</span> uv<span>;</span>
<span>varying</span> <span>vec3</span> color<span>;</span>

<span>float</span> <span>roundedBoxSDF</span><span>(</span><span>vec2</span> uv<span>,</span> <span>float</span> Size<span>,</span> <span>float</span> Radius<span>)</span>
<span>{</span>
    <span>return</span> <span>length</span><span>(</span><span>max</span><span>(</span><span>abs</span><span>(</span>uv<span>)</span> <span>-</span> Size <span>+</span> Radius<span>,</span> <span>0.0</span><span>)</span><span>)</span> <span>-</span> Radius<span>;</span>
<span>}</span>

<span>void</span> <span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
	
	
	<span>float</span> dist <span>=</span> <span>roundedBoxSDF</span><span>(</span>uv<span>,</span> <span>1.0</span><span>,</span> <span>0.4</span><span>)</span><span>;</span>

	
	<span>float</span> pixelSize <span>=</span> <span>length</span><span>(</span><span>vec2</span><span>(</span><span>dFdx</span><span>(</span>dist<span>)</span><span>,</span> <span>dFdy</span><span>(</span>dist<span>)</span><span>)</span><span>)</span><span>;</span>
	<span>float</span> alpha <span>=</span> <span>-</span>dist <span>/</span> <span>(</span>pixelSize <span>*</span> <span>1.4142135623730950488016887242097</span><span>)</span><span>;</span>

	
    gl_FragColor <span>=</span> <span>vec4</span><span>(</span>color <span>+</span> <span>clamp</span><span>(</span> <span>-</span> uv<span>.</span>y <span>*</span> <span>0.4</span><span>,</span> <span>0.0</span><span>,</span> <span>1.0</span><span>)</span><span>,</span> alpha<span>)</span><span>;</span>
<span>}</span></code></pre></details><details><summary>WebGL Javascript <a href="https://blog.frost.kiwi/analytical-anti-aliasing/3DAnalytical.js">3DAnalytical.js</a></summary><pre><code><span>function</span> <span>setup3D</span><span>(</span><span>canvasId<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>,</span> simpleColorFragSrc<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>,</span> radioName<span>,</span> showQuadOpt</span><span>)</span> <span>{</span>
	
	<span>const</span> canvas <span>=</span> document<span>.</span><span>getElementById</span><span>(</span>canvasId<span>)</span><span>;</span>
	<span>let</span> circleDrawFramebuffer<span>,</span> frameTexture<span>;</span>
	<span>let</span> buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>let</span> showQuad <span>=</span> <span>false</span><span>;</span>
	<span>let</span> resDiv <span>=</span> <span>1</span><span>;</span>
	<span>const</span> gl <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>&#39;webgl&#39;</span><span>,</span>
		<span>{</span>
			<span>preserveDrawingBuffer</span><span>:</span> <span>false</span><span>,</span>
			<span>antialias</span><span>:</span> <span>false</span><span>,</span>
			<span>alpha</span><span>:</span> <span>true</span>
		<span>}</span>
	<span>)</span><span>;</span>

	<span>let</span> DerivativesExtension <span>=</span> gl<span>.</span><span>getExtension</span><span>(</span><span>&#39;OES_standard_derivatives&#39;</span><span>)</span><span>;</span>

	
	<span>const</span> radios <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>radioName<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	radios<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;1&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			resDiv <span>=</span> event<span>.</span>target<span>.</span>value<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	<span>const</span> showQuadOption <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span><span>`</span><span>input[name=&#34;</span><span><span>${</span>showQuadOpt<span>}</span></span><span>&#34;]</span><span>`</span></span><span>)</span><span>;</span>
	showQuadOption<span>.</span><span>forEach</span><span>(</span><span>radio</span> <span>=&gt;</span> <span>{</span>
		
		<span>if</span> <span>(</span>radio<span>.</span>value <span>===</span> <span>&#34;false&#34;</span><span>)</span>
			radio<span>.</span>checked <span>=</span> <span>true</span><span>;</span>
		radio<span>.</span><span>addEventListener</span><span>(</span><span>&#39;change&#39;</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
			showQuad <span>=</span> <span>(</span>event<span>.</span>target<span>.</span>value <span>===</span> <span>&#34;true&#34;</span><span>)</span><span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>

	
	
	<span>const</span> circleShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> circleFragSrc<span>)</span><span>;</span>
	<span>const</span> viewProjectionLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>circleShd<span>,</span> <span>&#34;perspective&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> simpleColorShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> circleVtxSrc<span>,</span> simpleColorFragSrc<span>)</span><span>;</span>
	<span>const</span> viewProjectionLocationSimple <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>simpleColorShd<span>,</span> <span>&#34;perspective&#34;</span><span>)</span><span>;</span>

	
	<span>const</span> blitShd <span>=</span> <span>compileAndLinkShader</span><span>(</span>gl<span>,</span> blitVtxSrc<span>,</span> blitFragSrc<span>)</span><span>;</span>
	<span>const</span> transformLocation <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;transform&#34;</span><span>)</span><span>;</span>
	<span>const</span> offsetLocationPost <span>=</span> gl<span>.</span><span>getUniformLocation</span><span>(</span>blitShd<span>,</span> <span>&#34;offset&#34;</span><span>)</span><span>;</span>

	<span>const</span> vertex_buffer <span>=</span> gl<span>.</span><span>createBuffer</span><span>(</span><span>)</span><span>;</span>
	gl<span>.</span><span>bindBuffer</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> vertex_buffer<span>)</span><span>;</span>
	gl<span>.</span><span>bufferData</span><span>(</span>gl<span>.</span><span>ARRAY_BUFFER</span><span>,</span> unitQuad<span>,</span> gl<span>.</span><span>STATIC_DRAW</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>vertexAttribPointer</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>,</span> gl<span>.</span><span>FLOAT</span><span>,</span> <span>false</span><span>,</span> <span>5</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>,</span> <span>2</span> <span>*</span> Float32Array<span>.</span><span>BYTES_PER_ELEMENT</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>0</span><span>)</span><span>;</span>
	gl<span>.</span><span>enableVertexAttribArray</span><span>(</span><span>1</span><span>)</span><span>;</span>

	<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>

	<span>let</span> aspect_ratio <span>=</span> <span>0</span><span>;</span>
	<span>let</span> last_time <span>=</span> <span>0</span><span>;</span>
	<span>let</span> redrawActive <span>=</span> <span>false</span><span>;</span>

	<span>function</span> <span>setupTextureBuffers</span><span>(</span><span>)</span> <span>{</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		circleDrawFramebuffer <span>=</span> gl<span>.</span><span>createFramebuffer</span><span>(</span><span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>

		frameTexture <span>=</span> <span>setupTexture</span><span>(</span>gl<span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>,</span> frameTexture<span>,</span> gl<span>.</span><span>NEAREST</span><span>)</span><span>;</span>
		gl<span>.</span><span>framebufferTexture2D</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> gl<span>.</span><span>COLOR_ATTACHMENT0</span><span>,</span> gl<span>.</span><span>TEXTURE_2D</span><span>,</span> frameTexture<span>,</span> <span>0</span><span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>true</span><span>;</span>
	<span>}</span>

	<span>let</span> viewMatrix <span>=</span> Mat4<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
	<span>let</span> projectionMatrix <span>=</span> Mat4<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>

	<span>let</span> eye <span>=</span> <span>[</span><span>1.5</span><span>,</span> <span>1.5</span><span>,</span> <span>1.5</span><span>]</span><span>;</span>
	<span>let</span> target <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span><span>;</span>
	<span>let</span> up <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>]</span><span>;</span>

	gl<span>.</span><span>enable</span><span>(</span>gl<span>.</span><span>BLEND</span><span>)</span><span>;</span>

	<span>function</span> <span>redraw</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		redrawActive <span>=</span> <span>true</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>buffersInitialized<span>)</span> <span>{</span>
			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
		last_time <span>=</span> time<span>;</span>

		<span>const</span> radius <span>=</span> <span>5</span> <span>+</span> <span>4</span> <span>*</span> Math<span>.</span><span>sin</span><span>(</span>time <span>/</span> <span>2000</span><span>)</span><span>;</span>
		<span>var</span> speed <span>=</span> <span>(</span>time <span>/</span> <span>5000</span><span>)</span> <span>%</span> Math<span>.</span><span>PI</span> <span>*</span> <span>2</span><span>;</span>
		eye<span>[</span><span>0</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>cos</span><span>(</span>speed<span>)</span> <span>+</span> <span>0.1</span><span>;</span>
		eye<span>[</span><span>1</span><span>]</span> <span>=</span> radius <span>*</span> Math<span>.</span><span>sin</span><span>(</span>speed<span>)</span><span>;</span>

		Mat4<span>.</span><span>lookAt</span><span>(</span>viewMatrix<span>,</span> eye<span>,</span> target<span>,</span> up<span>)</span><span>;</span>

		<span>let</span> fov <span>=</span> <span>75</span> <span>*</span> Math<span>.</span><span>PI</span> <span>/</span> <span>180</span><span>;</span>
		Mat4<span>.</span><span>perspectiveNO</span><span>(</span>projectionMatrix<span>,</span> fov<span>,</span> aspect_ratio<span>,</span> <span>1</span><span>,</span> <span>Infinity</span><span>)</span><span>;</span>

		Mat4<span>.</span><span>multiply</span><span>(</span>projectionMatrix<span>,</span> projectionMatrix<span>,</span> viewMatrix<span>)</span><span>;</span>

		
		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>SRC_ALPHA</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width <span>/</span> resDiv<span>,</span> canvas<span>.</span>height <span>/</span> resDiv<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> circleDrawFramebuffer<span>)</span><span>;</span>
		gl<span>.</span><span>clear</span><span>(</span>gl<span>.</span><span>COLOR_BUFFER_BIT</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>circleShd<span>)</span><span>;</span>
		gl<span>.</span><span>uniformMatrix4fv</span><span>(</span>viewProjectionLocation<span>,</span> <span>false</span><span>,</span> projectionMatrix<span>)</span><span>;</span>

		
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		<span>if</span><span>(</span>showQuad<span>)</span><span>{</span>
			gl<span>.</span><span>useProgram</span><span>(</span>simpleColorShd<span>)</span><span>;</span>
			gl<span>.</span><span>uniformMatrix4fv</span><span>(</span>viewProjectionLocationSimple<span>,</span> <span>false</span><span>,</span> projectionMatrix<span>)</span><span>;</span>
			gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>
		<span>}</span>

		gl<span>.</span><span>viewport</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>

		gl<span>.</span><span>blendFunc</span><span>(</span>gl<span>.</span><span>ONE</span><span>,</span> gl<span>.</span><span>ONE_MINUS_SRC_ALPHA</span><span>)</span><span>;</span>
		gl<span>.</span><span>useProgram</span><span>(</span>blitShd<span>)</span><span>;</span>
		gl<span>.</span><span>bindFramebuffer</span><span>(</span>gl<span>.</span><span>FRAMEBUFFER</span><span>,</span> <span>null</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>uniform4f</span><span>(</span>transformLocation<span>,</span> <span>1.0</span><span>,</span> <span>1.0</span><span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>uniform2f</span><span>(</span>offsetLocationPost<span>,</span> <span>0.0</span><span>,</span> <span>0.0</span><span>)</span><span>;</span>
		gl<span>.</span><span>drawArrays</span><span>(</span>gl<span>.</span><span>TRIANGLE_FAN</span><span>,</span> <span>0</span><span>,</span> <span>4</span><span>)</span><span>;</span>

		
		redrawActive <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>let</span> isRendering <span>=</span> <span>false</span><span>;</span>
	<span>let</span> animationFrameId<span>;</span>

	<span>function</span> <span>onResize</span><span>(</span><span>)</span> <span>{</span>
		<span>const</span> dipRect <span>=</span> canvas<span>.</span><span>getBoundingClientRect</span><span>(</span><span>)</span><span>;</span>
		<span>const</span> width <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>right<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>left<span>)</span><span>;</span>
		<span>const</span> height <span>=</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>bottom<span>)</span> <span>-</span> Math<span>.</span><span>round</span><span>(</span>devicePixelRatio <span>*</span> dipRect<span>.</span>top<span>)</span><span>;</span>

		<span>if</span> <span>(</span>canvas<span>.</span>width <span>!==</span> width <span>||</span> canvas<span>.</span>height <span>!==</span> height<span>)</span> <span>{</span>
			canvas<span>.</span>width <span>=</span> width<span>;</span>
			canvas<span>.</span>height <span>=</span> height<span>;</span>

			<span>setupTextureBuffers</span><span>(</span><span>)</span><span>;</span>
			aspect_ratio <span>=</span> width <span>/</span> height<span>;</span>
			<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>startRendering</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	window<span>.</span><span>addEventListener</span><span>(</span><span>&#39;resize&#39;</span><span>,</span> onResize<span>,</span> <span>true</span><span>)</span><span>;</span>
	<span>onResize</span><span>(</span><span>)</span><span>;</span>

	<span>function</span> <span>renderLoop</span><span>(</span><span>time</span><span>)</span> <span>{</span>
		<span>if</span> <span>(</span>isRendering<span>)</span> <span>{</span>
			<span>redraw</span><span>(</span>time<span>)</span><span>;</span>
			animationFrameId <span>=</span> <span>requestAnimationFrame</span><span>(</span>renderLoop<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>function</span> <span>startRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>true</span><span>;</span>
		<span>renderLoop</span><span>(</span>last_time<span>)</span><span>;</span>
	<span>}</span>
	<span>function</span> <span>stopRendering</span><span>(</span><span>)</span> <span>{</span>
		
		isRendering <span>=</span> <span>false</span><span>;</span>
		<span>cancelAnimationFrame</span><span>(</span>animationFrameId<span>)</span><span>;</span>
		<span>while</span> <span>(</span>redrawActive<span>)</span> <span>{</span>
			
		<span>}</span>
		
		gl<span>.</span><span>finish</span><span>(</span><span>)</span><span>;</span>

		
		gl<span>.</span><span>deleteTexture</span><span>(</span>frameTexture<span>)</span><span>;</span>
		gl<span>.</span><span>deleteFramebuffer</span><span>(</span>circleDrawFramebuffer<span>)</span><span>;</span>
		buffersInitialized <span>=</span> <span>false</span><span>;</span>
	<span>}</span>

	<span>function</span> <span>handleIntersection</span><span>(</span><span>entries</span><span>)</span> <span>{</span>
		entries<span>.</span><span>forEach</span><span>(</span><span>entry</span> <span>=&gt;</span> <span>{</span>
			<span>if</span> <span>(</span>entry<span>.</span>isIntersecting<span>)</span> <span>{</span>
				<span>if</span> <span>(</span><span>!</span>isRendering<span>)</span> <span>startRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span> <span>else</span> <span>{</span>
				<span>stopRendering</span><span>(</span><span>)</span><span>;</span>
			<span>}</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>

	
	<span>let</span> observer <span>=</span> <span>new</span> <span>IntersectionObserver</span><span>(</span>handleIntersection<span>)</span><span>;</span>
	observer<span>.</span><span>observe</span><span>(</span>canvas<span>)</span><span>;</span>
<span>}</span></code></pre></details></blockquote><p>With the 3D camera and resulting perspective matrix multiplication, we use the reliable screen space derivatives again to get the pixel size. But in reality, <a href="https://web.archive.org/web/20150521050627/https://www.opengl.org/wiki/Compute_eye_space_from_window_space">we can still do without</a>! This would require us to multiply of the inverse perspective matrix with the fragment coordinates <em><strong>per pixel</strong></em>. Performance-painful, yet possible.</p><h3 id="unmentioned-challenges" tabindex="-1">Unmentioned challenges <a href="#unmentioned-challenges">#</a></h3><p>There is something I have not explained yet, a persistent misunderstanding I held until <a href="https://stannum.io/">Yakov Galka</a> explained <a href="https://stackoverflow.com/questions/73903568">the deetz to me on stackoverflow</a>. Depending on how we setup the blending math, to perform the smoothing we may remove pixel alpha on the inside of the shape, add it to the outside or center it.</p><p>Adding or subtracting would mess with the shape every so slightly, especially at small sizes or under strong perspective. So centering is the way to go. Unfortunately, centering the fade on the border can put the edge outside our quad and lead to hard edges or clipping.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/cut.png" alt="Clipping of the border"/><figcaption>Clipping of the border. (Overdone for emphasis)</figcaption></figure><p>In 3D this is especially painful, as there is no amount of safety margin that would solve this, with the camera at oblique angles. Nvidia introduced the vendor specific extension <a href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conservative_raster_dilate.txt"><code>NV_conservative_raster_dilate</code></a> to always give you an extra pixel at the border. Unfortunately it‚Äôs not available in WebGL and specific to NVIDIA hardware.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/missing_raster_by_yakov-galka.png" alt="Border pixels not rasterized due to fading overshooting the quad"/><figcaption>Border pixels not rasterized due to fading overshooting the quad</figcaption></figure><p>So we are forced to shrink the border in all cases. This leads to smooth edges even under strong perspective, but technically influences the shape. This is absolutely <em>not</em> visible in isolation, but may lead to mismatches or unexpected behavior, as even perspective has now an influence on the shape.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/inside_raster_by_yakov-galka.png" alt="Border pixels rasterized with shrunken border"/><figcaption>Border pixels rasterized with shrunken border</figcaption></figure><p>For the 2D case, we could implement a kind of <a href="https://registry.khronos.org/OpenGL/extensions/NV/NV_conservative_raster_dilate.txt"><code>NV_conservative_raster_dilate</code></a> ourselves, by growing the quad in the vertex shader by one pixel and shrink the signed distance field by one pixel in the fragment shader. And this <em>is</em> exactly what‚Äôs happening in the 2D demos on this page!</p><blockquote><p>This is really pedantic and just here for correctness. In most cases, you don&#39;t need to be so precise.</p><img src="https://blog.frost.kiwi/assets/kiwis/think.svg"/></blockquote><p>That is the reason the red box always lines up with the border, at all resolution switches and with all 2D demos on this page. Specifically in the vertex shader, the line responsible for this is:</p><pre><code>
vertex <span>*=</span> size <span>+</span> pixelSize<span>;</span></code></pre><blockquote><p>Not messing up gamma and multiplied vs premultiplied alpha are important for all forms of AA, but are very context dependant. This blog post is about AAA specifically, thus we ignore these.</p><img src="https://blog.frost.kiwi/assets/kiwis/teach.svg"/></blockquote><h2 id="what-are-the-big-boys-doing%3F" tabindex="-1">What are the big boys doing? <a href="#what-are-the-big-boys-doing%3F">#</a></h2><p>This rendering approach has found its way into many professional products. Let‚Äôs finish by looking at some of them.</p><h3 id="%E2%80%9Cshapes%E2%80%9D-for-unity" tabindex="-1"><a href="https://acegikmo.com/shapes">‚ÄúShapes‚Äù</a> for Unity <a href="#%E2%80%9Cshapes%E2%80%9D-for-unity">#</a></h3><p>Feature-wise the most complete implementation of this approach is in Unity extension <a href="https://acegikmo.com/shapes">Shapes</a> by <a href="https://twitter.com/FreyaHolmer/">Freya Holm√©r</a>. There the SDFs are either anti-aliased by MSAA or are blended like in this blog post, though it‚Äôs referred to as ‚Äú<a href="https://acegikmo.com/shapes/docs/#anti-aliasing">Fast Local Anti-Aliasing</a>‚Äù for the <code>fwidth()</code> case and ‚Äú<a href="https://acegikmo.com/shapes/docs/#anti-aliasing">Corrected Local Anti-Aliasing</a>‚Äù for the <code>length()</code> case.</p><figure><video controls="" height="540" poster="vid/shapes_thumb.jpg" width="960"><source src="vid/shapes.mp4" type="video/mp4"/></video><figcaption>Trailer for <a href="https://acegikmo.com/shapes">&#34;Shapes&#34;</a> by <a href="https://twitter.com/FreyaHolmer/">Freya Holm√©r</a></figcaption></figure><p>With motion-blur, <a href="https://acegikmo.com/shapes/docs/#shapes-feature-table">shape-respecting color gradients</a> and lines <a href="https://acegikmo.com/shapes/docs/#anti-aliasing">below 1px being opacity faded</a> to prevent further aliasing, this is signed-distance field rendering and AAA by extension, implemented to its logical conclusion.</p><h3 id="valve-software%E2%80%99s-implementation" tabindex="-1"><a href="https://www.valvesoftware.com/">Valve Software</a>‚Äôs implementation <a href="#valve-software%E2%80%99s-implementation">#</a></h3><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/tf2hud.png" alt="Hud elements in Team Fortress 2"/><figcaption>Hud elements in <a href="https://www.teamfortress.com/">Team Fortress 2</a></figcaption></figure><p>Valve introduced extensive use of signed distance field rendering to the <a href="https://en.wikipedia.org/wiki/Source_(game_engine)">Source engine</a> during the development of the <a href="https://en.wikipedia.org/wiki/The_Orange_Box">Orange Box</a>. Most prominently in <a href="https://www.teamfortress.com/">Team Fortress 2</a>, where it was used to create smooth yet sharp UI elements on the HUD. It even received its own <a href="https://wiki.teamfortress.com/wiki/Developer_commentary">Developer Commentary</a> entry.</p><blockquote><p><strong>Alden Kroll:</strong> Two-dimensional HUD elements present a particular art problem, because they have to look good and sharp no matter what resolution the user is running their game at. Given today‚Äôs availability of high resolution wide-screen displays, this can require a lot of texture memory and a lot of work anticipating different display resolutions. The problem for Team Fortress 2 was even more daunting because of our desire to include a lot of smooth curved elements in our HUD. We developed a new shader system for drawing ‚Äòline art‚Äô images. The system allows us to create images at a fixed resolution that produced smooth silhouettes even when scaled up to a very high resolution. This shader system also handles outlining and drop-shadows, and can be applied in the 3D space to world elements such as signs.</p></blockquote><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/valve.png" alt="64x64 Texture: Alpha blended, Alpha Tested and SDF rendering"/><figcaption>64x64 Texture: Alpha blended, Alpha Tested and SDF rendering</figcaption></figure><p>They also released <a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf">a paper</a> describing the specific implementation, including a showcase for use in the 3D game world, though I have never seen it used in the game world itself in Valve titles. Added as a mere footnote to the paper, was a way to improve rendering with sharp corners‚Ä¶</p><h3 id="the-future-of-all-things-font%3F" tabindex="-1">The future of all things font? <a href="#the-future-of-all-things-font%3F">#</a></h3><p>If you save a signed distance field into a texture and sample it with linear interpolation, you will get perfectly sharp characters at any size, but the limited resolution will result in clipped or rounded corners, depending on implementation math.</p><p>Picking up on that foot note and bringing the technique to its logical conclusion was the most thorough and well composed Master Thesis I ever read: ‚Äú<a href="https://github.com/Chlumsky/msdfgen/files/3050967/thesis.pdf">Shape Decomposition for Multi-channel Distance Fields</a>‚Äù by <a href="https://github.com/Chlumsky">Viktor Chlumsk√Ω</a>, which included code for the <a href="https://github.com/Chlumsky/msdfgen">font-file to SDF conversion</a> and a full <a href="https://github.com/Chlumsky/msdf-atlas-gen?tab=readme-ov-file">font atlas generator</a>.</p><p>Basically, use RGB and a median term to get perfectly sharp text at any size, including an Alpha channel with the classical SDF for effects like glows and drop shadows, all done on the GPU with no run-time baking or intense processing. If you dig around in video games, you will find SDF based font rendering from time to time!</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/msdf.png" alt="Multi-Channel SDF demo from msdf-atlas-gen"/><figcaption>Multi-Channel SDF demo from <a href="https://github.com/Chlumsky/msdf-atlas-gen?tab=readme-ov-file">msdf-atlas-gen</a></figcaption></figure><p>From experience I can tell you, that there are more implementation headaches. Chinese, Japanese, Korean characters require bigger textures to resolve their minute details. Bigger textures means you‚Äôll often minimize during rendering, but minimizing may introduce artifacts on its own‚Ä¶</p><p>But considering the current state of browser font baking + rendering and the <em>pure insanity</em> of edge-cases covered, including <a href="https://faultlore.com/blah/text-hates-you/">synthetic fallbacks for missing italic or bold variants</a> and baking 4 variants with 0.25px offsets to account for minute sampling issues, I think SDF text rendering has not been given enough serious consideration.</p><blockquote><p>&#34;<a href="https://faultlore.com/blah/text-hates-you/">Text rendering hates you</a>&#34; is a recommended read if you want to see how crushingly complex this topic gets.</p><img src="https://blog.frost.kiwi/assets/kiwis/tired.svg"/></blockquote><p>You may be wondering, if we can get the <a href="https://www.shadertoy.com/view/MlKcDD">analytical solution for a bezier curve</a>, why bake into textures instead? We may know the solution for <strong>one</strong> segment, but to get the full shape we need to sum up all the contributions from all segments. This works, but performance tanks hard, as we solve <em>every</em> bezier curve segment <strong>per pixel</strong>.</p><h2 id="clarity-should-not-be-a-luxury" tabindex="-1">Clarity should not be a luxury <a href="#clarity-should-not-be-a-luxury">#</a></h2><p>Modern video games often use TAA in combination with dynamic resolution scaling, a concoction guaranteed to result in blurriness. These AA algorithms come with post-process sharpening built-in to combat this, as is done in <a href="https://gpuopen.com/fidelityfx-cas/">FSR</a> or <a href="https://docs.unity3d.com/Packages/com.unity.postprocessing@3.4/manual/Anti-aliasing.html#temporal-anti-aliasing">TAA</a>. Fixing blurring by sharpening, I find this a bit of graphics programming sin.</p><figure><img src="https://blog.frost.kiwi/analytical-anti-aliasing/img/warframetaa.png" alt="TAA Sharpening in Warframe"/><figcaption>TAA Sharpening in <a href="https://www.warframe.com/">Warframe</a></figcaption></figure><p>Whole communities rally around fixing this, like the reddit communities ‚Äú<a href="https://www.reddit.com/r/MotionClarity/">r/MotionClarity</a>‚Äù or the lovingly titled ‚Äú<a href="https://www.reddit.com/r/FuckTAA">r/FuckTAA</a>‚Äù, all with the understanding, that Anti-Aliasing should not come at the cost of clarity. FXAA creator Timothy Lottes mentioned, that this is <a href="https://x.com/NOTimothyLottes/status/1756733156877578611">solvable to some degree with adjustments to filtering</a>, though even the most modern titles suffer from this.</p><p>What we have not talked about are the newer machine learning approaches as done for instance with NVIDIA‚Äôs <a href="https://en.wikipedia.org/wiki/Deep_learning_anti-aliasing"><strong>DLAA</strong></a>, as that is really outside the scope of this post. Suffice to say Timothy Lottes is <a href="https://x.com/NOTimothyLottes/status/1756746848402800785">not a fan</a>. As for AAA, it‚Äôs lovely being able to draw smooth yet sharp, motion-stable shapes of any size at native resolutions.</p><blockquote><p>Please feel free to use these techniques in your projects.</p><img src="https://blog.frost.kiwi/assets/kiwis/love.svg"/></blockquote></div></div>
  </body>
</html>
