<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://substrate.stackexchange.com/questions/982/why-does-the-all-0-public-key-have-a-known-private-key-in-sr25519-and-ed25519">Original</a>
    <h1>Why does the all 0 public key have a known private key in SR25519 and ED25519?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
<p>Yes, it&#39;s a consequence of the Edwards curve models used, but secp256k1 is a short Weierstrass curve.</p>
<p>Ed25519 has the identity <code>(0,1)</code> in Affine coordinates, meaning <code>(0,1) + (0,1) = (0,1)</code> in Ed25519.  It little endian encodes as <code>[1u8, 0u8, ..., 0u8]</code>, not all zeros.</p>
<p>In fact <code>[0u8; 32]</code> decodes as <code>(1,0)</code> because -1 is a square in F_q with q = 2^255-19, since q is divisible by 4.  It follows <code>(1,0)</code> lies on the curve.   It&#39;s not in the distinguished prime order subgroup, but <code>(1,0) + (1,0) = (0,1)</code> in Ed25519, so <code>(1,0)</code> still acts like the identity in sane Ed25519 protocols.  See page 6 of <a href="https://ed25519.cr.yp.to/ed25519-20110926.pdf" rel="noreferrer">Ed25519 paper</a>.</p>
<p>Ristretto decompresses <code>[0u8; 32]</code> as the <a href="https://ristretto.group/test_vectors/ristretto255.html?highlight=identity#test-vectors-for--ristretto255" rel="noreferrer">identity</a>.  It&#39;s arguably somewhat by chance, except Mike Hamberg avoided crazy constants in the Jacobi quartic encoding, so zero stuck around from Ed25519.</p>
<p>If you want unspendable funds then choose a point via <a href="https://doc.dalek.rs/curve25519_dalek/ristretto/struct.RistrettoPoint.html#method.hash_from_bytes" rel="noreferrer">hash-to-curve</a>, which also lets you encode an undependable reason, and control who knows they&#39;re unspendable.</p>
<pre><code>let mut hash = sha2::Shake256::default();
hash.input(input);
let unspendable_address = RistrettoPoint::from_hash(hash).compress()
</code></pre>
<p>Appears dalek never released a hash-to-curve for ed25519, but they&#39;ve one in master that&#39;s usable for this: <a href="https://github.com/dalek-cryptography/curve25519-dalek/blob/main/src/edwards.rs#L532" rel="noreferrer">https://github.com/dalek-cryptography/curve25519-dalek/blob/main/src/edwards.rs#L532</a></p>
    </div></div>
  </body>
</html>
