<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kristoff.it/blog/zig-multi-sequence-for-loops/">Original</a>
    <h1>Zig&#39;s Curious Multi-Sequence for Loops</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body"><p>Zig has just gained new for loop syntax that allows
you to iterate on multiple slices / arrays at the same time.
In this blog post I’m going to explain in detail the
rationale behind this choice, while also introducing
you to a couple useful patterns that the syntax is
meant to encourage.</p><p>If you want to try it out, you will need an unstable
build of Zig, which you can get from
<a href="https://ziglang.org/download/">the downloads page</a>.</p><h2 id="basic-syntax">Basic syntax</h2><p>The most basic for loop syntax in Zig is still the
same as before.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> elems <span>=</span> [<span>4</span>]<span>usize</span>{ <span>10</span>, <span>20</span>, <span>30</span>, <span>40</span> };
</span></span><span><span>
</span></span><span><span><span>for</span> (elems) <span>|</span>x<span>|</span> {
</span></span><span><span>   std.debug.print(<span>&#34;{} &#34;</span>, .{x});
</span></span><span><span>}
</span></span></code></pre></div><p>This prints:</p><pre tabindex="0"><code>10 20 30 40 
</code></pre><p>If you’re new to Zig, you might be surprised
by the <code>|x|</code> syntax. That’s called a capture
in Zig and in the case of <code>for</code> loops is how
you can, well, <em>capture</em> the iteration value
and give it a name.</p><h3 id="ranges">Ranges</h3><p>The new syntax also supports ranges, which are
a new construct in Zig.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>for</span> (<span>0</span>..<span>4</span>) <span>|</span>n<span>|</span> {
</span></span><span><span>   std.debug.print(<span>&#34;{} &#34;</span>, .{n});
</span></span><span><span>}
</span></span></code></pre></div><p>This prints:</p><pre tabindex="0"><code>0 1 2 3 
</code></pre><p>Ranges can also start from something other than zero.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>for</span> (<span>1</span>..<span>5</span>) <span>|</span>n<span>|</span> {
</span></span><span><span>   std.debug.print(<span>&#34;{} &#34;</span>, .{n});
</span></span><span><span>}
</span></span></code></pre></div><p>This prints:</p><pre tabindex="0"><code>1 2 3 4 
</code></pre><p>Ranges can only exist as an argument to a <code>for</code> loop. This means that you can’t store them in variables, but you can use variables to specify their bounds.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> a<span>:</span> <span>usize</span> <span>=</span> <span>10</span>;
</span></span><span><span><span>var</span> b<span>:</span> <span>usize</span> <span>=</span> <span>15</span>;
</span></span><span><span>
</span></span><span><span><span>for</span> (a..b) <span>|</span>n<span>|</span> {
</span></span><span><span>   std.debug.print(<span>&#34;{} &#34;</span>, .{n});
</span></span><span><span>}
</span></span></code></pre></div><p>This prints:</p><pre tabindex="0"><code>10 11 12 13 14
</code></pre><h2 id="multi-sequence-syntax">Multi-sequence syntax</h2><p>The new multi-sequence syntax allows you to loop over
two or more arrays or slices at the same time:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> elems <span>=</span> [_][]<span>const</span> <span>u8</span> { <span>&#34;water&#34;</span>, <span>&#34;earth&#34;</span>, <span>&#34;fire&#34;</span>, <span>&#34;air&#34;</span> };
</span></span><span><span><span>var</span> nats <span>=</span> [_][]<span>const</span> <span>u8</span> { <span>&#34;tribes&#34;</span>, <span>&#34;kingdom&#34;</span>, <span>&#34;nation&#34;</span>, <span>&#34;nomads&#34;</span> };
</span></span><span><span>
</span></span><span><span><span>for</span> (elems, nats) <span>|</span>e, n<span>|</span> {
</span></span><span><span>   std.debug.print(<span>&#34;{s} {s}</span><span>\n</span><span>&#34;</span>, .{e, n});
</span></span><span><span>}
</span></span></code></pre></div><p>This prints:</p><pre tabindex="0"><code>water tribes
earth kingdom
fire nation
air nomads
</code></pre><p>There’s only one simple rule when it comes to the
length of the sequences: <strong>all lengths must match</strong>.
Passing arrays of different length is safety-checked
UB (i.e. you will get a panic in safe release modes).</p><h2 id="ranges-as-indexes">Ranges as indexes</h2><p>To iterate over a sequence and also keep track of the
element’s index, you can add a range to the list of
sequences you want to iterate. <strong>Since all sequences
must have the same length, you can omit the upper end
of the range and let Zig automatically infer it from
the other sequences</strong>.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> elems <span>=</span> [_][]<span>const</span> <span>u8</span> { <span>&#34;water&#34;</span>, <span>&#34;earth&#34;</span>, <span>&#34;fire&#34;</span>, <span>&#34;air&#34;</span> };
</span></span><span><span><span>var</span> nats <span>=</span> [_][]<span>const</span> <span>u8</span> { <span>&#34;tribes&#34;</span>, <span>&#34;kingdom&#34;</span>, <span>&#34;nation&#34;</span>, <span>&#34;nomads&#34;</span> };
</span></span><span><span>
</span></span><span><span><span>for</span> (elems, nats, <span>0</span>..) <span>|</span>e, n, idx<span>|</span> {
</span></span><span><span>   std.debug.print(<span>&#34;{} - {s} {s}</span><span>\n</span><span>&#34;</span>, .{idx, e, n});
</span></span><span><span>}
</span></span></code></pre></div><p>This prints:</p><pre tabindex="0"><code>0 - water tribes
1 - earth kingdom
2 - fire nation
3 - air nomads
</code></pre><h2 id="other-properties-of-for-loops">Other properties of <code>for</code> loops</h2><p>Up until now we saw the new changes to <code>for</code> loops,
but if you’re new to Zig you might not know all the
other things they support, so I’ll quickly recap
them in this section.</p><h3 id="pointer-to-the-element">Pointer to the element</h3><p>Value captures in Zig should always be understood as
immutable copies. To ask for a pointer you can add
a <code>*</code> before the capture name.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> good_digits<span>:</span> [<span>3</span>]<span>usize</span> <span>=</span> .{<span>4</span>, <span>2</span>, <span>0</span>};
</span></span><span><span>
</span></span><span><span><span>for</span> (<span>&amp;</span>good_digits) <span>|*</span>d<span>|</span> {
</span></span><span><span>   d.<span>*</span> <span>=</span> <span>6</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// for (good_digits) |d| {
</span></span></span><span><span><span>//    d = 6;
</span></span></span><span><span><span>// }
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// error: cannot assign to constant
</span></span></span><span><span><span>//     	d = 6;
</span></span></span><span><span><span>//     	^
</span></span></span></code></pre></div><h3 id="labels-break-and-continue">Labels, <code>break</code> and <code>continue</code></h3><p>You can give labels to loops, which helps breaking
and continuing iteration at the right level.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> vowels <span>=</span> <span>&#34;aeiou&#34;</span>;
</span></span><span><span><span>const</span> text <span>=</span> <span>&#34;lorem ipsum&#34;</span>;
</span></span><span><span><span>var</span> missing <span>=</span> <span>false</span>;
</span></span><span><span>
</span></span><span><span>outer<span>:</span> <span>for</span> (vowels) <span>|</span>v<span>|</span> {
</span></span><span><span>   <span>for</span> (text) <span>|</span>x<span>|</span> {
</span></span><span><span>      <span>if</span> (x <span>==</span> v) <span>continue</span> <span>:</span>outer;
</span></span><span><span>   }
</span></span><span><span>   missing <span>=</span> <span>true</span>;
</span></span><span><span>   <span>break</span> <span>:</span>outer;
</span></span><span><span>}
</span></span></code></pre></div><h3 id="else-for-for-loops"><code>else</code> for <code>for</code> loops</h3><p>In Zig you can give an <code>else</code> branch to a <code>for</code> loop.
The <code>else</code> branch triggers when the loop ends naturally,
as opposed to breaking from it.</p><p>This models beautifully searching for an element in a
sequence: if the element is found, you will <code>break</code>
from the loop, while if it’s not found then the loop
will end naturally, at which point the <code>else</code> branch
will allow you to implement the “not found” case.</p><p><code>for</code> loops can also be used as expressions, which
works particularly well in this case.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> text <span>=</span> <span>&#34;abcdef&#34;</span>;
</span></span><span><span><span>const</span> needle <span>=</span> <span>&#39;e&#39;</span>;
</span></span><span><span>
</span></span><span><span><span>const</span> match<span>:</span> <span>?</span><span>usize</span> <span>=</span> <span>for</span> (text, <span>0</span>..) <span>|</span>x, idx<span>|</span> {
</span></span><span><span>   <span>if</span> (x <span>==</span> needle) <span>break</span> idx;
</span></span><span><span>} <span>else</span> <span>null</span>;
</span></span></code></pre></div><h3 id="inlined-for-loops">Inlined <code>for</code> loops</h3><p>It’s possible to operate on heterogeneous sequences
of values with <code>for</code> loops when doing comptime
metaprogramming. You can learn more in
<a href="https://kristoff.it/blog/what-is-zig-comptime/">this old blog post</a>
of mine.</p><h2 id="multi-sequence-for-loops-and-data-oriented-design-dod">Multi-sequence <code>for</code> loops and data oriented design (DOD)</h2><p>Say that you have a game where each monster has an
element type, a counter for hit points, and a unique
“dna” string used to procedurally generate stats for
each monster’s offspring (and to give an early taste
of how it feels to play with slot machines to young
kids).</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> Monster <span>=</span> <span>struct</span> {
</span></span><span><span>   elem_type<span>:</span> <span>enum</span>{ fire, water, air, earth },
</span></span><span><span>   hp<span>:</span> <span>usize</span>,
</span></span><span><span>   dna<span>:</span> [<span>33</span>]<span>u8</span>, <span>// gambling department demands 
</span></span></span><span><span><span></span>                <span>// we use exactly 33 bytes
</span></span></span><span><span><span></span>};
</span></span></code></pre></div><p>First of all, you would probably want the in-memory
representation of this struct to place <code>hp</code> at the
top of the struct in order to avoid the need for
padding inside the struct to maintain its natural
alignment (because its type is <code>usize</code>, which has
8 byte alignment on common 64bit machines).</p><p>Luckily, this is done automatically by Zig (you can
use a <code>extern struct</code> if you want field ordering to
work like in C), but even then, the struct has
alignment 8 and size 42, which means that it needs
6 bytes of padding at the end to keep the alignment
consistent in an array (ie <code>@sizeOf([2]Monster) == 96</code>),
so in the end some padding is inevitable given the size
of our fields. 6 bytes might not seem much, but it does
mean that each monster instance wastes roughly 15% of
its size just for padding.</p><p>One technique that lets us prevent that waste is to avoid
representing our monsters as an array of structs (AoS), and
instead “deconstruct” them into multiple arrays, one per
field (also known as struct-of-arrays, SoA):</p><div><pre tabindex="0"><code data-lang="zig"><span><span>monster_hps<span>:</span> []<span>usize</span>,
</span></span><span><span>monster_dnas<span>:</span> [][<span>33</span>]<span>u8</span>,
</span></span><span><span>monster_elem_types<span>:</span> []<span>enum</span>{ fire, water, air, earth },
</span></span></code></pre></div><p>This memory layout wastes no bytes and also lets us
operate more efficiently on our data.</p><p>Let’s say that <code>fire</code> monsters gain one hit point every
tick of our game. This means that every tick we want to
look at each monster’s <code>elem_type</code> and based on that we
increment its <code>hp</code> by one.</p><p>If we were to do this with the original array-of-structs
layout, for each monster we would have to load from
memory 39 bytes of data that we don’t care about (33
from the <code>dna</code> field, plus 6 of padding) over the 9
bytes that we do need. That’s a waste rate of more than 400%!</p><p>With the struct-of-arrays layout we only load from memory
data that we do care about, which can have a tremendous
effect on performance.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>for</span> (monster_elem_types, monster_hps) <span>|</span>et, <span>*</span>hp<span>|</span> {
</span></span><span><span>   <span>if</span> (et <span>==</span> .fire) hp.<span>*</span> <span>+|=</span> <span>1</span>; <span>// saturating addition
</span></span></span><span><span><span></span>} 
</span></span></code></pre></div><p>The Zig standard library has <code>MultiArrayList</code>, a data
structure that helps make DOD style programming even
more ergonomic. <a href="https://zig.news/kristoff/struct-of-arrays-soa-in-zig-easy-in-userland-40m0">Here you can read more about it</a>.</p><h2 id="hoisting-safety-checks">Hoisting safety checks</h2><p>In low-level programming languages, accessing an array
item corresponds to adding an offset to a pointer value
and then dereferencing it. This operation is very fast
but, if the logic is wrong, one could end up reading
past the end of an array and the program wouldn’t even
notice.</p><p>In Zig out-of-bounds array accesses are safety-checked
in safe build modes which means that the compiler adds
a hidden assertion whenever an array access is about
to happen.</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> idx<span>:</span> <span>usize</span> <span>=</span> <span>5</span>;
</span></span><span><span>assert(idx <span>&lt;</span> my_slice.len); <span>// secretly added by the compiler
</span></span></span><span><span><span></span>_ <span>=</span> my_slice[idx];
</span></span></code></pre></div><p>If we were to implement the previous game feature
(fire monsters getting 1 hp every tick) without
multi-sequence <code>for</code> loops, we would have to do
something like this:</p><div><pre tabindex="0"><code data-lang="zig"><span><span><span>var</span> idx<span>:</span> <span>usize</span> <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span><span>while</span> (idx <span>&lt;</span> monster_count) <span>:</span> (idx <span>+=</span> <span>1</span>) {
</span></span><span><span>   <span>const</span> et <span>=</span> monster_elem_types[idx]; <span>// potential oob
</span></span></span><span><span><span></span>   <span>const</span> hp <span>=</span> <span>&amp;</span>monster_hps[idx]; <span>// potential oob
</span></span></span><span><span><span></span>
</span></span><span><span>   <span>if</span> (et <span>==</span> .fire) hp.<span>*</span> <span>+|=</span> <span>1</span>;
</span></span><span><span>} 
</span></span></code></pre></div><p>Unfortunately, the Zig compiler would have to insert
two hidden assertions with this version of the code:
one before the assignment to <code>et</code>, and one before
the assignment to <code>hp</code>.</p><p>In the multi-sequence <code>for</code> loop version it’s only
necessary to test once at the beginning of the loop
that the two arrays have equal size, instead of
having 2 assertions run every loop iteration. The
multi-sequence <code>for</code> loop syntax helps convey
intention more clearly to the compiler, which in turn
lets it generate more efficient code.</p><p>Of course, with sophisticated-enough static analysis
the compiler could prove that <code>monster_count</code> is
always equivalent to <code>monster_elem_types.len</code> and
<code>monster_hps.len</code>, and thus it could elide the
assertions, but static analysis slows compilation
times and tends to be a fragile thing, like
<a href="https://leveluppp.ghost.io/loop-optimizations-in-various-compilers/">this amazing blog post about loop optimizations in C#</a> shows.</p><p><strong>Multi-sequence <code>for</code> loop syntax doesn’t slow down
compilation times and guarantees that you get good
performance also in debug builds, where advanced
optimizations are disabled and compilation times
matter the most.</strong></p><h2 id="conclusion">Conclusion</h2><p>Zig is already a compelling programming language and
toolchain, but there’s more design space to explore
ahead of us before we can tag v1.0.</p><p>We <a href="https://kristoff.it/blog/zig-self-hosted-now-what/">recently self-hosted the compiler</a> and <a href="https://ziglang.org/news/goodbye-cpp/">optimized our development process</a>
in order to make it as smooth as possible to explore
new design ideas like multi-sequence <code>for</code> loops.</p><p>Zig describes itself as a programming language for
maintaining <strong>robust</strong>, <strong>optimal</strong> and <strong>reusable</strong>
code, and multi-sequence for loops are a shining
example of how the language tries to strike a
compelling balance between clarity, performance and safety.</p><p>Comptime metaprogramming allows us to have
<code>std.MultiArrayList</code>, <a href="https://zig.news/kristoff/struct-of-arrays-soa-in-zig-easy-in-userland-40m0">a userland implementation of AoS/SoA transformation</a>,
which makes it easier to do DOD-style programming, while
multi-sequence <code>for</code> loops ensure that we get all the
safety of out-of-bounds checks without impacting runtime
performance nor compromising on compilation times.</p><p>If you like where we’re going, please consider
<a href="https://ziglang.org/zsf/">sponsoring the Zig Software Foundation</a>.</p></div></div>
  </body>
</html>
