<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC08/">Original</a>
    <h1>RC08: Lispful for Recursion</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-05-25T00:00:00-07:00">May 25, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>Something that intrigues me about Lisp so far is the way in which it lends itself, almost automatically and as a first principle, to recursion. In my experience working through various introductory programming books, recursion is a topic usually saved for later – and for good reason, I think (or thought), since it is a vertigo-inducing headache-maker of a topic.</p>

<p>But for some reason with Lisp it feels front-and-center. Before loops, even. Maybe that’s because the very applicative-order evaluation at its core is recursive, which is to say that evaluating (read: understanding) a complex expression as a human requires drilling down first to the deepest elements and creating a mental stack along the way.</p>

<p>For instance, the equation</p>

<math>
  <mfrac>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mn>2</mn>
        <mo>+</mo>
        <mn>10</mn>
      </mrow>
      <mo>)</mo>
      <mo>(</mo>
      <mrow>
        <mn>3</mn>
        <mo>-</mo>
        <mn>21</mn>
      </mrow>
      <mo>)</mo>
    </mrow>
    <mrow>
      <mrow>
        <mfrac>
          <mn>3</mn>
          <mn>7</mn>
        </mfrac>
      </mrow>
      <mo>(</mo>
      <mrow>
        <mn>3</mn>
        <mo>+</mo>
        <mn>11</mn>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mfrac>
</math>

<p>in Lisp would look like:</p>

<div><div><pre><code><span>(</span><span>/</span> <span>(</span><span>*</span> <span>(</span><span>+</span> <span>2</span> <span>10</span><span>)</span> <span>(</span><span>-</span> <span>3</span> <span>21</span><span>))</span> <span>(</span><span>*</span> <span>(</span><span>/</span> <span>3</span> <span>7</span><span>)</span> <span>(</span><span>+</span> <span>3</span> <span>7</span><span>)))</span>
</code></pre></div></div>

<p>so automatically we find we must recursively drill down this hierarchy of expressions to the innermost, atomic parts – things like <code>(+ 3 11)</code> or <code>(/ 3 7)</code> which are the bedrock of this particular expression – and move back outward.</p>

<p>It’s not that far a leap from here to a recursive procedure, such as this computation of a factorial:</p>

<div><div><pre><code><span>(</span><span>define</span> <span>(</span><span>factorial</span> <span>x</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>=</span> <span>x</span> <span>1</span><span>)</span>
    <span>1</span>
    <span>(</span><span>*</span> <span>x</span> <span>(</span><span>factorial</span> <span>(</span><span>-</span> <span>x</span> <span>1</span><span>)))))</span>
</code></pre></div></div>

<p>Probably Lisp’s affinity with recursion has something to do with the fact that, as its name implies (LISt Processing), its very structure is defined by lists of lists of lists, which is recursive by nature. In a way that is not quite so palpable in other languages, I find while working with a Lisp dialect that I am viscerally aware of the lamination and the nesting, and that in turn quietly opens the door to recusive thinking.</p>

<p>Anyway, here’s an algo I wrote today that uses Newton’s method to approximate cube roots, which holds that, if <code>y</code> is an approximate cube root of <code>x</code>, an improved approximation can be obtained by the following:</p>

<math>
  <mfrac>
    <mrow>
      <mfrac>
        <mrow>
          <mi>x</mi>
        </mrow>
        <mrow>
          <msup>
            <mi>y</mi>
            <mn>2</mn>
          </msup>
        </mrow>
      </mfrac>
      <mo>+</mo>
      <mn>2</mn>
      <mi>y</mi>
    </mrow>
    <mrow>
      <mn>3</mn>
    </mrow>
  </mfrac>
</math>

<div><div><pre><code><span>(</span><span>define</span> <span>(</span><span>cuberoot</span> <span>target</span><span>)</span>
  <span>(</span><span>cuberoot-itr</span> <span>1.0</span> <span>target</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>cuberoot-itr</span> <span>guess</span> <span>target</span><span>)</span> <span>; the recursive piece</span>
  <span>(</span><span>if</span> <span>(</span><span>good-enough?</span> <span>guess</span> <span>target</span><span>)</span>
    <span>guess</span>
    <span>(</span><span>cuberoot-itr</span> <span>(</span><span>improve</span> <span>guess</span> <span>target</span><span>)</span> <span>target</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>good-enough?</span> <span>guess</span> <span>target</span><span>)</span>
  <span>(</span><span>&lt;</span> <span>(</span><span>abs</span> <span>(</span><span>-</span> <span>(</span><span>cube</span> <span>guess</span><span>)</span> <span>target</span><span>))</span> <span>.</span><span>01</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>cube</span> <span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>x</span> <span>x</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>improve</span> <span>guess</span> <span>target</span><span>)</span>
  <span>(</span><span>/</span> <span>(</span><span>+</span> <span>(</span><span>/</span> <span>target</span> <span>(</span><span>square</span> <span>guess</span><span>))</span> <span>(</span><span>*</span> <span>2</span> <span>guess</span><span>))</span> <span>3</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>square</span> <span>x</span><span>)</span> <span>(</span><span>*</span> <span>x</span> <span>x</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>abs</span> <span>x</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>&lt;</span> <span>x</span> <span>0</span><span>)</span>
    <span>(</span><span>-</span> <span>x</span><span>)</span>
    <span>x</span><span>))</span>

</code></pre></div></div>


          

        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
