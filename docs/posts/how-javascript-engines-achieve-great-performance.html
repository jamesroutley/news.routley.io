<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogg.bekk.no/how-javascript-engines-achieve-great-performance-fb0b36601557?gi=10a6fd7465f9">Original</a>
    
    <div id="readability-page-1" class="page"><div><div><p id="4263">JavaScript is an impressive technology. Not because it’s particularly well-designed (it isn’t). Not because almost every single consumer device with internet access in the world has executed a JavaScript program. Instead, JavaScript is impressive because almost every single feature of the language makes it a nightmare to optimize and yet, it is fast.</p><p id="c26d">Think about it. There is no type information. Every single object can gain and lose properties over the lifetime of the program. There are six(!) different kinds of falsy values, and every number is a 64-bit float. As if that wasn’t enough, JavaScript is expected to execute quickly, so you can’t spend a lot of time analyzing and optimizing it either.</p><p id="ad0e">And yet, JavaScript is fast.</p><p id="8563">How can this be?</p><p id="ac83">In this article, we’re going to look closer at a few techniques that different JavaScript engines use to achieve good runtime performance. Keep in mind that I’m purposefully leaving a few details out, and simplifying things. It’s not a goal of this article that you learn how things work <em>exactly</em>, but that you understand enough to comprehend the theory behind the experiments we’ll perform later in this series.</p><h2 id="4caa">The execution model</h2><p id="452e">When your browser downloads JavaScript, its top priority is to get it running as quickly as possible. It does this by translating the code to bytecode, virtual machine instructions, which is then handed over to an interpreter, or virtual machine, that understands how to execute them.</p><p id="7b93">You might question why the browser would convert JavaScript to <em>virtual</em> machine instructions instead of <em>actual</em> machine instructions. It’s a good question. In fact, converting straight to machine instructions is what V8 (Chrome’s JavaScript engine) used to do until recently.</p><p id="e61d">A virtual machine for a specific programming language is usually an easier compilation target because it has a closer relation to the source language. An actual machine has a much more generic instruction set, and so it requires more work to translate the programming language to work well with those instructions. This difficulty means compilation takes longer, which again means it takes longer for the JavaScript to start executing.</p><p id="5ebb">As an example, a virtual machine that understands JavaScript is also likely to understand JavaScript objects. Because of this, the virtual instructions required to execute a statement like <code>object.x</code> might be one or two instructions. An actual machine, with no understanding of how JavaScript objects work, will need a lot more instructions to figure out where <code>.x</code> resides in memory and how to get it.</p><p id="f886">The problem with a virtual machine is that it is, well, virtual. It doesn’t exist. The instructions cannot be executed directly, but must be interpreted at runtime. Interpreting code will always be slower than executing code directly.</p><p id="c944">There’s a tradeoff here. Faster compilation time versus faster runtime. In many cases, faster compilation is a good tradeoff to make. The user is unlikely to care whether a single button click takes 20 or 40 milliseconds to execute, especially if the button is only pressed once. Compiling the JavaScript quickly, even if the resulting code is slower to execute, will let the user see and interact with the page faster.</p><p id="4741">There are situations that are computationally expensive. Stuff like games, syntax highlighting or calculating the fizzbuzz string of a thousand numbers. In these cases, the combined time of compiling and executing machine instructions is likely to reduce the total execution time. So how does JavaScript handle these kinds of situations?</p><h2 id="f991">Hot code</h2><p id="092d">Whenever the JavaScript engine detects that a function is hot (that is, executed many times) it hands that function over to an optimizing compiler. This compiler translates the virtual machine instructions into actual machine instructions. What’s more, since the function has already been run several times, the optimizing compiler can make several assumptions based on previous runs. In other words, it can perform speculative optimizations to make even faster code.</p><p id="2718">What happens if, later on, these speculations turn out to be wrong? The JavaScript engine can simply delete the optimized, but wrong, function, and revert to using the unoptimized version. Once the function has been run several more times, it can attempt to pass it to the optimizing compiler again, this time with even more information that it can use for speculative optimizations.</p><p id="cd76">Now that we know that frequently run functions use information from previous executions during optimization, the next thing to explore is what kind of information this is.</p><h2 id="10ba">A problem of translation</h2><p id="c472">Almost everything in JavaScript is an object. Unfortunately, JavaScript objects are tricky things to teach a machine to deal with. Let’s look at the following code:</p><pre><span id="2f77">function addFive(obj) {</span></pre><p id="a846">A function is pretty straightforward to translate to machine instructions, as is returning from a function. But a machine doesn’t know what <code>objects</code> are, so how would you translate accessing the <code>method</code> property of <code>obj</code>?</p><p id="43ec">It would help to know what <code>obj</code> looks like, but in JavaScript we can never really be certain. Any object can have a <code>method</code> property added to, or removed from, it. Even when it does exist, we cannot actually be certain if it is a function, much less what calling it returns.</p><p id="b85c">Let’s attempt to translate the above code to a subset of JavaScript that doesn’t have objects, to get an idea of what translating to machine instructions might be like.</p><p id="72a3">First, we need a way to represent objects. We also need a way to retrieve values from one. Arrays are trivial to support in machine code, so we might go with a representation like this:</p><pre><span id="4e45">// An object like { method: function() {} }</span></pre><p id="bc9a">With this, we can attempt to make a naive implementation of <code>addFive</code> :</p><pre><span id="593e">function addFive(obj) {</span><span id="8e3b">  var callResult = property(/* this */ obj);</span></pre><p id="68f4">Of course, this doesn’t work in the case where <code>obj.method()</code> returns a something other than a number, so we need to tweak the implementation a little:</p><pre><span id="857d">function addFive(obj) {</span><span id="19d7">  var callResult = property(/* this */ obj);</span></pre><p id="2aee">This would work, but I hope it’s apparent that this code could skip a few steps (and thus be faster) if we could somehow know ahead of time what the structure of <code>obj</code> is, and what the type of <code>method</code> is.</p><h2 id="c1ec">Hidden classes</h2><p id="1d7e">All the major JavaScript engines keep track of an object’s shape in some way. In Chrome, this concept is known as hidden classes. It’s what we will call it in this article as well.</p><p id="4cbe">Let’s start by looking at the following snippet of code:</p><pre><span id="94dc">var obj = {}; // empty object</span></pre><p id="c958">If we were to translate this to machine instructions, how would we keep track of the object’s shape as new properties are added and removed? If we use the previous example’s idea of representing objects as arrays, it might look something like this:</p><pre><span id="d815">var emptyObj__Class = [ </span></pre><p id="f183">If we were to generate virtual machine instructions like this, we now would have a way to track what an object looks like at any given time. However, this on its own doesn’t really help us. We need to store this information somewhere where it would be valuable.</p><h2 id="c7c4">Inline caches</h2><p id="c41f">Whenever JavaScript code performs property access on an object, the JavaScript engine stores that object’s hidden class, as well as the result of the lookup (the mapping of property name to index) in a cache. These caches are known as inline caches, and they serve two important purposes:</p><ul><li id="495e">When executing bytecode, they speed up property access <em>if</em> the object involved has a hidden class that is in the cache.</li><li id="a0f7">During optimization, they contain information about what type of objects that have been involved when accessing an object property, which helps the optimizing compiler generate code specially suited for those types.</li></ul><p id="981f">Inline caches have a limit on how many hidden classes they store information on. This preserves memory, but also makes sure that performing lookups in the cache is fast. If retrieving an index from the inline cache takes longer than retrieving the index from the hidden class, the cache serves no purpose.</p><p id="fe3b">From what I can tell, inline caches will keep track of 4 hidden classes at most, at least in Chrome. After this, the inline cache will be disabled and the information will instead be stored in a global cache. The global cache is also limited in size, and once it has reached its limit, newer entries will overwrite older ones.</p><p id="c1b2">To best utilize inline caches, and aid the optimizing compiler, one should try to write functions that only perform property access on objects of a single type. More than that and the performance of the generated code will be sub-optimal.</p><h2 id="ef0c">Inlining</h2><p id="98af">A separate, but significant, kind of optimization is inlining. In short, this optimization replaces a function call with the implementation of the called function. An example:</p><pre><span id="61ba">function map(fn, list) {</span></pre><p id="9d37">After inlining, the code might end up looking something like this:</p><pre><span id="1c42">function incrementNumbers(list) {</span><span id="a51a">    return newList;</span></pre><p id="c733">One benefit of this is that a function call has been removed. An even bigger benefit is that the JavaScript engine now has even more insight into what the function actually does. Based on this new version, the JavaScript engine might decide to perform inlining again:</p><pre><span id="9882">function incrementNumbers(list) {</span></pre><p id="0376">Another function call has been removed. What’s more, the optimizer might now speculate that <code>incrementNumbers</code> is only ever called with a list of numbers as an argument. It might also decide to inline the <code>incrementNumbers([1, 2, 3])</code> call itself, and discover that <code>list.length</code> is <code>3</code>, which again might lead to:</p><pre><span id="8c3a">var list = [1, 2, 3];</span></pre><p id="268b">In short, inlining enables optimizations that would not have been possible to perform across function boundaries.</p><p id="bd3b">There are limits to what can be inlined, however. Inlining can lead to larger functions due to code duplication, which requires additional memory. The JavaScript engine has a budget on how big a function can get before it skips inlining altogether.</p><p id="a7db">Some function calls are also difficult to inline. Particularly when a function is passed in as an argument.</p><p id="96b7">In addition, functions passed as arguments can be difficult to inline unless it’s always the same function. While that might strike you as a strange thing to do, it might end up being the case because of inlining.</p><h2 id="b701">Conclusion</h2><p id="8cf2">JavaScript engines have many tricks to improve runtime performance, many more than what has been covered here. However, the optimizations described in this article apply to most browsers, and are easy to verify if they’re being applied. Because of this, we’re mainly going to be focusing on these optimizations when we attempt to improve Elm’s runtime performance.</p><p id="0ead">But before we start trying to optimize anything, we need a way of identifying what code can be improved. The tools that give us this information, is the topic of the next article.</p><h2 id="170a">Further references</h2><p id="dc97">I’m not the first to try to explain how JavaScript engines work. Here are a few articles that go more in depth, and which have a different way of explaining similar concepts:</p><ul><li id="484b"><a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener ugc nofollow">What’s up with monomorphism</a></li><li id="0435"><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener ugc nofollow">Shapes and inline caches</a></li><li id="1c62"><a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener ugc nofollow">Optimizing prototypes</a></li></ul></div></div></div>
  </body>
</html>
