<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.n16f.net/blog/interactive-common-lisp-development/">Original</a>
    <h1>Interactive Common Lisp Development</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
      <p>Common Lisp programming is often presented as “interactive”. In most
languages, modifications to your program are applied either by recompiling it
and restarting it. In contrast, Common Lisp lets you incrementally modify your
program while it is running.</p>
<p>While this approach is convenient, especially for exploratory programming, it
also means that the state of your program during execution does not always
reflect the source code. You do not just define new constructs: you look them
up, inspect them, modify them or delete them. I had to learn a lot of
subtleties the hard way. This article is a compendium of information related
to the interactive nature of Common Lisp.</p>
<h2 id="variables">Variables</h2>
<p>In Common Lisp variables are identified by symbols. Evaluating <code>(SETQ A 42)</code>
creates or updates a variable with the integer <code>42</code> as value, and associates
it to the <code>A</code> symbol. After the call to <code>SETQ</code>, <code>(BOUNDP &#39;A)</code> will return <code>T</code>
and <code>(SYMBOL-VALUE &#39;A)</code> will return <code>42</code>.</p>
<p>You do not delete a variable: instead, you remove the association between the
symbol and the variable. You do so with <code>MAKUNBOUND</code>. Following the previous
example, <code>(MAKUNBOUND &#39;A)</code> will remove the association between the <code>A</code> symbol
and the variable. And <code>(BOUNDP &#39;A)</code> returns <code>NIL</code> as expected. As for
<code>(SYMBOL-VALUE &#39;A)</code>, it now signals an <code>UNBOUND-VARIABLE</code> error as mandated by
the standard.</p>
<p>What about <code>DEFVAR</code> and <code>DEFPARAMETER</code>? They are also used to declare
variables (globally defined ones), associating them with symbols. Both define
“special” variables (i.e. variables for which all bindings are dynamic; see
CLtL2 9.2). The difference is that the initial value passed to <code>DEFVAR</code> is not
evaluated if it already has a value. <code>MAKUNBOUND</code> will work on variables
declared with <code>DEFVAR</code> or <code>DEFPARAMETER</code> as expected.</p>
<p><code>DEFCONSTANT</code> is a bit more complicated. CLtL2<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> 5.3.2 states that “once a
name has been declared by defconstant to be constant, any further assignment
to or binding of that special variable is an error”, but does not clearly
define whether <code>MAKUNBOUND</code> should or should not be able to be used on
constants. However, CLtL2 5.3.2 also states that “defconstant […] does assert
that the value of the variable name is fixed and does license the compiler to
build assumptions about the value into programs being compiled”. If the
compiler is allowed to rely on the value associated with the variable name, it
would make sense not to allow the deletion of the binding. Thus it is
recommended to only use constants for values that are guaranteed to never
change, e.g. mathematical constants. Most of the time you want <code>DEFPARAMETER</code>.</p>
<p>Note that <code>MAKUNBOUND</code> does not apply to lexical variables.</p>
<h2 id="functions">Functions</h2>
<p>Common Lisp is a Lisp-2, meaning that variables and functions are part of two
separate namespaces. Despite this clear separation, functions behave similarly
to variables.</p>
<p>Using <code>DEFUN</code> will either create or update the global function associated with
a symbol. <code>SYMBOL-FUNCTION</code> returns the globally defined function associated
with a symbol, and <code>FMAKUNBOUND</code> deletes this association.</p>
<p>Let us point out a common mistake when referencing functions: <code>(QUOTE F)</code>
(abbreviated as <code>&#39;F</code>) yields a symbol while <code>(FUNCTION F)</code> (abbreviated as
<code>#&#39;F</code>) yields a function. The function argument of <code>FUNCALL</code> and <code>APPLY</code> can
be either a symbol or a function (see CLtL2 7.3) It has two consequences:</p>
<p>First, one can write a function referencing <code>F</code> as <code>(QUOTE F)</code> with the
expectation that <code>F</code> will later be bound to a function. The following function
definition is perfectly valid even though <code>F</code> has not been defined yet:</p>
<pre><code>(defun foo (a b)
  (funcall &#39;f a b))
</code></pre>
<p>Second, redefining the <code>F</code> function will update its association (or binding)
to the <code>F</code> symbol, but the previous function will still be available if it has
been referenced somewhere before the update. For example:</p>
<pre><code>(setf (symbol-function &#39;foo) #&#39;1+)
(let ((old-foo #&#39;foo))
  (setf (symbol-function &#39;foo) #&#39;1-)
  (funcall old-foo 42))
</code></pre>
<p>What about macros? Since macros are a specific kind of functions (CLtL2 5.1.4
“a macro is essentially a function from forms to forms”), it is not surprising
that they share the same namespace and can be manipulated in the same way as
functions with <code>FBOUNDP</code>, <code>SYMBOL-FUNCTION</code> and <code>FMAKUNBOUND</code>.</p>
<h2 id="symbols-and-packages">Symbols and packages</h2>
<p>While functions and variables are familiar concepts to developers, Common Lisp
symbols and packages are a bit more peculiar.</p>
<p>A symbol is <em>interned</em> when it is part of a package. The most explicit way to
create an interned symbol is to use <code>INTERN</code>, e.g. <code>(INTERN &#34;FOO&#34;)</code>. <code>INTERN</code>
interns the symbol in the current package by default, but one can pass a
package as second argument. After that, <code>(FIND-SYMBOL &#34;FOO&#34;)</code> will return our
interned symbol as expected.</p>
<p>More surprisingly, the reader automatically interns symbols. You can test it
by evaluating <code>(READ-FROM-STRING &#34;BAR&#34;)</code>. After evaluation, <code>BAR</code> is a symbol
interned in the current package. This also means that it is very easy to
pollute a package with symbols in ways you did not necessarily expect. To
clean up, simply use <code>UNINTERN</code>. Remember to refer to the right symbol: to
remove the symbol <code>BAR</code> from the package <code>FOO</code>, use <code>(UNINTERN &#39;FOO::BAR &#34;BAR&#34;)</code>.</p>
<p>A symbol is either internal or external. <code>EXPORT</code> will make a symbol external
to its package while <code>UNEXPORT</code> will make it internal. As for <code>UNINTERN</code>,
confusion usually arises around which symbol is affected. <code>(UNEXPORT &#39;FOO:BAR &#34;FOO&#34;)</code> correctly refers to the external symbol in the <code>FOO</code> package and makes
it internal again. <code>(UNEXPORT &#39;BAR &#34;FOO&#34;)</code> will signal an error since the
<code>BAR</code> symbol is not part of the <code>FOO</code> package (unless of course the current
package happens to be <code>FOO</code>).</p>
<p>Packages themselves can be created with <code>MAKE-PACKAGE</code> and destroyed with
<code>DELETE-PACKAGE</code>. Developers are usually more familiar with <code>DEFPACKAGE</code>, a
macro allowing the creation of a package and its configuration (package use
list, imported and exported symbols, etc.) in a declarative way. A surprising
and frustrating behavior is that evaluating a <code>DEFPACKAGE</code> form for a package
that already exists will result in undefined behavior if the new declaration
“is not consistent” (CLtL2 11.7) with the current state of the package. As an
example, adding symbols to the export list is perfectly fine. Removing one
will result in undefined behavior (usually an error) due to the inconsistency
of the export list. Fortunately, Common Lisp offers all the necessary
functions to manipulate packages and their symbols: use them!</p>
<h2 id="classes">Classes</h2>
<p>The Common Lisp standard includes CLOS, the Common Lisp Object System.
Unsurprisingly it provides multiple ways to interact with classes and objects
dynamically.</p>
<p>As variables or functions, classes are identified by symbols and <code>FIND-CLASS</code>
returns the class associated with a symbol. Class names are part of a separate
namespace shared with structures and types.</p>
<p>The <code>DEFCLASS</code> macro is the only way to define or redefine a class. Redefining
a class means that instances created afterward with <code>MAKE-INSTANCE</code> will use
the new definition. Existing instances are updated: newly added slots are
added (either unbound or using the value associated with <code>:INITFORM</code>) and
slots that are not defined anymore are deleted.
<code>UPDATE-INSTANCE-FOR-REDEFINED-CLASS</code> is particularly interesting: developers
can define methods for this generic function in order to control how instances
are updated when their class is redefined.</p>
<p>Defining classes may imply implicitly defining methods: the <code>:ACCESSOR</code>,
<code>:READER</code> and <code>:WRITER</code> slot keyword arguments will lead to the creation of
generic functions. When a class is redefined, methods associated with slots
that have been removed will live on.</p>
<p>A limitation of CLOS is that classes cannot be deleted. <code>FIND-CLASS</code> can be
used as a <em>place</em>, and <code>(SETF (FIND-CLASS &#39;FOO) NIL)</code> will remove the
association between the <code>FOO</code> symbol and the class, but the class itself and
its instances will not disappear. While this limitation may seem strange, ask
yourself how an implementation should handle instances of a class that has
been deleted.</p>
<p>The class of an instance can be changed with <code>CHANGE-CLASS</code>: slots that exist
in the new class will be conserved while those that do not are deleted. New
slots are either unbound or set to the value associated with <code>:INITFORM</code> in
the new class. In a way similar to <code>UPDATE-INSTANCE-FOR-REDEFINED-CLASS</code>,
<code>UPDATE-INSTANCE-FOR-DIFFERENT-CLASS</code> lets developers control precisely the
process.</p>
<h3 id="generics-and-methods">Generics and methods</h3>
<p>Generics are functions which can be specialized based on the class (and not
type as one could expect) of their arguments and which can have a method
combination type.</p>
<p>Generics can be created explicitly with <code>DEFGENERIC</code> or implicitly when
<code>DEFMETHOD</code> is called and the list of parameter specializers and method
combination does not match any existing generic function. Since generics are
functions, <code>FBOUNDP</code>, <code>SYMBOL-FUNCTION</code> and <code>FMAKUNBOUND</code> will work as
expected.</p>
<p>Methods themselves are either defined as part of the <code>DEFGENERIC</code> call or
separately with <code>DEFMETHOD</code>. Discovering the different methods associated with
a generic function is a bit more complicated. There is no standard way to list
the methods associated with a generic, but it is at least possible to look up
a method with <code>FIND-METHOD</code>. Do remember to pass a function (and not a symbol)
as the generic, and to pass classes (and not symbols naming classes) in the
list of specializers.</p>
<p>Redefinition is not as obvious as for non-generic functions. When redefining a
generic with <code>DEFGENERIC</code> all methods defined as part of the previous
<code>DEFGENERIC</code> form are removed and methods defined in the redefinition are
added. However, methods defined separately with <code>DEFMETHOD</code> are not affected.</p>
<p>For example, in the following code, the second call to <code>DEFGENERIC</code> will
replace the two methods specialized on <code>INTEGER</code> and <code>FLOAT</code> respectively by a
single one specialized on a <code>STREAM</code>, but the method specialized on <code>STRING</code>
will remain unaffected.</p>
<pre><code>(defgeneric foo (a)
  (:method ((a integer))
    (format nil &#34;~A is an integer&#34; a))
  (:method ((a float))
    (format nil &#34;~A is a float&#34; a)))

(defmethod foo ((a string))
  (format nil &#34;~S is a string&#34; a))

(defgeneric foo (a)
  (:method ((a stream))
    (format nil &#34;~A is a stream&#34; a)))
</code></pre>
<p>Note that trying to redefine a generic with a different parameter lambda list
will cause the removal of all previously defined methods since none of them
can match the new parameters.</p>
<p>Removing a method will require you to find it first using <code>FIND-METHOD</code> and
then use <code>REMOVE-METHOD</code>. With the previous example, removing the method
specialized on a <code>STRING</code> argument is done with:</p>
<pre><code>(remove-method #&#39;foo (find-method #&#39;foo nil (list (find-class &#39;string)) nil))
</code></pre>
<p>Working with methods is not always easy, and two errors are very common.</p>
<p>First, remember that changing the combinator in a <code>DEFMETHOD</code> will define a
new method. If you realize that your <code>:AFTER</code> method should use <code>:AROUND</code> and
reevaluate the <code>DEFMETHOD</code> form, remember to delete the method with the
<code>:AFTER</code> combinator or you will end up with two methods being called.</p>
<p>Second, when defining a method for a generic from another package, remember to
correctly refer to the generic. If you want to define a method on the <code>BAR</code>
generic from package <code>FOO</code>, use <code>(DEFMETHOD FOO:BAR (…) …)</code> and not
<code>(DEFMETHOD BAR (…) …)</code>. In the latter case, you will define a new <code>BAR</code>
generic in the current package.</p>
<h3 id="meta-object-protocol">Meta Object Protocol</h3>
<p>While CLOS is already quite powerful, various interactions are impossible. One
cannot create classes or methods programmatically, introspect classes or
instances for example to list their slots or obtain all their superclasses, or
list all the methods associated with a generic function.</p>
<p>In addition of an example of a CLOS implementation, The Art of the Metaobject
Protocol<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> defines multiple extensions to CLOS including metaclasses,
metaobjects, dynamic class and generic creation, class introspection and much
more.</p>
<p>Most Common Lisp implementations implement at least part of these extensions,
usually abbreviated as “MOP”, for “MetaObject Protocol”. The well-known
<a href="https://github.com/pcostanza/closer-mop">closer-mop</a> system can be used as a
compatibility layer for multiple implementations.</p>
<h3 id="structures">Structures</h3>
<p>Structures are record constructs defined with <code>DEFSTRUCT</code>. At a glance they
may seem very similar to classes, but they have a fundamental limitation:
the results of redefining a structure are undefined (CLtL2 19.2).</p>
<p>While this property allows implementations to handle structures in a more
efficient way than classes, it makes structures unsuitable for incremental
development. As such, they should only be used as a last resort, when a
regular class has been proved to be a performance bottleneck.</p>
<h3 id="conditions">Conditions</h3>
<p>While conditions look very similar to classes the Common Lisp standard does
not define them as classes. This is one of the few differences between the
standard and CLtL2 which clearly states in 29.3.4 that “Common Lisp condition
types are in fact CLOS classes, and condition objects are ordinary CLOS
objects”.</p>
<p>This is why one uses <code>DEFINE-CONDITION</code> instead of <code>DEFCLASS</code> and
<code>MAKE-CONDITION</code> instead of <code>MAKE-INSTANCE</code>. This also means that one should
not use slot-related functions (including the very useful <code>WITH-SLOTS</code> macro)
with conditions.</p>
<p>In practice, most modern implementations follow CLtL2 and the
<a href="https://www.lispworks.com/documentation/HyperSpec/Issues/iss049_w.htm"><code>CLOS-CONDITIONS:INTEGRATE</code> X3J13 Cleanup
Issue</a>
and implement conditions as CLOS classes, meaning that conditions can be
manipulated and redefined as any other classes. And the same way as any other
classes, they cannot be deleted.</p>
<h2 id="types">Types</h2>
<p>Types are identified by symbols and are part of the same namespace as classes
(which should not be surprising since defining a class automatically defines a
type with the same name).</p>
<p>Types are defined with <code>DEFTYPE</code>, but documentation is surprisingly silent on
the effects of type redefinition. This can lead to interesting situations. On
some implementations (e.g. SBCL and CCL), if a class slot is defined as having
the type <code>FOO</code>, redefining <code>FOO</code> will not be taken into account and the type
checking operation (which is not mandated by the standard) will use the
previous definition of the type. Infortunatly Common Lisp does not mandate
any specific behavior on slot type mismatches (CLtL2 28.1.3.2).</p>
<p>Thus developers should not expect any useful effect from redefining types.
Restarting the implementation after substantial type changes is probably best.</p>
<p>In the same vein interactions with types are very limited. You cannot find a
type by its symbol or even check whether a type exists or not. Calling
<code>TYPE-OF</code> on a value will return a type this value satisfies, but the nature
of the type is implementation-dependent (CLtL2 4.9): it could be any
supertype. In other words, <code>TYPE-OF</code> could absolutly return <code>T</code> for all values
but <code>NIL</code>. At least <code>SUBTYPE-P</code> lets you check whether a type is a subtype of
another type.</p>
<h2 id="going-further">Going further</h2>
<p>Common Lisp is a complex language with a lot of subtleties, way more than what
can be covered in a blog post. The curious reader will probably skip the
standard (not because you have to buy it, but because it is a <a href="https://www.xach.com/naggum/articles/3210940486298743@naggum.net.html">low quality
scan of a printed
document</a>
and jump directly to CLtL2 or the <a href="https://www.lispworks.com/documentation/lw50/CLHS/Front/index.htm">Common Lisp
HyperSpec</a>.
The Art of the Metaobject Protocol is of course the normative reference for
the CLOS extensions usually referred to as “MOP”.</p>


    </section>
  </div></div>
  </body>
</html>
