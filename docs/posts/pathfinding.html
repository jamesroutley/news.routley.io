<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://juhrjuhr.itch.io/deep-space-exploitation/devlog/945428/9-pathfinding">Original</a>
    <h1>Pathfinding</h1>
    
    <div id="readability-page-1" class="page"><section id="object_text_widget_7877429"><p><strong>Hello!</strong></p>
<p>I had a few extra requirements of my pathfinding, due to how my game plays:</p>
<ul><li>Must deal with a dynamic physical environment (objects can move freely and are destructible)</li><li>Have paths that prefer to keep their distance from objects but still get close when needed</li><li>Allow for wrapping around the borders of the game area (Asteroids style)</li></ul>
<p><img src="https://img.itch.zone/aW1nLzIxMjAwMzk1LmdpZg==/original/RjziF%2B.gif" loading="lazy"/><br/></p>
<p><strong>General Approach</strong></p>
<p>My first thought was that I wanted detailed paths so that they could thread through messy arrangements of objects quite easily. This would mean a longer search time, so the simple choice of search algorithm is A*. And since I need to query the world for each node to see whether it&#39;s blocked, I thought I&#39;d use space partitioning with the queries to cut down on the number required for each path.</p>
<p>I ended up sticking to this plan, and figuring out the more detailed stuff along the way.</p>
<p><strong>Space Partitioned Queries</strong></p>
<p>I built a space partitioning tree where each node covers a specific area of the game, and then each of that node&#39;s children covers a specific area of their parent&#39;s area (with the tree&#39;s root covering the whole game area). I do this to a depth of 6 and then the leaf nodes effectively make up the navigation grid for path finding.</p>
<p>Now when I check if a node is blocked it will first check its parent. If its parent is not blocked, then none of its children are blocked. If the parent is blocked, then the child node needs to run its own query to see whether its own area is blocked. This allows us to know whether large areas of the game are not blocked in very few queries, which is useful because these queries are expensive.</p>
<p><strong>A* Search</strong></p>
<p>The actual search is a pretty standard A* search. Each node has 8 neighbours, with nodes on the edge having wrapped neighbours, which are cached along with their traversal cost for faster lookup.</p>
<p><strong>Environment Changing in Real Time</strong></p>
<p>Because objects can move around in the game world and even have chunks of them destroyed, this algorithm needed to be able to update in real time. The asteroid that wasn&#39;t blocking the path a second ago might have moved, and the asteroid that was blocking the path might have been blown up!</p>
<p>My simple solution for this was to allow the algorithm to cache whether each node it checked was blocked, but then invalidate that cache every so often (currently every 500ms is working nicely). This allows time to build up a picture of the world and let one path finding request use information from a previous request, but also forces the algorithm to keep up to date on the current state of the world.</p>
<p>Ideally we wouldn&#39;t invalidate the whole cache since there will be sections of the game world where nothing has moved, but realistically this is a simple approach that works well enough. Saying that, I do have a plan on how to do this should it be necessary.</p>
<p><img src="https://img.itch.zone/aW1nLzIxMjAwMzY3LmdpZg==/original/O%2FX04e.gif" loading="lazy"/><br/></p>
<p>Here you can see the spreading out and being updated in real time. Each blue square represents an unblocked node, and the colour of the pixel in the node represents proximity to the nearest object.<br/></p>
<p><strong>Natural Paths</strong></p>
<p>The shortest path doesn&#39;t usually look natural, or safe for that matter, so I wanted the algorithm to prefer paths that are further away from objects but still be able to get close when necessary (threading through a small gap, for example).</p>
<p>So for each pathfinding request a preferred distance from objects is provided, which is then used to give each node a proximity rating. This proximity rating is used when determining the traversal cost to a node, so nodes that are closer to objects are simply more expensive when running the search. </p>
<p>Currently the proximity rating has an exponential effect, so the path really tries to avoid being super close to things, but doesn&#39;t mind being a little close if it has to.</p>
<p><img src="https://img.itch.zone/aW1nLzIxMjAwMzcyLmdpZg==/original/X7dh0x.gif" loading="lazy"/><br/></p>
<p>Here you can see the path keeping its distance from objects until its forced to get closer and in between them. You can also see the space partitioning better here, with the larger blue squares representing areas that only required a single query.</p>
<p><img src="https://img.itch.zone/aW1nLzIxMjAwMzczLmdpZg==/original/u8ZlIg.gif" loading="lazy"/><br/></p>
<p><strong>Wrapped Paths</strong></p>
<p>Because the game area allows for Asteroids-like wrapping, I wanted the pathfinding to account for this too. NPCs not having the same kind of mobility as the player is a bit jarring, plus it made the problem a little more fun to solve. :)</p>
<p>Wrapped paths mean that every navigation node actually has the same number of neighbours, which is an interesting and maybe uncommon property (pathfinding on a 3d globe probably has the same property).</p>
<p>Producing the wrapped path was not actually the hard part, it was simple enough to give border nodes neighbours on the other side of the grid. The hard part was having the NPC actually follow the path since without any special handling it would just reach the node at one border and then turn around and move straight towards the node at the other border, without wrapping at all.</p>
<p>To fix this, any time wrapping occurs on a path an additional node is added off-screen, which the NPC attempts to follow and then ends up wrapping around. There was also the problem of which NPC position do you use to follow the path when they start wrapping (an object has multiple positions when it&#39;s wrapping), but the simple solution to this was to just use the closest NPC position to the next step in the path.</p>
<p>The borders have their own proximity cost to keep paths slightly away from them and also make wrapping a kind of last resort.</p>
<p><img src="https://img.itch.zone/aW1nLzIxMjAwMzc0LmdpZg==/original/dGKgwy.gif" loading="lazy"/><br/></p>
<p>Here you can see the path spreading out and finding that the shortest path by quite a margin is to wrap around the order instead of go around the asteroids. You can also see the elapsed time in the corner, this is the time spent in processing the path each update, not total update time.</p>
<p><strong>Efficiency</strong></p>
<p>This algorithm is doing a lot of work and it can end up taking multiple milliseconds for the more complicated paths (on my machine anyway). I&#39;m trying pretty hard to keep the game as performant as possible, so it matters a lot to me that this won&#39;t slow anything down.</p>
<p>My approach was to first benchmark and optimise things as much as I could, and then split the processing of a single pathing request over multiple game ticks. To split over multiple ticks I check the number of nodes visited and world queries after each iteration of the A* search, if either of these are over the threshold I&#39;ve set, then the loop exits and picks up where it left off on the next tick.</p>
<p>This means that there&#39;s some asynchronicity when an entity requests a path and when it gets the result. Since the wait is only ever in the single digit milliseconds this isn&#39;t really perceptible to the player, especially since it&#39;s only ever NPCs making pathing requests and not the player.</p>
<p>This kind of efficiency problem is something that looks ripe for multi-threading, but the main problem I had here is that all the world state of the game is held on the main thread and in complicated structures, so copying that across to a pathing thread would be difficult and potentially slow. I could have allowed the pathing thread to make query requests to the main thread, but then we have more synchronization logic to deal with. So for fewer headaches I stuck to the main thread and divided processing between ticks.</p>
<p><strong>Conclusion</strong></p>
<p>The only part of this solution that I looked at other examples for was the core A* search, everything else I worked out myself to the best of my ability. I could say that the solution I wanted had specific requirements that many examples online didn&#39;t cater for, but in honesty I didn&#39;t even look because I wanted to have a go at this myself. The thing I love about game dev is thinking my way around interesting problems and providing (hopefully) a good solution. Maybe I could have had a working solution faster by finding someone else&#39;s online, but I wouldn&#39;t have enjoyed the process as much.</p>
<p>In my tests of my solution it&#39;s been performant and produces paths that makes sense, and maybe more importantly look good to the player. There are aspects that I&#39;d like to look into more, like only invalidating the parts of the query cache where the world has changed, but sadly we have to move on to other features eventually. Next I get to actually use this pathing when creating behaviours for some NPCs, so we&#39;ll see how it all turns out.</p></section></div>
  </body>
</html>
