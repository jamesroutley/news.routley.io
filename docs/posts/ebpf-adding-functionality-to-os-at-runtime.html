<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ebpf.io/what-is-ebpf/">Original</a>
    <h1>eBPF – Adding functionality to OS at runtime</h1>
    
    <div id="readability-page-1" class="page"><div><h2>What is eBPF?</h2><p>eBPF (which is no longer an acronym for anything) is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in a privileged context such as the operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.</p><p>Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system.</p><p><img src="https://ebpf.io/static/overview-a213bbbda01b911f9ab529d969acd225.png"/></p><p>eBPF changes this formula fundamentally. By allowing to run sandboxed programs within the operating system, application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality.</p><p>Today, eBPF is used extensively to drive a wide variety of use cases: Providing high-performance networking and load-balancing in modern data centers and cloud native environments, extracting fine-grained security observability data at low overhead, helping application developers trace applications, providing insights for performance troubleshooting, preventive application and container runtime security enforcement, and much more. The possibilities are endless, and the innovation that eBPF is unlocked has only just begun.</p><h3>What is eBPF.io?</h3><p>eBPF.io is a place for everybody to learn and collaborate on the topic of eBPF. eBPF is an open community and everybody can participate and share. Whether you want to read a first introduction to eBPF, find further reading material or make your first steps to becoming contributors to major eBPF projects, eBPF.io will help you along the way.</p><h3>What is the bee named?</h3><p>The bee is the official logo for eBPF and was originally created by Vadim Shchekoldin. At the first eBPF Summit there was a vote taken and the bee was named <b>eBee</b>. (For details on acceptable uses of the logo, please see the Linux Foundation <a href="https://linuxfoundation.org/brand-guidelines/">Brand Guidelines</a>.)</p><h2>Introduction to eBPF</h2><p>The following chapters are a quick introduction into eBPF. If you would like to learn more about eBPF, see the<!-- --> <a href="https://cilium.readthedocs.io/en/stable/bpf/">eBPF &amp; XDP Reference Guide</a>. Whether you are a developer looking to build an eBPF program, or interested in leveraging a solution that uses eBPF, it is useful to understand the basic concepts and architecture.</p><h3>Hook Overview</h3><p>eBPF programs are event-driven and are run when the kernel or an application passes a certain hook point. Pre-defined hooks include system calls, function entry/exit, kernel tracepoints, network events, and several others.</p><p><img src="https://ebpf.io/static/syscall_hook-67a7e1bfcabb2ab7a46b359ae9cee71a.png"/></p><p>If a predefined hook does not exist for a particular need, it is possible to create a kernel probe (kprobe) or user probe (uprobe) to attach eBPF programs almost anywhere in kernel or user applications.</p><p><img src="https://ebpf.io/static/hook_overview-b14aa13a6baf76a4e35e69de857fa88d.png"/></p><h3>How are eBPF programs written?</h3><p>In a lot of scenarios, eBPF is not used directly but indirectly via projects like <a href="https://ebpf.io/projects/#cilium">Cilium</a>,<!-- --> <a href="https://ebpf.io/projects/#bcc">bcc</a>, or<!-- --> <a href="https://ebpf.io/projects/#bpftrace">bpftrace</a> which provide an abstraction on top of eBPF and do not require to write programs directly but instead offer the ability to specify intent-based definitions which are then implemented with eBPF.</p><p><img src="https://ebpf.io/static/clang-474f8cf2581479a1a8f3f77538b67681.png"/></p><p>If no higher-level abstraction exists, programs need to be written directly. The Linux kernel expects eBPF programs to be loaded in the form of bytecode. While it is of course possible to write bytecode directly, the more common development practice is to leverage a compiler suite like <a href="https://llvm.org/">LLVM</a> to compile pseudo-C code into eBPF bytecode.</p><h3>Loader &amp; Verification Architecture</h3><p>When the desired hook has been identified, the eBPF program can be loaded into the Linux kernel using the bpf system call. This is typically done using one of the available eBPF libraries. The next section provides an introduction into the available development toolchains.</p><p><img src="https://ebpf.io/static/go-ec58640488770cf5e5b4160ae7c04ae0.png"/></p><p>As the program is loaded into the Linux kernel, it passes through two steps before being attached to the requested hook:</p><h3>Verification</h3><p>The verification step ensures that the eBPF program is safe to run. It validates that the program meets several conditions, for example:</p><p><img src="https://ebpf.io/static/loader-dff8db7daed55496f43076808c62be8f.png"/></p><ul><li>The process loading the eBPF program holds the required capabilities (privileges). Unless unprivileged eBPF is enabled, only privileged processes can load eBPF programs.</li><li>The program does not crash or otherwise harm the system.</li><li>The program always runs to completion (i.e. the program does not sit in a loop forever, holding up further processing).</li></ul><h3>JIT Compilation</h3><p>The Just-in-Time (JIT) compilation step translates the generic bytecode of the program into the machine specific instruction set to optimize execution speed of the program. This makes eBPF programs run as efficiently as natively compiled kernel code or as code loaded as a kernel module.</p><h3>Maps</h3><p>A vital aspect of eBPF programs is the ability to share collected information and to store state. For this purpose, eBPF programs can leverage the concept of eBPF maps to store and retrieve data in a wide set of data structures. eBPF maps can be accessed from eBPF programs as well as from applications in user space via a system call.</p><p><img src="https://ebpf.io/static/map_architecture-6b0f37504ff7d44559b740bab0012d02.png"/></p><p>The following is an incomplete list of supported map types to give an understanding of the diversity in data structures. For various map types, both a shared and a per-CPU variation is available.</p><ul><li>Hash tables, Arrays</li><li>LRU (Least Recently Used)</li><li>Ring Buffer</li><li>Stack Trace</li><li>LPM (Longest Prefix match)</li><li>...</li></ul><h3>Helper Calls</h3><p>eBPF programs cannot call into arbitrary kernel functions. Allowing this would bind eBPF programs to particular kernel versions and would complicate compatibility of programs. Instead, eBPF programs can make function calls into helper functions, a well-known and stable API offered by the kernel.</p><p><img src="https://ebpf.io/static/helper-84af75c9a5b2c2abf127110cda48b8e2.png"/></p><p>The set of available helper calls is constantly evolving. Examples of available helper calls:</p><ul><li>Generate random numbers</li><li>Get current time &amp; date</li><li>eBPF map access</li><li>Get process/cgroup context</li><li>Manipulate network packets and forwarding logic</li></ul><h3>Tail &amp; Function Calls</h3><p>eBPF programs are composable with the concept of tail and function calls. Function calls allow defining and calling functions within an eBPF program. Tail calls can call and execute another eBPF program and replace the execution context, similar to how the execve() system call operates for regular processes.</p><p><img src="https://ebpf.io/static/tailcall-a4d7f4b6a449cdee9515c6ff36c89346.png"/></p><h3>eBPF Safety</h3><p><i>With great power there must also come great responsibility.</i></p><p>eBPF is an incredibly powerful technology and now runs at the heart of many critical software infrastructure components. During the development of eBPF, the safety of eBPF was the most crucial aspect when eBPF was considered for inclusion into the Linux kernel. eBPF safety is ensured through several layers:</p><h4>Required Privileges</h4><p>Unless unprivileged eBPF is enabled, all processes that intend to load eBPF programs into the Linux kernel must be running in privileged mode (root) or require the capability CAP_BPF. This means that untrusted programs cannot load eBPF programs.</p><p>If unprivileged eBPF is enabled, unprivileged processes can load certain eBPF programs subject to a reduced functionality set and with limited access to the kernel.</p><h4>Verifier</h4><p>If a process is allowed to load an eBPF program, all programs still pass through the eBPF verifier. The eBPF verifier ensures the safety of the program itself. This means, for example:</p><ul><li>Programs are validated to ensure they always run to completion, e.g. an eBPF program may never block or sit in a loop forever. eBPF programs may contain so called bounded loops but the program is only accepted if the verifier can ensure that the loop contains an exit condition which is guaranteed to become true.</li><li>Programs may not use any uninitialized variables or access memory out of bounds.</li><li>Programs must fit within the size requirements of the system. It is not possible to load arbitrarily large eBPF programs.</li><li>Program must have a finite complexity. The verifier will evaluate all possible execution paths and must be capable of completing the analysis within the limits of the configured upper complexity limit.</li></ul><h4>Hardening</h4><p>Upon successful completion of the verification, the eBPF program runs through a hardening process according to whether the program is loaded from a privileged or unprivileged process. This step includes:</p><ul><li><b>Program execution protection:</b> The kernel memory holding an eBPF program is protected and made read-only. If for any reason, whether it is a kernel bug or malicious manipulation, the eBPF program is attempted to be modified, the kernel will crash instead of allowing it to continue executing the corrupted/manipulated program.</li><li><b>Mitigation against Spectre:</b> Under speculation CPUs may mispredict branches and leave observable side effects that could be extracted through a side channel. To name a few examples: eBPF programs mask memory access in order to redirect access under transient instructions to controlled areas, the verifier also follows program paths accessible only under speculative execution and the JIT compiler emits Retpolines in case tail calls cannot be converted to direct calls.</li><li><b>Constant blinding:</b> All constants in the code are blinded to prevent JIT spraying attacks. This prevents attackers from injecting executable code as constants which in the presence of another kernel bug, could allow an attacker to jump into the memory section of the eBPF program to execute code.</li></ul><h4>Abstracted Runtime Context</h4><p>eBPF programs cannot access arbitrary kernel memory directly. Access to data and data structures that lie outside of the context of the program must be accessed via eBPF helpers. This guarantees consistent data access and makes any such access subject to the privileges of the eBPF program, e.g. an eBPF program running is allowed to modify the data of certain data structures if the modification can be guaranteed to be safe. An eBPF program cannot randomly modify data structures in the kernel.</p><h2>Why eBPF?</h2><h3>The Power of Programmability</h3><p>Let’s start with an analogy. Do you remember GeoCities? 20 years ago, web pages used to be almost exclusively written in static markup language (HTML). A web page was basically a document with an application (browser) able to display it. Looking at web pages today, web pages have become full-blown applications and web-based technology has replaced a vast majority of applications written in languages requiring compilation. What enabled this evolution?</p><p><img src="https://ebpf.io/static/geocities-a7a90c1af196df4bbce3a7932f056f93.png"/></p><p>The short-answer is programmability with the introduction of JavaScript. It unlocked a massive revolution resulting in browsers to evolve into almost independent operating systems.</p><p>Why did the evolution happen? Programmers were no longer as bound to users running particular browser versions. Instead of convincing standards bodies that a new HTML tag was needed, the availability of the necessary building blocks decoupled the pace of innovation of the underlying browser from the application running on top. This is of course a bit oversimplified as HTML did evolve over time and contributed to the success but the evolution of HTML itself would not have been sufficient.</p><p>Before taking this example and applying it to eBPF, let&#39;s look at a couple of key aspects that were vital in the introduction of JavaScript:</p><ul><li><b>Safety:</b> Untrusted code runs in the browser of the user. This was solved by sandboxing JavaScript programs and abstracting access to browser data.</li><li><b>Continuous Delivery:</b> Evolution of program logic must be possible without requiring to constantly ship new browser versions. This was solved by providing the right low-level building blocks sufficient to build arbitrary logic.</li><li><b>Performance:</b> Programmability must be provided with minimal overhead. This was solved with the introduction of a Just-in-Time (JIT) compiler.</li></ul><p>For all of the above, exact counter parts can be found in eBPF for the same reason.</p><h3>eBPF&#39;s impact on the Linux Kernel</h3><p>Now let’s return to eBPF. In order to understand the programmability impact of eBPF on the Linux kernel, it helps to have a high-level understanding of the architecture of the Linux kernel and how it interacts with applications and the hardware.</p><p><img src="https://ebpf.io/static/kernel_arch-c0be6286222dcd0e6e45250d2d9a87fd.png"/></p><p>The main purpose of the Linux kernel is to abstract the hardware or virtual hardware and provide a consistent API (system calls) allowing for applications to run and share the resources. In order to achieve this, a wide set of subsystems and layers are maintained to distribute these responsibilities. Each subsystem typically allows for some level of configuration to account for different needs of users. If a desired behavior cannot be configured, a kernel change is required, historically, leaving two options:</p><li>Change kernel source code and convince the Linux kernel community that the change is required.</li><li>Wait several years for the new kernel version to become a commodity.</li><li>Write a kernel module</li><li>Fix it up regularly, as every kernel release may break it</li><li>Risk corrupting your Linux kernel due to lack of security boundaries</li><table><thead><tr><th>Native Support</th><th>Kernel Module</th></tr></thead><tbody><tr><td><ol></ol></td></tr><tr></tr><tr><td><ol></ol></td></tr><tr></tr></tbody></table><p>With eBPF, a new option is available that allows for reprogramming the behavior of the Linux kernel without requiring changes to kernel source code or loading a kernel module. In many ways, this is very similar to how JavaScript and other scripting languages unlocked the evolution of systems which had become difficult or expensive to change.</p><h2>Development Toolchains</h2><p>Several development toolchains exist to assist in the development and management of eBPF programs. All of them address different needs of users:</p><h4>bcc</h4><p>BCC is a framework that enables users to write python programs with eBPF programs embedded inside them. The framework is primarily targeted for use cases which involve application and system profiling/tracing where an eBPF program is used to collect statistics or generate events and a counterpart in user space collects the data and displays it in a human readable form. Running the python program will generate the eBPF bytecode and load it into the kernel.</p><p><img src="https://ebpf.io/static/bcc-3eaeaf344b8830aa11d5d03921891578.png"/></p><h4>bpftrace</h4><p>bpftrace is a high-level tracing language for Linux eBPF and available in recent Linux kernels (4.x). bpftrace uses LLVM as a backend to compile scripts to eBPF bytecode and makes use of BCC for interacting with the Linux eBPF subsystem as well as existing Linux tracing capabilities: kernel dynamic tracing (kprobes), user-level dynamic tracing (uprobes), and tracepoints. The bpftrace language is inspired by awk, C and predecessor tracers such as DTrace and SystemTap.</p><p><img src="https://ebpf.io/static/bpftrace-92ad270c4d575c6ae27ef94b6aa8c135.png"/></p><h4>eBPF Go Library</h4><p>The eBPF Go library provides a generic eBPF library that decouples the process of getting to the eBPF bytecode and the loading and management of eBPF programs. eBPF programs are typically created by writing a higher level language and then use the clang/LLVM compiler to compile to eBPF bytecode.</p><p><img src="https://ebpf.io/static/go-ec58640488770cf5e5b4160ae7c04ae0.png"/></p><h4>libbpf C/C++ Library</h4><p>The libbpf library is a C/C++-based generic eBPF library which helps to decouple the loading of eBPF object files generated from the clang/LLVM compiler into the kernel and generally abstracts interaction with the BPF system call by providing easy to use library APIs for applications.</p><p><img src="https://ebpf.io/static/libbpf-ee03b2f4d79b197554fa00671e67129d.png"/></p><h2>Further Reading</h2><p>If you would like to learn more about eBPF, continue reading using the following additional materials:</p><h3>Documentation</h3><ul><li><a href="https://cilium.readthedocs.io/en/stable/bpf/">BPF &amp; XDP Reference Guide</a></li><li><a href="https://www.kernel.org/doc/html/latest/bpf/index.html">BPF Documentation</a></li><li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst">BPF Design Q&amp;A</a></li></ul><h3>Tutorials</h3><ul><li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">Learn eBPF Tracing: Tutorial and Examples</a></li><li><a href="https://github.com/xdp-project/xdp-tutorial">XDP Hands-On Tutorials</a></li><li><a href="https://facebookmicrosites.github.io/bpf/blog/">BCC, libbpf and BPF CO-RE Tutorials</a></li></ul><h3>Talks</h3><h4>Generic</h4><ul><li><a href="https://www.youtube.com/watch?v=99jUcLt3rSk">eBPF and Kubernetes: Little Helper Minions for Scaling Microservices</a><span> (</span><a href="https://kccnceu20.sched.com/event/ZemQ/ebpf-and-kubernetes-little-helper-minions-for-scaling-microservices-daniel-borkmann-cilium">Slides</a><span>)</span></li><li><a href="https://www.infoq.com/presentations/facebook-google-bpf-linux-kernel/">eBPF - Rethinking the Linux Kernel</a><span> (</span><a href="https://docs.google.com/presentation/d/1AcB4x7JCWET0ysDr0gsX-EIdQSTyBtmi6OAW7bE0jm0">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=U3PdyHlrG1o&amp;t=7">BPF as a revolutionary technology for the container landscape</a><span> (</span><a href="https://fosdem.org/2020/schedule/event/containers_bpf/attachments/slides/4122/export/events/attachments/containers_bpf/slides/4122/BPF_as_a_revolutionary_technology_for_the_container_landscape.pdf">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=ZYBXZFKPS28">BPF at Facebook</a></li><li><a href="https://youtu.be/7pmXdG8-7WU?t=8">BPF: A New Type of Software</a><span> (</span><a href="https://www.slideshare.net/brendangregg/um2019-bpf-a-new-type-of-software">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=mFxs3VXABPU">The ubiquity but also the necessity of eBPF as a technology</a></li></ul><h4>Deep Dives</h4><ul><li><a href="https://www.youtube.com/watch?v=6N30Yp5f9c4">BPF and Spectre: Mitigating transient execution attacks</a><span> (</span><a href="https://ebpf.io/summit-2021-slides/eBPF_Summit_2021-Keynote-Daniel_Borkmann-BPF_and_Spectre.pdf">Slides</a><span>)</span></li><li><a href="https://www.usenix.org/conference/lisa21/presentation/gregg-bpf">BPF Internals</a><span> (</span><a href="https://www.usenix.org/system/files/lisa21_slides_gregg_bpf.pdf">Slides</a><span>)</span></li></ul><h4>Cilium</h4><ul><li><a href="https://www.youtube.com/watch?v=PJY-rN1EsVw">Advanced BPF Kernel Features for the Container Age</a><span> (</span><a href="https://fosdem.org/2021/schedule/event/containers_ebpf_kernel/attachments/slides/4358/export/events/attachments/containers_ebpf_kernel/slides/4358/Advanced_BPF_Kernel_Features_for_the_Container_Age_FOSDEM.pdf">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=UkvxPyIJAko&amp;t=21s">Kubernetes Service Load-Balancing at Scale with BPF &amp; XDP</a><span> (</span><a href="https://linuxplumbersconf.org/event/7/contributions/674/attachments/568/1002/plumbers_2020_cilium_load_balancer.pdf">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=bIRwSIwNHC0">Liberating Kubernetes from kube-proxy and iptables</a><span> (</span><a href="https://docs.google.com/presentation/d/1cZJ-pcwB9WG88wzhDm2jxQY4Sh8adYg0-N3qWQ8593I/edit#slide=id.g7055f48ba8_0_0">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=Kmm8Hl57WDU">Understanding and Troubleshooting the eBPF Datapath in Cilium</a><span> (</span><a href="https://static.sched.com/hosted_files/kccncna19/20/eBPF%20and%20the%20Cilium%20Datapath.pdf">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=gPvl2NDIWzY">Transparent Chaos Testing with Envoy, Cilium and BPF</a><span> (</span><a href="https://static.sched.com/hosted_files/kccnceu19/54/Chaos%20Testing%20with%20Envoy%2C%20Cilium%20and%20eBPF.pdf">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=QmmId1QEE5k">Cilium - Bringing the BPF Revolution to Kubernetes Networking and Security</a><span> (</span><a href="https://www.slideshare.net/ThomasGraf5/cilium-bringing-the-bpf-revolution-to-kubernetes-networking-and-security">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=_Iq1xxNZOAo">How to Make Linux Microservice-Aware with eBPF</a><span> (</span><a href="https://www.slideshare.net/InfoQ/how-to-make-linux-microserviceaware-with-cilium-and-ebpf">Slides</a><span>)</span></li><li><a href="https://www.youtube.com/watch?v=ER9eIXL2_14">Accelerating Envoy with the Linux Kernel</a></li><li><a href="https://www.youtube.com/watch?v=ilKlmTDdFgk">Cilium - Network and Application Security with BPF and XDP</a><span> (</span><a href="https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp">Slides</a><span>)</span></li></ul><h4>Hubble</h4><ul><li><a href="https://static.sched.com/hosted_files/kccnceu20/1b/Aug19-Hubble-eBPF_Based_Observability_for_Kubernetes_Sebastian_Wicki.pdf">Hubble - eBPF Based Observability for Kubernetes</a></li></ul><h3>Books</h3><ul><li><a href="https://isovalent.com/data/liz-rice-what-is-ebpf.pdf">What is eBPF?</a></li><li><a href="http://www.brendangregg.com/systems-performance-2nd-edition-book.html">Systems Performance: Enterprise and the Cloud, 2nd Edition</a></li><li><a href="http://www.brendangregg.com/bpf-performance-tools-book.html">BPF Performance Tools</a></li><li><a href="https://www.oreilly.com/library/view/linux-observability-with/9781492050193/">Linux Observability with BPF</a></li></ul><h3>Articles &amp; Blogs</h3><ul><li><a href="https://lwn.net/Articles/790684/">BPF for security - and chaos - in Kubernetes</a></li><li><a href="https://thenewstack.io/linux-technology-for-the-new-year-ebpf/">Linux Technology for the New Year: eBPF</a></li><li><a href="https://lwn.net/Articles/740157/">A thorough introduction to eBPF</a></li><li><a href="https://opensource.googleblog.com/2016/11/cilium-networking-and-security.html">Cilium, BPF and XDP</a></li><li><a href="https://lwn.net/Kernel/Index/#Berkeley_Packet_Filter">Archive of various articles on BPF</a></li><li><a href="https://blog.cloudflare.com/tag/ebpf/">Various articles on BPF by Cloudflare</a></li><li><a href="https://facebookmicrosites.github.io/bpf/blog/">Various articles on BPF by Facebook</a></li></ul></div></div>
  </body>
</html>
