<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ifesunmola.com/how-to-use-the-foreign-function-api-in-java-22-to-call-c-libraries/">Original</a>
    <h1>How to Use the Foreign Function API in Java 22 to Call C Libraries</h1>
    
    <div id="readability-page-1" class="page"><p>This article explains how to call C libraries like fopen, fgets, and fclose from Java.</p><article id="markdown-content"><h2 id="introduction">Introduction</h2>
<p>Before the release of Java 22, the usual way to call foreign functions was with the Java
Native Interface (JNI). Anyone who has used (or tried to use) JNI would agree that it was
very easy to shoot yourself in the foot and accidentally shoot someone else in the foot
while the first shooting was still happening.</p>
<p>Iâ€™m not going to dive into how easy it is to mess up, but I will say this: To use JNI, you
have to write C code. Let me rephrase that: for developers that have been pampered with
garbage collection and safety to use JNI, they had to write C code. What could go wrong?
There are other solutions built on JNI where you donâ€™t have to write the C bindings
manually, but â€¦ meh.</p>
<p>Iâ€™ll admit that JNI is very powerful. But what if we didnâ€™t have to write C code, like the
way itâ€™s done in other languages? Enter the star of todayâ€™s writing: Foreign Function and
Memory (FFM) API from the <code>java.lang.foreign</code> package.</p>
<p>This article will review how to read the contents of a file using fopen, fclose and fgets
from the C standard library. This might get long and technical, so buckle up!</p>
<blockquote>
<p>Using the FFM API to call regular functions that already exist in the Java
standard library makes no sense because there will always be an overhead. The API is best
used for libraries that cannot be rewritten in Java. I chose functions from the C standard
library because itâ€™s available to almost everyone.</p>
</blockquote>
<h2 id="setting-up-libc-class-and-fopen">Setting up LibC class and fopen</h2>
<p>The Java language architects made the API as open as possible. Aside from the code that
relates to foreign functions, thereâ€™s almost no abstraction. So, a little bit of setup is
required to get going. My guess is that they didnâ€™t want to constrain developers too much.</p>
<p>In a file named <code>LibC.java</code>:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>import</span> java.lang.foreign.*;
</span></span><span><span>
</span></span><span><span><span>class</span> <span>LibC</span> {
</span></span><span><span>	<span>private</span> <span>final</span> Arena allocator;
</span></span><span><span>	Linker linker <span>=</span> Linker.<span>nativeLinker</span>();
</span></span><span><span>	SymbolLookup lib <span>=</span> linker.<span>defaultLookup</span>();
</span></span><span><span>
</span></span><span><span>	LibC(Arena arena) {
</span></span><span><span>		<span>this</span>.<span>allocator</span> <span>=</span> arena;
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><ol>
<li>
<p>Think of an <code>Arena</code> as an allocator. It is how memory is allocated and freed. If the
arena is closed, all the memory allocated through it is freed. Youâ€™ll see more of
it when we get the main method.</p>
</li>
<li>
<p><code>Linker.nativeLinker()</code> simply â€¦ gets the native linker.</p>
</li>
<li>
<p><code>linker.defaultLookup()</code> implicitly loads all the common libraries that
are typically present on PCs. <code>libc</code> - the C standard library is one of them.</p>
</li>
</ol>
<p>To set up <code>fopen</code>, add the following below <code>SymbolLookup lib = linker.defaultLookup();</code>:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>// Required Imports</span>
</span></span><span><span><span>import static</span> java.lang.foreign.ValueLayout.*;
</span></span><span><span><span>import</span> java.lang.invoke.MethodHandle;
</span></span><span><span><span>// End imports</span>
</span></span><span><span>
</span></span><span><span>MemorySegment fopenAddress <span>=</span> lib.<span>find</span>(<span>&#34;fopen&#34;</span>).<span>orElseThrow</span>();
</span></span><span><span><span>//FILE *fopen(const char *filename, const char *mode)</span>
</span></span><span><span>FunctionDescriptor fopenDesc <span>=</span>
</span></span><span><span>		FunctionDescriptor.<span>of</span>(ADDRESS, ADDRESS, ADDRESS);
</span></span><span><span>MethodHandle fopen <span>=</span> linker.<span>downcallHandle</span>(fopenAddress, fopenDesc);
</span></span></code></pre></div><blockquote>
<p>The above code perfectly shows my love/hate relationship with Java. Itâ€™s verbose, lots
of typing, I even had to skip the use of <code>private final</code> because it would get too long.
But sometimes, it also makes sense. I mean â€¦ could it get any more descriptive
than naming something <code>FunctionDescriptor</code>? Sure you could use FuncDescriptor or
FuncDesc or be like go programmers and name it fd (please donâ€™t fight me).</p>
</blockquote>
<p>I donâ€™t know about you but that looks scary. Letâ€™s break it down:</p>
<ol>
<li>
<p><code>MemorySegment</code></p>
<ul>
<li>Think of this as the equivalent of a C pointer. Anytime a C function
returns a pointer, or takes in a pointer argument <code>MemorySegment</code> is used to
represent it in java code.</li>
</ul>
</li>
<li>
<p><code>lib.find(&#34;fopen&#34;).orElseThrow()</code>:</p>
<ul>
<li>Recall that <code>lib</code> contains all the common libraries that are typically found on a
PC, and the C standard library is one of them.</li>
<li>The code finds the address (pointer) of where <code>fopen</code> is stored, and returns it,
or throws an exception if it wasnâ€™t found.</li>
</ul>
</li>
<li>
<p><code>FunctionDescriptor.of(ADDRESS, ADDRESS, ADDRESS)</code>:</p>
<ul>
<li>The code is exactly what it sounds like. It describes the signature of <code>fopen</code></li>
<li>The first argument is the return type of <code>fopen</code> - A memory address</li>
<li>The 2nd and 3rd (and subsequent) arguments are the parameters. Theyâ€™re all memory
addresses.</li>
<li>Thereâ€™s also a <code>FunctionDescriptor.ofVoid()</code> that only allows parameters, and
returns void</li>
</ul>
</li>
<li>
<p><code>MethodHandle fopen = linker.downcallHandle(fopenAddress, fopenDesc)</code></p>
<ul>
<li>This basically creates a way to actually call the function.</li>
<li>In general, it is used to call a foreign function in any language.</li>
</ul>
</li>
</ol>
<p>Any bindings you create will typically follow the same pattern: Find the library, describe
the function, create a way to call it from java.</p>
<p>With that, we can create method to publicly access it. Below the <code>LibC</code> constructor:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span>MemorySegment <span>fopen</span>(String filePath, String mode) {
</span></span><span><span>	MemorySegment pathPtr <span>=</span> allocator.<span>allocateFrom</span>(filePath);
</span></span><span><span>	MemorySegment modePtr <span>=</span> allocator.<span>allocateFrom</span>(mode);
</span></span><span><span>
</span></span><span><span>	<span>try</span> {
</span></span><span><span>		<span>return</span> (MemorySegment) fopen.<span>invoke</span>(pathPtr, modePtr);
</span></span><span><span>	}
</span></span><span><span>	<span>catch</span> (Throwable e) {
</span></span><span><span>		<span>return</span> MemorySegment.<span>NULL</span>;
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><blockquote>
<p>Note that type inference (kinda) has been around since Java 10. Iâ€™m explicitly
using the types for clarity.</p>
</blockquote>
<p>There are some new things, letâ€™s address them:</p>
<ol>
<li><code>MemorySegment pathPtr = allocator.allocateFrom(filePath)</code>:
<ul>
<li>Weâ€™ve seen MemorySegment before. Itâ€™s a pointer.</li>
<li><code>allocator.allocateFrom(filePath)</code> creates a pointer from the file path string</li>
<li>modePtr also follows the same pattern</li>
</ul>
</li>
<li><code>return (MemorySegment) fopen.invoke(pathPtr, modePtr);</code>
<ul>
<li>Recall the signature (and FunctionDescriptor)
of fopen: <code>FILE *fopen(const char *filename, const char *mode)</code>. It returns a
pointer, and takes in 2 pointers as its parameter.</li>
<li><code>fopen.invoke()</code> comes from the <code>MethodHandle</code> we created above. It invokes the
foreign function, and returns an Object, so we need to cast to the described return
type - an address i.e a <code>MemorySegment</code></li>
<li>There are several things that could go wrong, so <code>.invoke()</code> throws a <code>Throwable</code> -
the super class of all errors and exceptions.</li>
<li>Returning <code>NULL</code> is not the best way to handle an exception like this, but letâ€™s
keep it simple.</li>
</ul>
</li>
</ol>
<h2 id="more-on-arenas">More on Arenas</h2>
<p>As mentioned earlier, an arena is like an allocator.</p>
<p>There are some edge cases but most of the time, every memory you create in C has to be
linked to an arena in Java. Even if you use malloc to allocate memory and get a
MemorySegment back, before you use it, you have to link it to an arena, and in that same
process of linking, you have to pass a <code>Consumer</code> that would free the memory segment. If
you really need the memory without a Consumer to free it (not sure why), thereâ€™s a way to
do that too.</p>
<p>Hereâ€™s a really simple example:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>// Assume we&#39;ve setup a LibC class that that DOESN&#39;T take an </span>
</span></span><span><span><span>// Arena as a constructor parameter. It contains both malloc and</span>
</span></span><span><span><span>// free methods. In a main method: </span>
</span></span><span><span><span>var</span> libc <span>=</span> <span>new</span> LibC();
</span></span><span><span>MemorySegment mallocedMem <span>=</span> libc.<span>malloc</span>(20); <span>// allocate 20 bytes</span>
</span></span><span><span>
</span></span><span><span><span>// outputs 0, we can&#39;t use it yet! An exception will be thrown </span>
</span></span><span><span><span>// if we work with it.</span>
</span></span><span><span>System.<span>out</span>.<span>println</span>(mallocedMem.<span>byteSize</span>());
</span></span><span><span>mallocedMem.<span>getString</span>(0); <span>// IndexOutOfBoundsException</span>
</span></span></code></pre></div><p>To be able to actually use it, we need something like this:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>try</span> (Arena allocator <span>=</span> Arena.<span>ofConfined</span>()) {
</span></span><span><span>   <span>// We could use the arena in the malloc call method but for</span>
</span></span><span><span>   <span>// demonstration purposes, our library still doesn&#39;t have access to it.</span>
</span></span><span><span>   <span>var</span> libc <span>=</span> <span>new</span> LibCTest();
</span></span><span><span>   
</span></span><span><span>   <span>// Size will be allocated later. For now, just get a reference</span>
</span></span><span><span>   MemorySegment mallocedMem <span>=</span> libc.<span>malloc</span>();
</span></span><span><span>   System.<span>out</span>.<span>println</span>(<span>&#34;Address: &#34;</span> <span>+</span> mallocedMem);
</span></span><span><span>   
</span></span><span><span>   Consumer<span>&lt;</span>MemorySegment<span>&gt;</span> cleanup <span>=</span> libc::free;
</span></span><span><span>   
</span></span><span><span>   <span>// cleanup is called after the allocator is closed</span>
</span></span><span><span>   mallocedMem <span>=</span> mallocedMem.<span>reinterpret</span>(20, allocator, cleanup);
</span></span><span><span>   <span>// Same address as above, but with different size</span>
</span></span><span><span>   System.<span>out</span>.<span>println</span>(<span>&#34;Address &#34;</span> <span>+</span> mallocedMem);
</span></span><span><span>   System.<span>out</span>.<span>println</span>(mallocedMem.<span>getString</span>(0)); <span>// prints empty string</span>
</span></span><span><span>}
</span></span><span><span><span>// allocator closed here, mallocedMem is freed</span>
</span></span></code></pre></div><p>I think itâ€™s a nice way to make sure we can use C and not inherit the memory issues.</p>
<h2 id="mainrunner-class">Main/Runner class</h2>
<p>Create a file named file.txt and put some text in it. Iâ€™m not saying you should use this
text, but itâ€™ll be cool if you did:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>What is that thing?
</span></span><span><span>This is Appa, my flying bison.
</span></span><span><span>Right, and this is Katara, my flying sister.
</span></span></code></pre></div><p>In a file named Runner.java:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>import</span> java.lang.foreign.*;
</span></span><span><span><span>// we have to run with java 22 so we might as well use the </span>
</span></span><span><span><span>// unnamed classes preview feature. Your IDE might yell at </span>
</span></span><span><span><span>// you and ask to enable preview features.</span>
</span></span><span><span><span>void</span> <span>main</span>() {
</span></span><span><span>	<span>try</span> (Arena allocator <span>=</span> Arena.<span>ofConfined</span>()) {
</span></span><span><span>		<span>var</span> libc <span>=</span> <span>new</span> LibC(allocator);
</span></span><span><span>
</span></span><span><span>		MemorySegment filePtr <span>=</span> libc.<span>fopen</span>(<span>&#34;file.txt&#34;</span>, <span>&#34;r&#34;</span>);
</span></span><span><span>		<span>if</span> (filePtr.<span>equals</span>(MemorySegment.<span>NULL</span>)) {
</span></span><span><span>			System.<span>out</span>.<span>println</span>(<span>&#34;File could not be opened or invoke call failed&#34;</span>);
</span></span><span><span>			<span>return</span>;
</span></span><span><span>		}
</span></span><span><span>		System.<span>out</span>.<span>println</span>(<span>&#34;File opened successfully&#34;</span>);
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>If you run with <code>java --enable-preview --source 22 Runner.java</code> You should see the success
message or an error message if you change to a file that doesnâ€™t exist â€¦ and some
warnings. Those warnings are there to remind you that you are using methods that
might cause the JVM to crash.</p>
<h2 id="adding-fgets-and-fclose">Adding fgets and fclose</h2>
<p>As mentioned earlier, the steps to add more libraries are the same, so I wonâ€™t go over
already discussed terminologies. Just after the <code>MethodHandle</code> for fopen, add the
following:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>//char *fgets(char *str, int n, FILE *stream)</span>
</span></span><span><span>MemorySegment fgetsAddress <span>=</span> lib.<span>find</span>(<span>&#34;fgets&#34;</span>).<span>orElseThrow</span>();
</span></span><span><span>FunctionDescriptor fgetsDesc <span>=</span>
</span></span><span><span>		FunctionDescriptor.<span>of</span>(ADDRESS, ADDRESS, JAVA_INT, ADDRESS);
</span></span><span><span>MethodHandle fgets <span>=</span> linker.<span>downcallHandle</span>(fgetsAddress, fgetsDesc);
</span></span><span><span>
</span></span><span><span><span>//int fclose(FILE *stream)</span>
</span></span><span><span>MemorySegment fcloseAddress <span>=</span> lib.<span>find</span>(<span>&#34;fclose&#34;</span>).<span>orElseThrow</span>();
</span></span><span><span>FunctionDescriptor fcloseDesc <span>=</span>
</span></span><span><span>		FunctionDescriptor.<span>of</span>(JAVA_INT, ADDRESS);
</span></span><span><span>MethodHandle fclose <span>=</span> linker.<span>downcallHandle</span>(fcloseAddress, fcloseDesc);
</span></span></code></pre></div><p>The only unfamiliar code above should be the FunctionDescriptor. For <code>fgetsDesc</code>, weâ€™re
saying fgets returns an (address) pointer, takes a pointer, an int, and another pointer.</p>
<p>For <code>fcloseDesc</code>, weâ€™re saying fclose returns an int, and takes an address</p>
<blockquote>
<p>To be safer, you could use interfaces to differentiate between a C FILE* and a generic
MemorySegment</p>
</blockquote>
<p>And for the methods to publicly access them, add the following
below <code>MemorySegment fopen(String, String)</code>:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span>MemorySegment <span>fgets</span>(MemorySegment buffer, <span>int</span> size, MemorySegment filePtr) {
</span></span><span><span>	<span>try</span> {
</span></span><span><span>		<span>return</span> (MemorySegment) fgets.<span>invoke</span>(buffer, size, filePtr);
</span></span><span><span>	}
</span></span><span><span>	<span>catch</span> (Throwable e) {
</span></span><span><span>		<span>return</span> MemorySegment.<span>NULL</span>;
</span></span><span><span>	}
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span> <span>fclose</span>(MemorySegment filePtr) {
</span></span><span><span>	<span>try</span> {
</span></span><span><span>		<span>return</span> (<span>int</span>) fclose.<span>invoke</span>(filePtr);
</span></span><span><span>	}
</span></span><span><span>	<span>catch</span> (Throwable e) {
</span></span><span><span>		<span>return</span> <span>-</span>1;
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Nothing unfamiliar here either. In fclose, instead of casting to a <code>MemorySegment</code>, we
cast to an int because in the <code>FunctionDescriptor</code>, we said we expect an int as a result.</p>
<p>And finally, in the main method, replace <code>System.out.println(&#34;File opened ...</code> with:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span>MemorySegment buffer <span>=</span> allocator.<span>allocate</span>(100); <span>// allocate 100 bytes</span>
</span></span><span><span>MemorySegment result;
</span></span><span><span><span>for</span> (; ; ) {
</span></span><span><span>   result <span>=</span> libc.<span>fgets</span>(buffer, 100, filePtr);
</span></span><span><span>   <span>if</span> (result.<span>equals</span>(MemorySegment.<span>NULL</span>)) <span>break</span>;
</span></span><span><span>   
</span></span><span><span>   System.<span>out</span>.<span>print</span>(buffer.<span>getString</span>(0));
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>if</span> (libc.<span>fclose</span>(filePtr) <span>!=</span> 0) {
</span></span><span><span>   System.<span>out</span>.<span>println</span>(<span>&#34;File was not closed&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>Again, nothing too unfamiliar here either. Itâ€™s like a java flavoured version of how you
read a file in plain C. The <code>buffer.getString</code> returns the string stored in the buffer
at offset 0. So, if we wanted to print from the 5th character, we would use 5 instead.</p>
<p>If you run again with <code>java --enable-preview --source 22 Runner.java</code>, you should see the file
contents printed out (and the warnings).</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>What are your thoughts on this compared to JNI? Itâ€™s a lot of code but also a much safer
alternative. Iâ€™m also curious as to how it compares performance wise.</p>
<p>Thereâ€™s a tool called <code>jextract</code> (linked below) that can generate foreign function
bindings from header files, and we wonâ€™t have to do all the work we did
above so the lots of code issue isnâ€™t really an issue. I decided not to use jextract at
all in this article because itâ€™ll be like learning java multithreading without learning
Java.</p>
<p>Maybe Iâ€™ll write on how to use jextract with something like SDL2 or LLVM? Or a
machine learning library? It most likely wonâ€™t be as straightforward as simply calling
jextract with some header files, but weâ€™ll see ðŸ™‚</p>
<h2 id="references">References</h2>
<ul>
<li>
<a href="https://docs.oracle.com/en/java/javase/21/core/foreign-function-and-memory-api.html" target="_blank">https://docs.oracle.com/en/java/javase/21/core/foreign-function-and-memory-api.html
</a></li>
<li>
<a href="https://github.com/openjdk/jextract" target="_blank">https://github.com/openjdk/jextract
</a></li>
<li>
<a href="https://jdk.java.net/jextract/" target="_blank">https://jdk.java.net/jextract/
</a></li>
<li>
<a href="https://www.youtube.com/watch?v=iwmVbeiA42E&amp;t=1613s" target="_blank">
  (YouTube) Foreign Function &amp; Memory API - A (Quick) Peek Under the Hood
  
</a></li>
<li>
<a href="https://youtu.be/AjjAZsnRXtE?t=2686" target="_blank">
  (YouTube) Java 22 Launch Stream with Jorn Vernee and Per Ake Minborg
  
</a></li>
<li>
<a href="https://news.ycombinator.com/item?id=34580907#34586552" target="_blank">https://news.ycombinator.com/item?id=34580907#34586552
</a></li>
</ul>
<h2 id="source-code">Source Code</h2>
<p>Run with java 22+ : <code>java --enable-preview --source 22 Runner.java</code></p>
<ul>
<li>
<a href="https://ifesunmola.com/using-java-foreign-function-api-to-call-c-libraries/LibC.java">
  LibC.java
  
</a></li>
<li>
<a href="https://ifesunmola.com/using-java-foreign-function-api-to-call-c-libraries/Runner.java">
  Runner.java
  
</a></li>
<li>
<a href="https://ifesunmola.com/using-java-foreign-function-api-to-call-c-libraries/file.txt">
  file.txt
  
</a></li>
</ul>
<p>Read next:

<a href="https://ifesunmola.com/sum-types-in-java">
Sum types in Java

</a></p>

</article></div>
  </body>
</html>
