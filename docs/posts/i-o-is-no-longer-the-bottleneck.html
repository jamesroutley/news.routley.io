<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benhoyt.com/writings/io-is-no-longer-the-bottleneck/">Original</a>
    <h1>I/O is no longer the bottleneck</h1>
    
    <div id="readability-page-1" class="page"><div id="container">



<div id="content">

<p>November 2022</p>

<p>When interviewing programmers, I often ask them to code a simple program to count word frequencies in a text file. It’s a good problem that tests a bunch of skills, and with some follow-up questions, allows you to go surprisingly deep.</p>

<p>One of the follow-up questions I ask is, “What’s the performance bottleneck in your program?” Most people say something like “reading from the input file”.</p>

<p>In fact, I was inspired to write this article after responding to someone on Gopher Slack, who said, “I also note there’s a lot of extra work happening here in splitting the entire line, etc, it’s just that typically this is all so much faster than I/O that we don’t care.”</p>

<p>I’m not picking on him … before I <a href="https://benhoyt.com/writings/count-words/">analyzed the performance</a> of the count-words problem, I thought the same. It’s what we’ve all been taught, right? “I/O is slow.”</p>

<p>Not anymore! Disk I/O may have been slow 10 or 20 years ago, but in 2022, <strong>reading a file sequentially from disk is very fast.</strong></p>

<p>Just how fast? I tested the read and write speed of my development laptop using <a href="https://www.shellhacks.com/disk-speed-test-read-write-hdd-ssd-perfomance-linux/">this method</a> but with <code>count=4096</code> so we’re reading and writing 4GB. Here are the results on my Dell XPS 13 with a Samsung PM9A1 NVMe drive, running Ubuntu 22.04:</p>

<table>
  <thead>
    <tr>
      <th>I/O Type</th>
      <th>Speed (GB/s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Read (not cached)</td>
      <td>1.7</td>
    </tr>
    <tr>
      <td>Read (cached)</td>
      <td>10.8</td>
    </tr>
    <tr>
      <td>Write (incl. sync time)</td>
      <td>1.2</td>
    </tr>
    <tr>
      <td>Write (not incl. sync)</td>
      <td>1.6</td>
    </tr>
  </tbody>
</table>

<p>System calls are relatively slow, of course, but when reading or writing sequentially you only have to do one syscall every 4KB, or 64KB, or whatever your buffer size is. And I/O over a network is still slow, especially a non-local network.</p>

<p>So what <em>is</em> the bottleneck in a program that counts word frequencies like the one above? It’s processing or parsing the input and the associated memory allocations: splitting the input into words, converting to lowercase, and counting frequencies with a hash table.</p>

<p>I modified my Python and Go count-words programs to record the times of the various stages of the process: reading the input, processing (the slow part), sorting by most frequent, and outputting. I’m running it on a 413MB text file, so it’s a decent amount of input (100 concatenated copies of the <a href="https://www.gutenberg.org/cache/epub/10/pg10.txt">text of the King James Bible</a>).</p>

<p>Below are the results, in seconds, from the best of 3 runs:</p>

<table>
  <thead>
    <tr>
      <th>Stage</th>
      <th>Python</th>
      <th>Go (simple)</th>
      <th>Go (optimized)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Reading</td>
      <td>0.384</td>
      <td>0.499</td>
      <td>0.154</td>
    </tr>
    <tr>
      <td>Processing</td>
      <td>7.980</td>
      <td>3.492</td>
      <td>2.249</td>
    </tr>
    <tr>
      <td>Sorting</td>
      <td>0.005</td>
      <td>0.002</td>
      <td>0.002</td>
    </tr>
    <tr>
      <td>Outputting</td>
      <td>0.010</td>
      <td>0.009</td>
      <td>0.010</td>
    </tr>
    <tr>
      <td><strong>Total</strong></td>
      <td>8.386</td>
      <td>4.000</td>
      <td>2.414</td>
    </tr>
  </tbody>
</table>

<p>The sorting and outputting is negligible here: because the input is 100 copies, the number of unique words is comparatively low. Side note: this makes another interesting follow-up question in interviews. Some candidates say that sorting is going to be the bottleneck, because it’s O(N log N) rather than the input processing, which is O(N). However, it’s easy to forget we’re dealing with two different N’s: the total number of words in the file, and the number of unique words.</p>

<p>The guts of the <a href="https://github.com/benhoyt/io-performance/blob/master/simple.py">Python version</a> boil down to a few lines of code:</p>

<div><div><pre><code><span>content</span> <span>=</span> <span>sys</span><span>.</span><span>stdin</span><span>.</span><span>read</span><span>()</span>
<span>counts</span> <span>=</span> <span>collections</span><span>.</span><span>Counter</span><span>(</span><span>content</span><span>.</span><span>lower</span><span>().</span><span>split</span><span>())</span>
<span>most_common</span> <span>=</span> <span>counts</span><span>.</span><span>most_common</span><span>()</span>
<span>for</span> <span>word</span><span>,</span> <span>count</span> <span>in</span> <span>most_common</span><span>:</span>
    <span>print</span><span>(</span><span>word</span><span>,</span> <span>count</span><span>)</span>
</code></pre></div></div>

<p>You can easily read line-by-line in Python, but it’s a bit slower, so here I’m just reading the whole file into memory and processing it at once.</p>

<p>The <a href="https://github.com/benhoyt/io-performance/blob/master/simple.go">simple Go version</a> takes the same approach, though Go’s standard library doesn’t have <a href="https://docs.python.org/3/library/collections.html#collections.Counter"><code>collections.Counter</code></a>, so we have to do the “most common” sorting ourselves.</p>

<p>The <a href="https://github.com/benhoyt/io-performance/blob/master/optimized.go">optimized Go version</a> is significantly faster, but also quite a lot more complicated. We’re avoiding most memory allocations by converting to lowercase and splitting on word boundaries <em>in place</em>. That’s a good rule of thumb for optimizing CPU-bound code: reduce memory allocations. See my <a href="https://benhoyt.com/writings/count-words/">count-words optimization article</a> for how to profile this.</p>

<p>I haven’t shown an optimized Python version because it’s hard to optimize Python much further! (I got the time down from 8.4 to 7.5 seconds). It’s as fast as it is because the core operations are happening in C code – that’s why it so often doesn’t matter that “Python is slow”.</p>

<p>As you can see, the disk I/O in the simple Go version takes only 14% of the running time. In the optimized version, we’ve sped up both reading and processing, and the disk I/O takes only 7% of the total.</p>

<p>My conclusion? If you’re processing “big data”, disk I/O probably isn’t the bottleneck. A little bit of measurement will likely point to parsing and memory allocation.</p>

<p>I’d love it if you <a href="https://github.com/sponsors/benhoyt/">sponsored me on GitHub</a> – it will motivate me to work on my open source projects and write more good content. Thanks!</p>


</div>

</div></div>
  </body>
</html>
