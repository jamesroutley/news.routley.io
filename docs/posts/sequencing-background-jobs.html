<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zachahn.com/posts/1733015437">Original</a>
    <h1>Sequencing background jobs</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>I often have to build a sequence of background jobs. For example, I’m working on a personal project where a third party, <a href="https://plaid.com">Plaid</a>, hits a webhook, and the webhook queues a job to pull data from Plaid, then queues another job to parse and save that data. Here’s a diagram of a real example:</p>
<div><pre><code>Plaid
| Notifies server when data is ready
|
--&gt; Webhook
    | Verifies payload and queues the job
    |
    --&gt; TransactionPullJob
        | Pulls data from Plaid
        | Saves the raw data
        | Launches next job when done with location of saved data
        |
        --&gt; TransactionParseJob
            | Parses the saved data
            | Saves the parsed data
</code></pre></div>
<p>I prefer keeping each job small, idempotent, and atomic. It helps keep things each part re-runnable and thus the whole reliable.</p>
<p>But there are tradeoffs. Mainly, since we’re splitting up one task into atomic jobs, it becomes a little harder to see how each job fits into the full task. So I attempted two experiments to see if I could make things a little more readable. (Two for now!) Note that examples here are specific to Rails, but I assume concepts of idempotency as well as maintainability are somewhat consistent between languages and frameworks.</p>
<h2><a href="#checkpoints" aria-hidden="true" id="checkpoints"></a>Checkpoints</h2>
<p>My first attempt was to store intermediary values in a database, basically memoizing each idempotent part of a task, so that I could keep all the logic in one place.</p>
<div><pre><code><span># This is pseudocode!</span>
<span>class</span> <span>TransactionSyncJob</span>
  <span>include</span> <span>Disqualified</span><span>::</span><span>Job</span>
  <span>include</span> <span>Checkpoints</span>

  <span>def</span> <span>perform</span><span>(</span><span>credential_id</span><span>)</span>
    <span>credential</span> <span>=</span> <span>Credential</span><span>.</span><span>find</span><span>(</span><span>credential_id</span><span>)</span>
    <span>cursor</span> <span>=</span> <span>credential</span><span>.</span><span>cursor</span>

    <span># A checkpoint session wraps all of the individual checkpoints. </span>
    <span>checkpoint_session</span><span>(</span><span>&#34;transaction-sync-</span><span>#{</span><span>cursor</span> <span>||</span> <span>&#34;initial&#34;</span><span>}</span><span>&#34;</span><span>)</span> <span>do</span>
      <span># When a `checkpoint` finishes, we save the final value inside the block</span>
      <span># in the database. Every call to `checkpoint` first attempts to retrieve</span>
      <span># a saved run, and otherwise runs the code inside and saves the final</span>
      <span># return value</span>
      <span>batch_id</span> <span>=</span> <span>checkpoint</span><span>(</span><span>step: </span><span>&#34;pull&#34;</span><span>)</span> <span>do</span>
        <span>ApplicationRecord</span><span>.</span><span>transaction</span> <span>do</span>
          <span>batch</span> <span>=</span> <span>PlaidTransactionUpdateBatch</span><span>.</span><span>create!</span><span>(</span>
            <span>credential: </span><span>credential</span>
          <span>)</span>
          <span>has_more</span> <span>=</span> <span>true</span>
          <span>while</span> <span>has_more</span>
            <span>response</span> <span>=</span> <span>Plaid</span><span>.</span><span>transactions</span><span>.</span><span>sync</span><span>(</span><span>credential</span><span>.</span><span>id</span><span>,</span> <span>cursor</span><span>)</span>
            <span>PlaidTransactionUpdatePage</span><span>.</span><span>create!</span><span>(</span>
              <span>plaid_transaction_update_batch: </span><span>batch</span><span>,</span>
              <span>content: </span><span>response</span><span>.</span><span>body</span>
            <span>)</span>
            <span>response_body</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>response</span><span>.</span><span>body</span><span>)</span>
            <span>cursor</span> <span>=</span> <span>response_body</span><span>[</span><span>&#34;cursor&#34;</span><span>]</span>
            <span>has_more</span> <span>=</span> <span>response_body</span><span>[</span><span>&#34;has_more&#34;</span><span>]</span>
          <span>end</span>
          <span>credential</span><span>.</span><span>update!</span><span>(</span><span>cursor: </span><span>cursor</span><span>)</span>
          <span>batch</span><span>.</span><span>id</span>
        <span>end</span>
      <span>end</span>

      <span># Each checkpoint in a session is meant to be idempotent and stable.</span>
      <span># But the variables inside them are not, and thus aren&#39;t accessible.</span>
      <span>checkpoint</span><span>(</span><span>step: </span><span>&#34;parse&#34;</span><span>)</span> <span>do</span>
        <span>ApplicationRecord</span><span>.</span><span>transaction</span> <span>do</span>
          <span>batch</span> <span>=</span> <span>PlaidTransactionUpdateBatch</span><span>.</span><span>find</span><span>(</span><span>batch_id</span><span>)</span>
          <span>next</span> <span>if</span> <span>batch</span><span>.</span><span>processed_at</span>
          <span>pages</span> <span>=</span> <span>batch</span><span>.</span><span>plaid_transaction_update_pages</span><span>.</span><span>order</span><span>(</span><span>id: :asc</span><span>)</span>
          <span>pages</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>page</span><span>|</span>
            <span>transactions</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>page</span><span>.</span><span>content</span><span>)[</span><span>&#34;transactions&#34;</span><span>]</span>
            <span>transactions</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>txn</span><span>|</span>
              <span>Transaction</span><span>.</span><span>create!</span><span>(</span>
                <span>plaid_id: </span><span>txn</span><span>.</span><span>fetch</span><span>(</span><span>&#34;id&#34;</span><span>),</span>
                <span># ...</span>
              <span>)</span>
            <span>end</span>
          <span>end</span>
          <span>batch</span><span>.</span><span>update!</span><span>(</span><span>processed_at: </span><span>Time</span><span>.</span><span>now</span><span>)</span>
        <span>end</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div>
<p>It’s kinda nice seeing the entire task in one place. This gives us the diagram below.</p>
<div><pre><code>Plaid
| Notifies server when data is ready
|
--&gt; Webhook
    | Verifies payload and queues the job
    |
    --&gt; TransactionSyncJob
        | Pulls data from Plaid
        | Saves the raw data
        | Parses the saved data
        | Saves the parsed data
</code></pre></div>
<p>I think there are a few downsides to this solution though. Mostly that this one job is now really long, and it’s a little annoying to wrap each ACID transaction with a checkpoint.</p>
<h2><a href="#disqualified-sequence" aria-hidden="true" id="disqualified-sequence"></a>Disqualified Sequence</h2>
<p><a href="https://github.com/zachahn/disqualified/issues/4">I had this idea</a> to create a feature in my background job framework that allows for queuing sequential jobs at once rather than needing to chain them. I built it out and tested it on this worker</p>
<div><pre><code><span>class</span> <span>TransactionSyncJob</span>
  <span>include</span> <span>Disqualified</span><span>::</span><span>Job</span>

  <span>def</span> <span>perform</span><span>(</span><span>credential_id</span><span>)</span>
    <span># The main difference between this and the first example is that we need</span>
    <span># to tell the the second job the results of the first job before the first</span>
    <span># job even starts to run.</span>
    <span>batch_uuid</span> <span>=</span> <span>SecureRandom</span><span>.</span><span>uuid</span>
    <span>Disqualified</span><span>::</span><span>Sequence</span><span>.</span><span>queue</span> <span>do</span>
      <span>TransactionSyncPullJob</span><span>.</span><span>perform_async</span><span>(</span><span>credential_id</span><span>,</span> <span>batch_uuid</span><span>)</span>
      <span>TransactionSyncParseJob</span><span>.</span><span>perform_async</span><span>(</span><span>credential_id</span><span>,</span> <span>batch_uuid</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span>

<span># I copied most of this from the first example</span>
<span>class</span> <span>TransactionSyncPullJob</span>
  <span>include</span> <span>Disqualified</span><span>::</span><span>Job</span>

  <span>def</span> <span>perform</span><span>(</span><span>credential_id</span><span>,</span> <span>batch_uuid</span><span>)</span>
    <span>credential</span> <span>=</span> <span>Credential</span><span>.</span><span>find</span><span>(</span><span>credential_id</span><span>)</span>
    <span>cursor</span> <span>=</span> <span>credential</span><span>.</span><span>cursor</span>

    <span>ApplicationRecord</span><span>.</span><span>transaction</span> <span>do</span>
      <span>batch</span> <span>=</span> <span>PlaidTransactionUpdateBatch</span><span>.</span><span>create!</span><span>(</span>
        <span>uuid: </span><span>batch_uuid</span><span>,</span>
        <span>credential: </span><span>credential</span>
      <span>)</span>
      <span>has_more</span> <span>=</span> <span>true</span>
      <span>while</span> <span>has_more</span>
        <span>response</span> <span>=</span> <span>Plaid</span><span>.</span><span>transactions</span><span>.</span><span>sync</span><span>(</span><span>credential</span><span>.</span><span>id</span><span>,</span> <span>cursor</span><span>)</span>
        <span>PlaidTransactionUpdatePage</span><span>.</span><span>create!</span><span>(</span>
          <span>plaid_transaction_update_batch: </span><span>batch</span><span>,</span>
          <span>content: </span><span>response</span><span>.</span><span>body</span>
        <span>)</span>
        <span>response_body</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>response</span><span>.</span><span>body</span><span>)</span>
        <span>cursor</span> <span>=</span> <span>response_body</span><span>[</span><span>&#34;cursor&#34;</span><span>]</span>
        <span>has_more</span> <span>=</span> <span>response_body</span><span>[</span><span>&#34;has_more&#34;</span><span>]</span>
      <span>end</span>
      <span>credential</span><span>.</span><span>update!</span><span>(</span><span>cursor: </span><span>cursor</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span>

<span># I copied most of this from the first example too</span>
<span>class</span> <span>TransactionSyncParseJob</span>
  <span>include</span> <span>Disqualified</span><span>::</span><span>Job</span>

  <span>def</span> <span>perform</span><span>(</span><span>credential_id</span><span>,</span> <span>batch_uuid</span><span>)</span>
    <span>ApplicationRecord</span><span>.</span><span>transaction</span> <span>do</span>
      <span>batch</span> <span>=</span> <span>PlaidTransactionUpdateBatch</span><span>.</span><span>find_by!</span><span>(</span><span>uuid: </span><span>batch_uuid</span><span>)</span>
      <span>next</span> <span>if</span> <span>batch</span><span>.</span><span>processed_at</span>
      <span>pages</span> <span>=</span> <span>batch</span><span>.</span><span>plaid_transaction_update_pages</span><span>.</span><span>order</span><span>(</span><span>id: :asc</span><span>)</span>
      <span>pages</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>page</span><span>|</span>
        <span>transactions</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>page</span><span>.</span><span>content</span><span>)[</span><span>&#34;transactions&#34;</span><span>]</span>
        <span>transactions</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>txn</span><span>|</span>
          <span>Transaction</span><span>.</span><span>create!</span><span>(</span>
            <span>plaid_id: </span><span>txn</span><span>.</span><span>fetch</span><span>(</span><span>&#34;id&#34;</span><span>),</span>
            <span># ...</span>
          <span>)</span>
        <span>end</span>
      <span>end</span>
      <span>batch</span><span>.</span><span>update!</span><span>(</span><span>processed_at: </span><span>Time</span><span>.</span><span>now</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div>
<p>I’m pretty happy with this solution. It’s honestly pretty similar to the original state of things (prior to checkpoints), but it feels a little more cohesive since we’re able to see all the queued jobs in one place. This gives us the following diagram.</p>
<div><pre><code>Plaid
| Notifies server when data is ready
|
--&gt; Webhook
    | Verifies payload and queues the job
    |
    --&gt; TransactionSyncJob
        | Queues the following jobs in a Sequence
        |
        --&gt; TransactionSyncPullJob
        |   | Pulls data from Plaid
        |   | Saves the raw data
        |
        --&gt; TransactionSyncParseJob
            | Parses the saved data
            | Saves the parsed data
</code></pre></div>
<p>All things considered, I’m pretty happy with <code>Disqualified::Sequence</code>. I plan on releasing it soon.</p>
<p><em>These are my thoughts! Not my employer’s.</em></p>

    </div></div>
  </body>
</html>
