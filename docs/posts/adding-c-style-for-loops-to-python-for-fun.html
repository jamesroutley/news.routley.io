<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sadh.life/post/cursed-for/">Original</a>
    <h1>Adding C-style for loops to Python for fun</h1>
    
    <div id="readability-page-1" class="page"><article>
    <main>
      <p>It&#39;s true. It turns out you can, in fact, add C-style for loops into Python. The
way to get there however, was long and painful all the way to the end.</p><p>Regardless, I&#39;ve learned many things (some of which I hope nobody <em>ever</em> uses in
production), and I&#39;m here to share with you all the gruesome details. I hope you
find it helpful (or at the very least, entertaining).</p><h2 id="the-path-to-get-there">The Path to get there</h2><p>I had to try 3 different approaches in order to finally get to the image that
you see at the top. And hence, I&#39;ve sectioned the blog into 3 parts:</p><ul>
<li>Part 1: The &#34;simple&#34; implementation</li>
<li>Part 2: Making our own language inside Python</li>
<li>Part 3: The &#34;Truly Cursed&#34; way</li>
</ul><p>But before all of that, let&#39;s answer the big question: &#34;why?&#34;.</p><h2 id="part-0-the-beginning">Part 0: The beginning</h2><p>In the beginning, I had a dumb idea:</p><blockquote>
<p><em>&#34;Can I possibly put the 3-statement for-loop from C into Python?&#34;</em></p>
</blockquote><p>I mocked up an idea that I thought I could make, and posted it on
<a href="https://twitter.com/sadhlife/status/1497501076589019139">twitter</a>:</p><p><img src="https://user-images.githubusercontent.com/43412083/173145281-1a63ad93-56c0-4fd0-b8f1-78e7bf7005d6.png" alt="The mockup snippet"/></p><p>... and immediately, I got some intriguing reactions:</p><p><img src="https://user-images.githubusercontent.com/43412083/183288619-4d5531fa-b7bc-46a1-9168-1464dc94a7d6.png" alt="Twitter response 1"/></p><p><img src="https://user-images.githubusercontent.com/43412083/183288864-1cae2530-3fa2-478d-8a1e-d70eda401019.png" alt="Twitter response 2"/></p><p><img src="https://user-images.githubusercontent.com/43412083/183288703-b4360ea9-7c69-4109-b63b-0e18bfa5dcc6.png" alt="Twitter response 3"/></p><p>So I decided it&#39;d be worthwhile to try and make this a reality. Simple as that.</p><h2 id="part-1-the-simple-implementation">Part 1: The &#34;simple&#34; implementation</h2><p>I wanted it to look like a regular for-loop from C as much as possible:</p><pre><code><span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>printf</span><span>(</span><span>&#34;%d&#34;</span><span>,</span> i<span>)</span><span>;</span>
<span>}</span></code></pre><p>But there&#39;s a couple big problems:</p><ul>
<li>
<p>The builtin <code>for</code> syntax requires you to have an <code>in</code> clause:</p>
<pre><code><span>for</span> <span>&lt;</span>variable<span>&gt;</span> <span>in</span> <span>&lt;</span>some expression that gives an iterable<span>&gt;</span><span>:</span>
    <span>.</span><span>.</span><span>.</span></code></pre>
<p>Which is pretty restrictive. So our second best bet is to implement a function
instead -- one that takes in three arguments. I went with <code>_for(x, y, z)</code>.</p>
<p>For the <code>for</code> to be a block, I needed a generic block kind of statement, one
that allows us to put arbitrary code inside it: so I chose a <code>with</code> block:
<code>with</code> blocks can be customized with <code>__enter__</code> and <code>__exit__</code>.</p>
</li>
<li>
<p>The second problem is much bigger: The original <code>for</code> loop syntax takes in
<strong>statements</strong>. Notice that <code>int i = 0</code> and <code>i++</code> are statements, ones which
declare and assign a variable respectively.</p>
<p>Whereas, Python functions take in &#34;expressions&#34;, things that return a value.
This one is much harder to hack in, but I have one idea to save the day:</p>
<p>We need to do assignment, but we are limited to expressions. Hmmm... where
have I heard of this before... oh right. <strong>Assignment expressions.</strong></p>
<p>Python 3.8 has come to save the day. Let&#39;s try it out.</p>
</li>
</ul><p>Hence, I started with this rough idea:</p><pre><code><span>with</span> _for<span>(</span>i <span>:=</span> var<span>(</span><span>0</span><span>)</span><span>,</span> i <span>&lt;</span> <span>10</span><span>,</span> i <span>+</span> <span>2</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>i<span>)</span></code></pre><blockquote>
<p>Yeah, it&#39;s not the greatest syntax of all time, but you have to be confined to
Python syntax when writing Python (... or so I thought, more on that later).</p>
</blockquote><p>The first argument <code>i := var(0)</code> is what will initialise our <code>i</code> variable. But,
it is no ordinary variable, mind you. For the second and third argument to work,
<code>i &lt; 10</code> and <code>i + 2</code> should <em>behave</em> as the condition and increment part of the
for loop. Thankfully, By overriding functions like <code>__lt__</code> and <code>__add__</code>, we
can customize how this <code>i</code> variable behaves when we do these comparisons and
additions.</p><p>Now, all that&#39;s left is to implement this <code>_for</code> and <code>var</code> thing.</p><h3 id="implementing-var">Implementing <code>var</code></h3><p>We want <code>var</code> to be able to do these 3 things at least:</p><ul>
<li>Support storing a value inside it when initializing, i.e. <code>var(0)</code>.</li>
<li>Support creating conditions with comparisons: <code>i &lt; 10</code> should return a
&#34;conditional&#34; type, which we will use later.</li>
<li>Support creating the &#34;increment&#34;, i.e. <code>i + 2</code> should return an &#34;increment&#34;
type, which we will also use later.</li>
</ul><p>So I started with a simple <code>var</code> class:</p><pre><code><span>class</span> <span>var</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> value<span>)</span> <span>-</span><span>&gt;</span> <span>None</span><span>:</span>
        self<span>.</span>value <span>=</span> value

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>
        <span>return</span> <span>repr</span><span>(</span>self<span>.</span>value<span>)</span>


i <span>=</span> var<span>(</span><span>0</span><span>)</span>
<span>print</span><span>(</span>i<span>)</span>  </code></pre><p>I then added comparison support, by making a <code>_Comparison</code> type, and
implementing <code>__lt__</code>, such that doing <code>i &lt; something</code> stores that information:</p><pre><code><span>class</span> <span>_Comparison</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> var<span>,</span> op<span>,</span> value<span>)</span><span>:</span>
        self<span>.</span>var <span>=</span> var
        self<span>.</span>op <span>=</span> op
        self<span>.</span>value <span>=</span> value

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>
        <span>return</span> <span><span>f&#34;Comparing var(</span><span><span>{</span>self<span>.</span>var<span>!r</span><span>}</span></span><span>) </span><span><span>{</span>self<span>.</span>op<span>}</span></span><span> </span><span><span>{</span>self<span>.</span>value<span>!r</span><span>}</span></span><span>&#34;</span></span>


<span>class</span> <span>var</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        self<span>.</span>value <span>=</span> value

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>
        <span>return</span> <span>repr</span><span>(</span>self<span>.</span>value<span>)</span>

    <span>def</span> <span>__lt__</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        <span>return</span> _Comparison<span>(</span>var<span>=</span>self<span>,</span> op<span>=</span><span>&#34;&lt;&#34;</span><span>,</span> value<span>=</span>value<span>)</span></code></pre><p>Pretty simple so far:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> i <span>=</span> var<span>(</span><span>0</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>i<span>)</span>
<span>0</span>
<span>&gt;&gt;</span><span>&gt;</span> comp <span>=</span> i <span>&lt;</span> <span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>comp<span>)</span>
Comparing var<span>(</span>i<span>)</span> <span>&lt;</span> <span>10</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>type</span><span>(</span>comp<span>)</span>
<span>&lt;</span><span>class</span> <span>&#39;__main__._Comparison&#39;</span><span>&gt;</span>
<span>&gt;&gt;</span><span>&gt;</span> comp<span>.</span>op
<span>&#39;&lt;&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> comp<span>.</span>value
<span>10</span></code></pre><p>This <code>_Comparison</code> objects stores all information about the comparison, and this
gets passed down to the <code>_for()</code> function.</p><p>We&#39;ll do the same for the increment part:</p><pre><code><span>class</span> <span>_Increment</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> var<span>,</span> op<span>,</span> value<span>)</span><span>:</span>
        self<span>.</span>var <span>=</span> var
        self<span>.</span>op <span>=</span> op
        self<span>.</span>value <span>=</span> value

    <span>def</span> <span>__repr__</span><span>(</span>self<span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>
        <span>return</span> <span><span>f&#34;Incrementing var(</span><span><span>{</span>self<span>.</span>var<span>!r</span><span>}</span></span><span>) with </span><span><span>{</span>self<span>.</span>op<span>}</span></span><span><span>{</span>self<span>.</span>value<span>!r</span><span>}</span></span><span>&#34;</span></span>

<span>class</span> <span>var</span><span>:</span>
    <span>[</span><span>.</span><span>.</span><span>.</span><span>]</span>

    <span>def</span> <span>__add__</span><span>(</span>self<span>,</span> value<span>)</span><span>:</span>
        <span>return</span> _Increment<span>(</span>var<span>=</span>self<span>,</span> op<span>=</span><span>&#34;+&#34;</span><span>,</span> value<span>=</span>value<span>)</span></code></pre><pre><code><span>&gt;&gt;</span><span>&gt;</span> x <span>=</span> var<span>(</span><span>10</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> x <span>+</span> <span>2</span>
Incrementing var<span>(</span><span>10</span><span>)</span> <span>with</span> <span>+</span><span>2</span></code></pre><p>Alright! Now to the next part.</p><h3 id="implementing-_for">Implementing <code>_for</code></h3><p><code>_for()</code> must return a context manager, because we&#39;re using it with a <code>with</code>
statement, so we&#39;ll use the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager"><code>contextlib.contextmanager</code></a> decorator to
quickly make one:</p><pre><code><span>from</span> contextlib <span>import</span> contextmanager

<span>@contextmanager</span>
<span>def</span> <span>_for</span><span>(</span>variable<span>,</span> comparison<span>,</span> increment<span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f&#34;We initialized the variable as </span><span><span>{</span>variable<span>}</span></span><span>.&#34;</span></span><span>)</span>
    <span>print</span><span>(</span>
      <span><span>f&#34;We&#39;ll increment the value by </span><span><span>{</span>increment<span>.</span>op<span>}</span></span><span><span>{</span>increment<span>.</span>value<span>}</span></span><span> &#34;</span></span>
      <span><span>f&#34;each time, until it ~~stays~~ </span><span><span>{</span>comparison<span>.</span>op<span>}</span></span><span> </span><span><span>{</span>comparison<span>.</span>value<span>}</span></span><span>.&#34;</span></span>
      <span>)</span>
    <span>yield</span>

<span>with</span> _for<span>(</span>i <span>:=</span> var<span>(</span><span>0</span><span>)</span><span>,</span> i <span>&lt;</span> <span>10</span><span>,</span> i <span>+</span> <span>2</span><span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span></code></pre><p>And this way, we should have all the information needed:</p><pre><code>$ python cursedfor.py
We initialized the variable as 0.
We&#39;ll increment the value by +2 each time, until it stays &lt; 10.</code></pre><p>Let&#39;s do the looping now, shall we?</p><pre><code><span>from</span> contextlib <span>import</span> contextmanager

<span>@contextmanager</span>
<span>def</span> <span>_for</span><span>(</span>variable<span>,</span> comparison<span>,</span> increment<span>)</span><span>:</span>
    value <span>=</span> variable<span>.</span>value
    <span>while</span> value <span>&lt;</span> comparison<span>.</span>value<span>:</span>
        <span>print</span><span>(</span>value<span>)</span>
        value <span>+=</span> increment<span>.</span>value

    <span>yield</span>


<span>with</span> _for<span>(</span>i <span>:=</span> var<span>(</span><span>0</span><span>)</span><span>,</span> i <span>&lt;</span> <span>10</span><span>,</span> i <span>+</span> <span>2</span><span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span></code></pre><p>And the output:</p><pre><code>$ python cursedfor.py
0
2
4
6
8</code></pre><p>It works! Let&#39;s try a couple other cases:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> <span>with</span> _for<span>(</span>i <span>:=</span> var<span>(</span><span>1</span><span>)</span><span>,</span> i <span>&lt;</span> <span>10</span><span>,</span> i <span>+</span> <span>3</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>   <span>print</span><span>(</span>f&#34;<span>{</span>i <span>=</span> <span>}</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>1</span>
<span>4</span>
<span>7</span>
i <span>=</span> <span>1</span></code></pre><p>Great! ... wait a second.</p><h3 id="generalizing">Generalizing</h3><p>We&#39;re not actually executing the body of the for loop as many times, we&#39;re
simply printing out <code>value</code>, which is hardcoded. The body is still only executed
once. That&#39;s not what we wanted at all!</p><p>Let&#39;s try to hack around this.</p><h3 id="stack-manipulation">Stack manipulation</h3><p>What now? Does the <code>with</code> statement create its own stack, so we can, in theory,
find the body of the <code>with</code> statement and execute that N times?</p><p>Let&#39;s check using the <code>dis</code> module:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> dis
<span>&gt;&gt;</span><span>&gt;</span> dis<span>.</span>dis<span>(</span><span>&#39;&#39;&#39;
... with x:
...   pass
... &#39;&#39;&#39;</span><span>)</span>
  <span>2</span>           <span>0</span> LOAD_NAME                <span>0</span> <span>(</span>x<span>)</span>
              <span>2</span> SETUP_WITH              <span>16</span> <span>(</span>to <span>20</span><span>)</span>
              <span>4</span> POP_TOP

  <span>3</span>           <span>6</span> POP_BLOCK
              <span>8</span> LOAD_CONST               <span>0</span> <span>(</span><span>None</span><span>)</span>
             <span>10</span> DUP_TOP
             <span>12</span> DUP_TOP
             <span>14</span> CALL_FUNCTION            <span>3</span>
             <span>16</span> POP_TOP
             <span>18</span> JUMP_FORWARD            <span>16</span> <span>(</span>to <span>36</span><span>)</span>
        <span>&gt;&gt;</span>   <span>20</span> WITH_EXCEPT_START
             <span>22</span> POP_JUMP_IF_TRUE        <span>26</span>
             <span>24</span> RERAISE
        <span>&gt;&gt;</span>   <span>26</span> POP_TOP
             <span>28</span> POP_TOP
             <span>30</span> POP_TOP
             <span>32</span> POP_EXCEPT
             <span>34</span> POP_TOP
        <span>&gt;&gt;</span>   <span>36</span> LOAD_CONST               <span>0</span> <span>(</span><span>None</span><span>)</span>
             <span>38</span> RETURN_VALUE</code></pre><p>Nope. Since there&#39;s only one block of output, that shows there&#39;s no separate
code object for a <code>with</code> statement&#39;s body. Compare this to a function:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> dis<span>.</span>dis<span>(</span><span>&#39;&#39;&#39;
... def foo():
...   pass
...
... foo()
... &#39;&#39;&#39;</span><span>)</span>
  <span>2</span>           <span>0</span> LOAD_CONST               <span>0</span> <span>(</span><span>&lt;</span>code <span>object</span> foo at <span>0x7f318f54bf50</span><span>,</span> <span>file</span> <span>&#34;&lt;dis&gt;&#34;</span><span>,</span> line <span>2</span><span>&gt;</span><span>)</span>
              <span>2</span> LOAD_CONST               <span>1</span> <span>(</span><span>&#39;foo&#39;</span><span>)</span>
              <span>4</span> MAKE_FUNCTION            <span>0</span>
              <span>6</span> STORE_NAME               <span>0</span> <span>(</span>foo<span>)</span>

  <span>5</span>           <span>8</span> LOAD_NAME                <span>0</span> <span>(</span>foo<span>)</span>
             <span>10</span> CALL_FUNCTION            <span>0</span>
             <span>12</span> POP_TOP
             <span>14</span> LOAD_CONST               <span>2</span> <span>(</span><span>None</span><span>)</span>
             <span>16</span> RETURN_VALUE

Disassembly of <span>&lt;</span>code <span>object</span> foo at <span>0x7f318f54bf50</span><span>,</span> <span>file</span> <span>&#34;&lt;dis&gt;&#34;</span><span>,</span> line <span>2</span><span>&gt;</span><span>:</span>
  <span>3</span>           <span>0</span> LOAD_CONST               <span>0</span> <span>(</span><span>None</span><span>)</span>
              <span>2</span> RETURN_VALUE</code></pre><p>You can see there&#39;s two disassemblies, of two separate code objects. So that&#39;s
a no-go.</p><p>But hey, we can still access the stack frame...</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> inspect
<span>&gt;&gt;</span><span>&gt;</span> frame <span>=</span> inspect<span>.</span>currentframe<span>(</span><span>)</span></code></pre><p>And I could read the code object inside it...</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> frame<span>.</span>f_code
<span>&lt;</span>code <span>object</span> <span>&lt;</span>module<span>&gt;</span> at <span>0x7f03e9d90f50</span><span>,</span> <span>file</span> <span>&#34;&lt;stdin&gt;&#34;</span><span>,</span> line <span>1</span><span>&gt;</span>
<span>&gt;&gt;</span><span>&gt;</span> frame<span>.</span>f_code<span>.</span>co_code
<span>b&#39;e\x00\xa0\x01\xa1\x00Z\x02d\x00S\x00&#39;</span>
<span>&gt;&gt;</span><span>&gt;</span> frame<span>.</span>f_lasti
<span>10</span></code></pre><p><code>f_lasti</code> also tells us which of those bytes (instructions) was last executed,
which means the code after it must contain the body of the <code>with</code> statement!</p><p>So if we could just extract the bytecode and then run the body manually N times,
we could...</p><h3 id="giving-up">Giving up</h3><p>Here&#39;s one (obvious) piece of advice -- if your current approach devolves into
you trying to rewrite the Python interpreter, you have messed up.</p><p>Let&#39;s backtrack, and try to think of some other possibility.</p><h3 id="part-2-making-our-own-language-inside-python">Part 2: Making our own language inside Python</h3><p>Thanks to <a href="https://github.com/tusharsadhwani/zxpy">another such project</a> that I made in the past, I learned the
fact that you can add <em>arbitrary semantics</em> into Python -- essentially, if
something is valid Python code, you could <em>transform</em> it to suit your needs. All
you need is this one simple trick: <strong>AST manipulation</strong>.</p><p>Here&#39;s what I mean. You can take any piece of code:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> code <span>=</span> <span>&#39;2 + 3&#39;</span></code></pre><p>You can parse it (as long as it&#39;s valid &#34;Syntax&#34;)</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> <span>import</span> ast
<span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span>code<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>ast<span>.</span>dump<span>(</span>tree<span>,</span> indent<span>=</span><span>2</span><span>)</span><span>)</span>
Module<span>(</span>
  body<span>=</span><span>[</span>
    Expr<span>(</span>
      value<span>=</span>BinOp<span>(</span>
        left<span>=</span>Constant<span>(</span>value<span>=</span><span>2</span><span>)</span><span>,</span>
        op<span>=</span>Add<span>(</span><span>)</span><span>,</span>
        right<span>=</span>Constant<span>(</span>value<span>=</span><span>3</span><span>)</span><span>)</span><span>)</span><span>]</span><span>,</span>
  type_ignores<span>=</span><span>[</span><span>]</span><span>)</span></code></pre><p>You can change what the code actually means:</p><pre><code>
<span>&gt;&gt;</span><span>&gt;</span> tree<span>.</span>body<span>[</span><span>0</span><span>]</span><span>.</span>value<span>.</span>op <span>=</span> ast<span>.</span>Sub<span>(</span><span>)</span></code></pre><p>And you can generate code back out of it:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> ast<span>.</span>unparse<span>(</span>tree<span>)</span>
<span>&#39;2 - 3&#39;</span></code></pre><p>Which you&#39;re free to execute as you please. This example is really simplified,
but with enough transformation, you can turn any Python code into anything else.</p><p>So let&#39;s do exactly that.</p><h3 id="building-a-for-loop-transformer">Building a for-loop transformer</h3><p>What we want the following code:</p><pre><code><span>with</span> _for<span>(</span>i <span>:=</span> <span>0</span><span>,</span> i <span>&lt;</span> <span>10</span><span>,</span> i <span>+</span> <span>2</span><span>)</span><span>:</span>
    <span>&lt;</span>the body<span>&gt;</span></code></pre><p>into the following:</p><pre><code>i <span>=</span> <span>0</span>
<span>while</span> i <span>&lt;</span> <span>10</span><span>:</span>
    <span>&lt;</span>the body<span>&gt;</span>
    i <span>+=</span> <span>2</span></code></pre><p>We can break this down into three distinct parts:</p><ul>
<li>Find all <code>with _for()</code> statements inside a code block</li>
<li>Transform the <code>with _for()</code> into the initializer and <code>while</code> statements.</li>
<li>Replace all the instances with the two statements instead.</li>
</ul><p>Let&#39;s do them in that order:</p><h3 id="find-the-cursed-loops">Find the cursed loops</h3><p>We&#39;ll be using an <code>ast.NodeTransformer</code> class which helps us find and replace
AST nodes inside the code easily. We&#39;ll be implementing its <code>generic_visit()</code>
method, to find all AST nodes that have a <code>body</code>, and find cursed <code>_for</code> blocks
inside them.</p><pre><code><span>class</span> <span>CursedForTransformer</span><span>(</span>ast<span>.</span>NodeTransformer<span>)</span><span>:</span>
    <span>def</span> <span>generic_visit</span><span>(</span>self<span>,</span> node<span>:</span> ast<span>.</span>AST<span>)</span> <span>-</span><span>&gt;</span> ast<span>.</span>AST<span>:</span>
        <span>super</span><span>(</span><span>)</span><span>.</span>generic_visit<span>(</span>node<span>)</span>

        <span>if</span> <span>hasattr</span><span>(</span>node<span>,</span> <span>&#34;body&#34;</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span>node<span>.</span>body<span>,</span> <span>list</span><span>)</span><span>:</span>
            new_body <span>=</span> <span>[</span><span>]</span>
            <span>for</span> stmt <span>in</span> node<span>.</span>body<span>:</span>
                <span>if</span> <span>isinstance</span><span>(</span>stmt<span>,</span> ast<span>.</span>With<span>)</span><span>:</span>
                    <span>if</span> <span>any</span><span>(</span>
                        self<span>.</span>is_cursed_for_call<span>(</span>expr<span>.</span>context_expr<span>)</span>
                        <span>for</span> expr <span>in</span> stmt<span>.</span>items
                    <span>)</span><span>:</span>
                        item_replacements <span>=</span> self<span>.</span>replace_cursed_for<span>(</span>stmt<span>)</span>
                        new_body<span>.</span>extend<span>(</span>item_replacements<span>)</span>
                        <span>continue</span>

                
                new_body<span>.</span>append<span>(</span>stmt<span>)</span>

              node<span>.</span>body <span>=</span> new_body

          <span>return</span> node</code></pre><blockquote>
<p>If you want to deep dive into what&#39;s going on here with <code>NodeTransformer</code>,
<code>generic_visit</code> etc., check out <a href="https://sadh.life/post/ast">this post</a>.</p>
</blockquote><p>Essentially:</p><ul>
<li>
<p>We&#39;re finding all blocks in our code, by finding <code>body</code> attributes:</p>
<pre><code><span>if</span> <span>hasattr</span><span>(</span>node<span>,</span> <span>&#34;body&#34;</span><span>)</span> <span>and</span> <span>isinstance</span><span>(</span>node<span>.</span>body<span>,</span> <span>list</span><span>)</span><span>:</span></code></pre>
</li>
<li>
<p>Then we&#39;re trying to find <code>with</code> statements, which contain the cursed
for-loops:</p>
<pre><code><span>if</span> <span>isinstance</span><span>(</span>stmt<span>,</span> ast<span>.</span>With<span>)</span><span>:</span>
    <span>if</span> <span>any</span><span>(</span>
        self<span>.</span>is_cursed_for_call<span>(</span>expr<span>.</span>context_expr<span>)</span>
        <span>for</span> expr <span>in</span> stmt<span>.</span>items
    <span>)</span><span>:</span></code></pre>
</li>
<li>
<p>And if found, we call <code>self.replace_cursed_for(stmt)</code> to replace it with the
initializer and while loop, in the <code>new_body</code>:</p>
<pre><code>item_replacements <span>=</span> self<span>.</span>replace_cursed_for<span>(</span>stmt<span>)</span>
new_body<span>.</span>extend<span>(</span>item_replacements<span>)</span>
<span>continue</span></code></pre>
</li>
<li>
<p>Otherwise, if it&#39;s not a cursed for loop, we just add the node to the body,
unchanged:</p>
<pre><code>
new_body<span>.</span>append<span>(</span>stmt<span>)</span></code></pre>
<p>And we update the node&#39;s body, and return.</p>
</li>
</ul><p>Here&#39;s the code for <code>self.is_cursed_for_call</code>, it just checks if the function is
called <code>_for</code>:</p><pre><code>    <span>@staticmethod</span>
    <span>def</span> <span>is_cursed_for_call</span><span>(</span>node<span>:</span> ast<span>.</span>AST<span>)</span> <span>-</span><span>&gt;</span> <span>bool</span><span>:</span>
        <span>return</span> <span>(</span>
            <span>isinstance</span><span>(</span>node<span>,</span> ast<span>.</span>Call<span>)</span>
            <span>and</span> <span>isinstance</span><span>(</span>node<span>.</span>func<span>,</span> ast<span>.</span>Name<span>)</span>
            <span>and</span> node<span>.</span>func<span>.</span><span>id</span> <span>==</span> <span>&#34;_for&#34;</span>
        <span>)</span>
</code></pre><h3 id="implementing-the-cursed-for-transformer">Implementing the cursed-for transformer</h3><p>We have yet to see how <code>self.replace_cursed_for(stmt)</code> works. In essence it just
has to return a list of two nodes:</p><ul>
<li>An initializer (like <code>i = 0</code>),</li>
<li>And a <code>while</code> loop, containing the condition and the <code>with</code> body.</li>
</ul><p>Here&#39;s the function, simplified and documented for explanation:</p><pre><code><span>def</span> <span>replace_cursed_for</span><span>(</span>self<span>,</span> node<span>:</span> ast<span>.</span>With<span>)</span> <span>-</span><span>&gt;</span> <span>list</span><span>[</span>ast<span>.</span>AST<span>]</span><span>:</span>
    
    cursed_for_call<span>:</span> ast<span>.</span>Call <span>=</span> node<span>.</span>items<span>[</span><span>0</span><span>]</span><span>.</span>context_expr
    
    init_node<span>,</span> condition_node<span>,</span> increment_node <span>=</span> cursed_for_call<span>.</span>args

    
    init_variable<span>:</span> ast<span>.</span>Name <span>=</span> init_node<span>.</span>target
    init_statement <span>=</span> ast<span>.</span>Assign<span>(</span>targets<span>=</span><span>[</span>init_variable<span>]</span><span>,</span> value<span>=</span>init_node<span>.</span>value<span>)</span>

    
    increment_statement <span>=</span> ast<span>.</span>AugAssign<span>(</span>
        target<span>=</span>init_variable<span>,</span>
        op<span>=</span>increment_node<span>.</span>op<span>,</span>
        value<span>=</span>increment_node<span>.</span>right<span>,</span>
    <span>)</span>

    
    block_body <span>=</span> <span>[</span><span>*</span>node<span>.</span>body<span>,</span> increment_statement<span>]</span>
    while_statement <span>=</span> ast<span>.</span>While<span>(</span>test<span>=</span>condition_node<span>,</span> body<span>=</span>block_body<span>,</span> orelse<span>=</span><span>[</span><span>]</span><span>)</span>

    
    <span>return</span> <span>[</span>init_statement<span>,</span> while_statement<span>]</span></code></pre><p>To show it in action, here&#39;s the transformation it does:</p><pre><code><span>&gt;&gt;</span><span>&gt;</span> tree <span>=</span> ast<span>.</span>parse<span>(</span><span>&#39;&#39;&#39;
... def foo():
...     with _for(i := 10, i &lt;= 0, i - 3):
...         print(&#34;The value is:&#34;, i)
... &#39;&#39;&#39;</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> modified_tree <span>=</span> CursedForTransformer<span>(</span><span>)</span><span>.</span>visit<span>(</span>tree<span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>ast<span>.</span>unparse<span>(</span>modified_tree<span>)</span><span>)</span>
<span>&gt;&gt;</span><span>&gt;</span> ast<span>.</span>fix_missing_locations<span>(</span>modified_tree<span>)</span>
<span>&lt;</span>ast<span>.</span>Module <span>object</span> at <span>0x7f7a18bebf70</span><span>&gt;</span>
<span>&gt;&gt;</span><span>&gt;</span> <span>print</span><span>(</span>ast<span>.</span>unparse<span>(</span>modified_tree<span>)</span><span>)</span>

<span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
    i <span>=</span> <span>10</span>
    <span>while</span> i <span>&lt;=</span> <span>0</span><span>:</span>
        <span>print</span><span>(</span><span>&#39;The value is:&#39;</span><span>,</span> i<span>)</span>
        i <span>-=</span> <span>3</span></code></pre><p>It works! We can finally use this to run our cursed for loops!</p><p>If you wish to try this out yourself, the complete code (with much better error
handling) is present in <a href="https://github.com/tusharsadhwani/cursed-for/blob/master/approach/ast_manipulation/cursedfor.py">cursedfor.py</a> in the GitHub repository, and you can
download it and run the REPL.</p><details>
<summary> How the cursed REPL works </summary>
<p>Python&#39;s standard library never ceases to amaze me. Even for a usecase as weird
as creating a custom REPL, Python lets you do that by itself. Specifically,
there exists a <code>code</code> module, which contains primitives such as
<code>code.InteractiveConsole</code>.</p>
<p><code>InteractiveConsole</code> is a pre-built Python REPL, which by default works the same
way you would expect Python&#39;s interactive console to work:</p>
<pre><code><span>import</span> code

<span>class</span> <span>CursedConsole</span><span>(</span>code<span>.</span>InteractiveConsole<span>)</span><span>:</span>
    <span>pass</span>

CursedConsole<span>(</span><span>)</span><span>.</span>interact<span>(</span>banner<span>=</span><span><span>f&#34;Cursed Python REPL&#34;</span></span><span>,</span> exitmsg<span>=</span><span>&#34;&#34;</span><span>)</span></code></pre>
<pre><code>$ python cursedfor.py
Cursed Python REPL
&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x
5
&gt;&gt;&gt;</code></pre>
<p>Completely normal.</p>
<p>But, you can override any of its functions to change their functionality.</p>
<p>In our case, we can change the <code>runsource</code> method, which is responsible for
running a single statement or expression at a time. Here&#39;s the full
implementation:</p>
<pre><code><span>class</span> <span>CursedConsole</span><span>(</span>code<span>.</span>InteractiveConsole<span>)</span><span>:</span>
    <span>def</span> <span>runsource</span><span>(</span>
        self<span>,</span>
        source<span>:</span> <span>str</span><span>,</span>
        filename<span>:</span> <span>str</span> <span>=</span> <span>&#34;&lt;input&gt;&#34;</span><span>,</span>
        symbol<span>:</span> <span>str</span> <span>=</span> <span>&#34;single&#34;</span><span>,</span>
    <span>)</span> <span>-</span><span>&gt;</span> <span>bool</span><span>:</span>
        
        
        <span>with</span> suppress<span>(</span>SyntaxError<span>,</span> OverflowError<span>)</span><span>:</span>
            <span>if</span> code<span>.</span>compile_command<span>(</span>source<span>)</span> <span>==</span> <span>None</span><span>:</span>
                <span>return</span> <span>True</span>

        <span>try</span><span>:</span>
            tree <span>=</span> ast<span>.</span>parse<span>(</span>source<span>,</span> filename<span>,</span> mode<span>=</span>symbol<span>)</span>
            CursedForTransformer<span>(</span><span>)</span><span>.</span>visit<span>(</span>tree<span>)</span>
            ast<span>.</span>fix_missing_locations<span>(</span>tree<span>)</span>
        <span>except</span> <span>(</span>ValueError<span>,</span> SyntaxError<span>)</span><span>:</span>
            
            <span>return</span> <span>super</span><span>(</span><span>)</span><span>.</span>runsource<span>(</span>source<span>,</span> filename<span>,</span> symbol<span>)</span>

        code_obj <span>=</span> <span>compile</span><span>(</span>tree<span>,</span> filename<span>,</span> mode<span>=</span>symbol<span>)</span>
        self<span>.</span>runcode<span>(</span>code_obj<span>)</span>
        <span>return</span> <span>False</span></code></pre>
<p>The <code>code.compile_command</code> part returning <code>True</code> is important to support
multiline statements in the REPL, like these:</p>
<pre><code><span>&gt;&gt;</span><span>&gt;</span> <span>def</span> <span>foo</span><span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>42</span><span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>&gt;&gt;</span><span>&gt;</span></code></pre>
<p>Support for multiline input and exceptions comes for free because we used this
class.</p>
<p>Apart from that, the interesting part is this:</p>
<pre><code><span>try</span><span>:</span>
    tree <span>=</span> ast<span>.</span>parse<span>(</span>source<span>,</span> filename<span>,</span> mode<span>=</span>symbol<span>)</span>
    CursedForTransformer<span>(</span><span>)</span><span>.</span>visit<span>(</span>tree<span>)</span>
<span>except</span> <span>(</span>ValueError<span>,</span> SyntaxError<span>)</span><span>:</span>
    <span>[</span><span>.</span><span>.</span><span>.</span><span>]</span>

code_obj <span>=</span> <span>compile</span><span>(</span>tree<span>,</span> filename<span>,</span> mode<span>=</span>symbol<span>)</span>
self<span>.</span>runcode<span>(</span>code_obj<span>)</span></code></pre>
<p>We simply modified the AST tree before passing it on to <code>self.runcode</code>.</p>
<p>This is actually amazing. Using this same class and a custom <code>NodeTransformer</code>,
you can build basically any DSL or mini language that uses Python&#39;s syntax.</p>
<p>If you want to try doing it yourself, the starter code is present <a href="https://github.com/tusharsadhwani/t/blob/master/custom_interpreter.py">here</a>.</p>
</details><h3 id="is-that-it">Is that it?</h3><p>I was finally done with this project, but it always stayed in the back of my
mind. I just felt that I hadn&#39;t done it justice.</p><p>And so, a couple months later, I got to know of a much, <em>much</em> better way to do
this. And it was everything that I could&#39;ve ever wanted.</p><h2 id="part-3-the-truly-cursed-way">Part 3: The &#34;Truly Cursed&#34; way</h2><p>I stumbled upon <a href="https://pypi.org/p/cstyle">this library</a>, which tries to add braces to Python instead
of indentation. And although the implementation is questionable, it gave me
<strong>exactly</strong> the tool I needed to finish this project: <code>codecs</code>.</p><h3 id="what-the-heck-is-a-codec">What the heck is a codec?</h3><p>A &#34;codec&#34; in Python refers to the tools that let you convert the text encoding
of a source file into a Python string, and (in case of source code) can run the
code.</p><p>A lot of pre-built codecs exist, such as <code>utf-8</code>, <code>cp1252</code>, and <code>ascii</code>, so that
people can write their code in whichever file encoding they prefer to use, and
Python will pre-process the file into the text format that it understands,
before trying to run it.</p><p>There&#39;s just one tiny detail: You can write your own custom codecs.</p><h3 id="source-translation">Source translation</h3><p>So here&#39;s the new idea: What if instead of AST manipulation, we manipulated the
source text directly before it runs?</p><p>Yeah, I know, it&#39;s probably a bad idea. But I think it can work. And you can&#39;t
stop me, so you might as well see what I have to say.</p><p>The approach in my mind is pretty simple:</p><ul>
<li>Find the <code>for (init; condition; increment):</code> pattern in the source code</li>
<li>Substitute that text with two lines: <code>init</code> and <code>while condition:</code></li>
<li>Append the <code>increment</code> statement at the end of the <code>for</code> body.</li>
</ul><p>Let&#39;s try it out then.</p><h3 id="time-for-regex-hacks">Time for regex hacks</h3><p>To create the encoding, we first need to implement a transformation function. I
chose to implement one that works on a list of Python source lines. Here&#39;s the
boilerplate:</p><pre><code><span>import</span> codecs

<span>def</span> <span>_transform_cursed_for</span><span>(</span>lines<span>:</span> <span>list</span><span>[</span><span>str</span><span>]</span><span>)</span> <span>-</span><span>&gt;</span> <span>list</span><span>[</span><span>str</span><span>]</span><span>:</span>
    new_source <span>=</span> <span>[</span><span>]</span>
    index <span>=</span> <span>0</span>
    <span>while</span> index <span>&lt;</span> <span>len</span><span>(</span>lines<span>)</span><span>:</span>
        line <span>=</span> lines<span>[</span>index<span>]</span>

        
        new_source<span>.</span>append<span>(</span>line<span>)</span>
        index <span>+=</span> <span>1</span>

    <span>return</span> new_source

<span>def</span> <span>transform_cursed_for</span><span>(</span>source<span>:</span> <span>str</span><span>)</span> <span>-</span><span>&gt;</span> <span>str</span><span>:</span>
    lines <span>=</span> source<span>.</span>splitlines<span>(</span><span>)</span>
    new_lines <span>=</span> _transform_cursed_for<span>(</span>lines<span>)</span>
    <span>return</span> <span>&#34;\n&#34;</span><span>.</span>join<span>(</span>new_lines<span>)</span>

codecs<span>.</span>register<span>(</span>
  <span>{</span><span>&#39;cursed_for&#39;</span><span>:</span> codecs<span>.</span>CodecInfo<span>(</span>
    name<span>=</span><span>&#39;cursed_for&#39;</span><span>,</span>
    encode<span>=</span>utf_8<span>.</span>encode<span>,</span>
    decode<span>=</span>transform_cursed_for<span>,</span>
  <span>)</span><span>}</span><span>.</span>get
<span>)</span></code></pre><p>Now for the details on how we match and replace <code>for (x; y; z):</code> lines:</p><ul>
<li>
<p>First, you match the syntax:</p>
<pre><code>beginning_with_for_regex <span>=</span> re<span>.</span><span>compile</span><span>(</span><span>r&#39;^\s*for\b&#39;</span><span>)</span>

<span>if</span> beginning_with_for_regex<span>.</span><span>match</span><span>(</span>line<span>)</span><span>:</span>
    <span>.</span><span>.</span><span>.</span></code></pre>
</li>
<li>
<p>If we find such a line, we find the three parts and the indentation of the
inner block:</p>
<pre><code>indent_regex <span>=</span> re<span>.</span><span>compile</span><span>(</span><span>r&#39;^\s*&#39;</span><span>)</span>
cursed_for_regex <span>=</span> re<span>.</span><span>compile</span><span>(</span><span>r&#39;^\s*for\s*\((.+?);(.+?);(.+?)\):(.*)$&#39;</span><span>)</span>

<span>match</span> <span>=</span> cursed_for_regex<span>.</span><span>match</span><span>(</span>line<span>)</span>
initializer<span>,</span> condition<span>,</span> increment <span>=</span> <span>match</span><span>[</span><span>1</span><span>]</span><span>,</span> <span>match</span><span>[</span><span>2</span><span>]</span><span>,</span> <span>match</span><span>[</span><span>3</span><span>]</span>


for_indent_level <span>=</span> indent_regex<span>.</span><span>match</span><span>(</span>line<span>)</span><span>.</span>group<span>(</span><span>)</span>


next_line <span>=</span> lines<span>[</span>index<span>]</span>
index <span>+=</span> <span>1</span>


body_indent_level <span>=</span> indent_regex<span>.</span><span>match</span><span>(</span>next_line<span>)</span><span>.</span>group<span>(</span><span>)</span></code></pre>
</li>
<li>
<p>Now, we collect all the lines which are inside the <code>for</code> block, by finding all
lines which are indented at the same level as the first line:</p>
<pre><code>for_body_lines <span>=</span> <span>[</span>next_line<span>]</span>

<span>while</span> index <span>&lt;</span> <span>len</span><span>(</span>lines<span>)</span><span>:</span>
    next_line <span>=</span> lines<span>[</span>index<span>]</span>
    <span>if</span> <span>not</span> next_line<span>.</span>startswith<span>(</span>body_indent_level<span>)</span><span>:</span>
        <span>break</span>

    for_body_lines<span>.</span>append<span>(</span>next_line<span>)</span>
    index <span>+=</span> <span>1</span></code></pre>
</li>
<li>
<p>At the end, we add in the two initializer and <code>while</code> statemnets:</p>
<pre><code>initializer_stmt <span>=</span> <span><span>f&#39;</span><span><span>{</span>for_indent_level<span>}</span></span><span><span>{</span>initializer<span>.</span>strip<span>(</span><span>)</span><span>}</span></span><span>&#39;</span></span>
while_stmt <span>=</span> <span><span>f&#39;</span><span><span>{</span>for_indent_level<span>}</span></span><span>while </span><span><span>{</span>condition<span>.</span>strip<span>(</span><span>)</span><span>}</span></span><span>:&#39;</span></span>
increment_stmt <span>=</span> <span><span>f&#39;</span><span><span>{</span>body_indent_level<span>}</span></span><span><span>{</span>increment<span>.</span>strip<span>(</span><span>)</span><span>}</span></span><span>&#39;</span></span>

new_source<span>.</span>append<span>(</span>initializer_stmt<span>)</span>
new_source<span>.</span>append<span>(</span>while_stmt<span>)</span>
new_source<span>.</span>extend<span>(</span>for_body_lines<span>)</span>
new_source<span>.</span>append<span>(</span>increment_stmt<span>)</span></code></pre>
</li>
</ul><p>So that&#39;s how I did it. And to my own surprise, it works!</p><pre><code>code <span>=</span> <span>b&#39;&#39;&#39;
for (i = 0; i &lt; 10; i += 2):
    print(i)
print(&#34;done&#34;)
&#39;&#39;&#39;</span>
<span>print</span><span>(</span>code<span>.</span>decode<span>(</span><span>&#39;cursed_for&#39;</span><span>)</span><span>)</span></code></pre><pre><code>$ python cursedfor<span>.</span>py
i <span>=</span> <span>0</span>
<span>while</span> i <span>&lt;</span> <span>10</span><span>:</span>
    <span>print</span><span>(</span>i<span>)</span>
    i <span>+=</span> <span>2</span>
<span>print</span><span>(</span><span>&#34;done&#34;</span><span>)</span></code></pre><p>Is this useful, at all? Probably not. Is it cursed? <strong>YES.</strong></p><p>Can this knowledge be useful in making actually good Python packages? You tell
me!</p><h3 id="nested-cursed-loops">Nested cursed loops</h3><p>The current method does work, but it breaks if you try to give it nested loops:</p><pre><code><span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i <span>+=</span> <span>3</span><span>)</span><span>:</span>
    <span>for</span> <span>(</span>j <span>=</span> i<span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j <span>+=</span> <span>3</span><span>)</span><span>:</span>
        <span>print</span><span>(</span>i<span>,</span> j<span>)</span></code></pre><p>This is because we don&#39;t transform the body of the for-loop, which we should.</p><p><em>Recursively.</em></p><p>Simply call <code>_transform_cursed_for()</code> on the collected lines of the inner body,
before appending it to the new body:</p><pre><code><span>[</span><span>.</span><span>.</span><span>.</span><span>]</span>
new_source<span>.</span>extend<span>(</span>_transform_cursed_for<span>(</span>for_body_lines<span>)</span><span>)</span></code></pre><p>And that&#39;s it!</p><blockquote>
<p>The complete code for this approach, with much better error handling, etc. is
present in <a href="https://github.com/tusharsadhwani/cursed-for/tree/master/approach/the_truly_cursed_way">this folder</a> in the GitHub repository.</p>
</blockquote><h3 id="the-making-of-perhaps-the-most-cursed-python-package">The making of perhaps the most cursed Python package</h3><p>There&#39;s just one more thing left to do: Make this an installable package.</p><p>And honestly, that part of the process is a lot more black-magic hackery than
what we&#39;ve even seen so far. I basically copied what this other project called
<a href="https://github.com/asottile-archive/future-fstrings">future-fstrings</a> does, and you can watch <a href="https://www.youtube.com/watch?v=00h6aKnAdyY">this video</a> if you&#39;re really
curious.</p><p>In essence, we need to register this encoding at Python&#39;s startup time. And we
do that by creating a <code>.pth</code> file which must be stored into the <code>site-packages</code>
folder, which will get auto imported when Python starts up.</p><p>And with that, our package is complete.</p><h3 id="test-drive">Test drive</h3><p>You can now install the package:</p><pre><code>pip install cursed-for</code></pre><p>And run your cursed python files with a <code># coding</code> comment at the top:</p><pre><code>
<span>for</span> <span>(</span>i <span>=</span> <span>5</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i <span>+=</span> <span>2</span><span>)</span><span>:</span>
    <span>print</span><span>(</span>i<span>)</span></code></pre><pre><code>$ python x.py
5
7
9</code></pre><p>Can you do this in a REPL? Can you debug the output? Absolutely! Check out the
<a href="https://github.com/tusharsadhwani/cursed-for">repository&#39;s README</a> for more info.</p><p>And that&#39;s it from me. I... hope you learned something useful? I sure did.</p>
    </main>
  </article></div>
  </body>
</html>
