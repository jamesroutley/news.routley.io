<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://temporal.io/blog/durable-distributed-asyncio-event-loop">Original</a>
    <h1>Temporal Python – A durable, distributed asyncio event loop (2023)</h1>
    
    <div id="readability-page-1" class="page"><article><div>  <div data-contentful-entry-id="6vt7XRXjCU2fNLY9olFRZW" data-contentful-field-id="content"><!-- HTML_TAG_START -->
<p>We are excited about the GA release of the Temporal Python SDK. Python is now a fully-supported workflow language
in Temporal, and our use of native <a href="https://docs.python.org/3/library/asyncio.html" rel="nofollow">asyncio</a> constructs makes it a
perfect fit for Python developers looking to write durable workflows.</p>
<p><img src="https://images.ctfassets.net/0uuz8ydxyd9p/1hk7HB0wd9q2IKMZ5WZ8vT/7f6769aef3b75152e087561c37ba97a9/python-feature__1_.png" alt="python"/></p>
<p>Here are some links to read more about Temporal Python:</p>
<ul>
<li><a href="https://github.com/temporalio/sdk-python" rel="nofollow">Repository</a></li>
<li><a href="https://docs.temporal.io/dev-guide/python/" rel="nofollow">Application Development Guide</a></li>
<li><a href="https://github.com/temporalio/samples-python" rel="nofollow">Code Samples</a></li>
<li><a href="https://python.temporal.io" rel="nofollow">API Documentation</a></li>
</ul>
<p>Like essentially all of Temporal, Temporal Python is MIT licensed, and open source contributions are very welcome. Join
us in the <code>#python-sdk</code> channel in <a href="https://t.mp/slack" rel="nofollow">Temporal Slack</a> or ask questions in the
<a href="https://community.temporal.io/" rel="nofollow">Community Forum</a>.</p>
<p>Most of the details about how to use the SDK are in the aforementioned links, so this post will only give a high-level
refresher of what Temporal and Temporal Python are. Then we will dive into some of the details of how Temporal Python
leverages asyncio and other Temporal Python features.</p>
<h2>Intro to Temporal</h2>
<p>Temporal is a workflow system allowing developers to write workflows in code. Workflows run in any number of workers.
Code in a workflow translates to events in Temporal which means the workflow code can be replayed with the events on
different workers as needed in an Event Sourcing approach. Therefore workflow code must be deterministic in order to
safely rerun.</p>
<p>Workflows can call out to activities, which also run on workers and are general purpose functions that can do anything.</p>
<p>Clients can signal, query, cancel, and/or terminate workflows.</p>
<p>Since workflows routinely wait on timers, async tasks, managed coroutines, cancellations, etc., workflows are modeled
well as Python asyncio event loops.</p>
<h2>Intro to Temporal Python</h2>
<p>To give a quick walk through of Temporal Python, we’ll implement a simplified form of one-click buying where a purchase
is started and then, unless cancelled, will be performed in 10 seconds.</p>
<h3>Implementing an Activity</h3>
<p>First, let’s create a simple activity that does an HTTP POST of a purchase via <a href="https://docs.aiohttp.org" rel="nofollow">aiohttp</a>:</p>
<pre tabindex="0"><code><span><span>import</span><span> aiohttp</span></span>
<span><span>from</span><span> dataclasses </span><span>import</span><span> dataclass, asdict</span></span>
<span><span>from</span><span> temporalio </span><span>import</span><span> activity</span></span>
<span><span>from</span><span> temporalio.exceptions </span><span>import</span><span> ApplicationError</span></span>
<span></span>
<span><span>@</span><span>dataclass</span></span>
<span><span>class</span><span> Purchase</span><span>:</span></span>
<span><span>    item_id: </span><span>str</span></span>
<span><span>    user_id: </span><span>str</span></span>
<span></span>
<span><span>@</span><span>activity</span><span>.</span><span>defn</span></span>
<span><span>async</span><span> def</span><span> do_purchase</span><span>(</span><span>purchase</span><span>: Purchase) -&gt; </span><span>None</span><span>:</span></span>
<span><span>    async</span><span> with</span><span> aiohttp.ClientSession() </span><span>as</span><span> sess:</span></span>
<span><span>        async</span><span> with</span><span> sess.post(</span><span>&#34;</span><span>https://api.example.com/purchase</span><span>&#34;</span><span>, </span><span>json</span><span>=</span><span>asdict(purchase)) </span><span>as</span><span> resp:</span></span>
<span><span>            # We don&#39;t want to retry client failure</span></span>
<span><span>            if</span><span> resp.status </span><span>&gt;=</span><span> 400</span><span> and</span><span> resp.status </span><span>&lt;</span><span> 500</span><span>:</span></span>
<span><span>                raise</span><span> ApplicationError(</span><span>f</span><span>&#34;Status: </span><span>{</span><span>resp.status</span><span>}</span><span>&#34;</span><span>, resp.json(), </span><span>non_retryable</span><span>=</span><span>True</span><span>)</span></span>
<span><span>            # Otherwise, fail on bad status which will be inherently retried</span></span>
<span><span>            resp.raise_for_status()</span></span></code></pre>
<h3>Implementing a Workflow</h3>
<p>Now we want to execute that activity from a workflow after 10 seconds unless we receive a cancel:</p>
<pre tabindex="0"><code><span><span>import</span><span> asyncio</span></span>
<span><span>from</span><span> datetime </span><span>import</span><span> timedelta</span></span>
<span><span>from</span><span> enum </span><span>import</span><span> IntEnum</span></span>
<span><span>from</span><span> temporalio </span><span>import</span><span> workflow</span></span>
<span></span>
<span><span># Import our activity, but pass it through the sandbox</span></span>
<span><span>with</span><span> workflow.unsafe.imports_passed_through():</span></span>
<span><span>    from</span><span> .my_activities </span><span>import</span><span> Purchase, do_purchase</span></span>
<span></span>
<span><span>class</span><span> PurchaseStatus</span><span>(</span><span>IntEnum</span><span>):</span></span>
<span><span>    PENDING </span><span>=</span><span> 1</span></span>
<span><span>    CONFIRMED </span><span>=</span><span> 2</span></span>
<span><span>    CANCELLED </span><span>=</span><span> 3</span></span>
<span><span>    COMPLETED </span><span>=</span><span> 4</span></span>
<span></span>
<span><span>@</span><span>workflow</span><span>.</span><span>defn</span></span>
<span><span>class</span><span> OneClickBuyWorkflow</span><span>:</span></span>
<span><span>    def</span><span> __init__(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        self</span><span>.status </span><span>=</span><span> PurchaseStatus.PENDING</span></span>
<span><span>        self</span><span>.purchase: Optional[Purchase] </span><span>=</span><span> None</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>run</span></span>
<span><span>    async</span><span> def</span><span> run</span><span>(</span><span>self</span><span>, </span><span>purchase</span><span>: Purchase) -&gt; PurchaseStatus:</span></span>
<span><span>        self</span><span>.purchase </span><span>=</span><span> self</span><span>.purchase </span><span>or</span><span> purchase</span></span>
<span></span>
<span><span>        # Give user 10 seconds to cancel or update before we send it through</span></span>
<span><span>        try</span><span>:</span></span>
<span><span>            await</span><span> asyncio.sleep(</span><span>10</span><span>)</span></span>
<span><span>        except</span><span> asyncio.CancelledError:</span></span>
<span><span>            self</span><span>.status </span><span>=</span><span> PurchaseStatus.CANCELLED</span></span>
<span><span>            return</span><span> self</span><span>.status</span></span>
<span></span>
<span><span>        # Update status, purchase, and update status again</span></span>
<span><span>        self</span><span>.status </span><span>=</span><span> PurchaseStatus.CONFIRMED</span></span>
<span><span>        await</span><span> workflow.execute_activity(</span></span>
<span><span>            Purchaser.purchase,</span></span>
<span><span>            self</span><span>.purchase,</span></span>
<span><span>            start_to_close_timeout</span><span>=</span><span>timedelta(</span><span>minutes</span><span>=</span><span>1</span><span>),</span></span>
<span><span>            cancellation_type</span><span>=</span><span>workflow.ActivityCancellationType.WAIT_CANCELLATION_COMPLETED,</span></span>
<span><span>        )</span></span>
<span><span>        self</span><span>.status </span><span>=</span><span> PurchaseStatus.COMPLETED</span></span>
<span><span>        return</span><span> self</span><span>.status</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>signal</span></span>
<span><span>    def</span><span> update_purchase</span><span>(</span><span>self</span><span>, </span><span>purchase</span><span>: Purchase) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        self</span><span>.purchase </span><span>=</span><span> purchase</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>query</span></span>
<span><span>    def</span><span> current_status</span><span>(</span><span>self</span><span>) -&gt; PurchaseStatus:</span></span>
<span><span>        return</span><span> self</span><span>.status</span></span></code></pre>
<p>See the <code>asyncio.sleep</code> in there? That’s no normal local-process sleep; that’s a durable timer backed by Temporal. See
the “Temporal Workflows are Asyncio Event Loops” section later.</p>
<h3>Running a Worker</h3>
<p>Workflows and activities are run in workers like so:</p>
<pre tabindex="0"><code><span><span>from</span><span> temporalio.client </span><span>import</span><span> Client</span></span>
<span><span>from</span><span> temporalio.worker </span><span>import</span><span> Worker</span></span>
<span><span>from</span><span> .my_workflows </span><span>import</span><span> OneClickBuyWorkflow</span></span>
<span><span>from</span><span> .my_activities </span><span>import</span><span> do_purchase</span></span>
<span></span>
<span><span># Create and run a worker on a task queue for the workflow and activity</span></span>
<span><span>worker </span><span>=</span><span> Worker(</span></span>
<span><span>    await</span><span> Client.connect(</span><span>&#34;</span><span>my.temporal.host:7233</span><span>&#34;</span><span>),</span></span>
<span><span>    task_queue</span><span>=</span><span>&#34;</span><span>my-task-queue</span><span>&#34;</span><span>,</span></span>
<span><span>    workflows</span><span>=</span><span>[OneClickBuyWorkflow],</span></span>
<span><span>    activities</span><span>=</span><span>[do_purchase],</span></span>
<span><span>)</span></span>
<span><span>await</span><span> worker.run()</span></span></code></pre>
<h3>Using a Client</h3>
<p>Now we can start the workflow, send it a signal, check it’s status, etc.:</p>
<pre tabindex="0"><code><span><span>from</span><span> temporalio.client </span><span>import</span><span> Client</span></span>
<span><span>from</span><span> .my_activities </span><span>import</span><span> Purchase</span></span>
<span><span>from</span><span> .my_workflows </span><span>import</span><span> OneClickBuyWorkflow, PurchaseStatus</span></span>
<span></span>
<span><span># Create the client</span></span>
<span><span>client </span><span>=</span><span> await</span><span> Client.connect(</span><span>&#34;</span><span>my.temporal.host:7233</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span># Start a workflow</span></span>
<span><span>handle </span><span>=</span><span> await</span><span> client.start_workflow(</span></span>
<span><span>    OneClickBuyWorkflow.run,</span></span>
<span><span>    Purchase(</span><span>item_id</span><span>=</span><span>&#34;</span><span>item1</span><span>&#34;</span><span>, </span><span>user_id</span><span>=</span><span>&#34;</span><span>user1</span><span>&#34;</span><span>),</span></span>
<span><span>    id</span><span>=</span><span>&#34;</span><span>user1-purchase1</span><span>&#34;</span><span>,</span></span>
<span><span>    task_queue</span><span>=</span><span>&#34;</span><span>my-task-queue</span><span>&#34;</span><span>,</span></span>
<span><span>)</span></span>
<span></span>
<span><span># We can cancel it if we want</span></span>
<span><span>await</span><span> handle.cancel()</span></span>
<span></span>
<span><span># We can query its status, even if the workflow is complete</span></span>
<span><span>status </span><span>=</span><span> await</span><span> handle.query(OneClickBuyWorkflow.current_status)</span></span>
<span><span>assert</span><span> status </span><span>==</span><span> PurchaseStatus.CANCELLED</span></span>
<span></span>
<span><span># We can do many other things with the client like sending a signal to update</span></span>
<span><span># the purchase, wait for workflow completion, terminate the workflow, etc.</span></span></code></pre>
<p>This only scratches the surface of what can be done with Temporal Python. See the
<a href="https://github.com/temporalio/sdk-python" rel="nofollow">Python SDK project</a> for more details.</p>
<p>Now that we’ve given a brief overview of Temporal Python, let’s discuss how it leverages asyncio.</p>
<h2>Temporal Workflows are Asyncio Event Loops</h2>
<p>Here we’ll describe asyncio and how Temporal leverages it.</p>
<h3>Asyncio Behind the Scenes</h3>
<p>When running the following in a Python <code>async def</code> function, what happens?</p>
<pre tabindex="0"><code><span><span>await</span><span> asyncio.sleep(</span><span>10</span><span>)</span></span></code></pre>
<p>It sleeps for 10 seconds. But <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep" rel="nofollow">asyncio.sleep</a> is not
like a <a href="https://docs.python.org/3/library/time.html#time.sleep" rel="nofollow">time.sleep</a> — it does not block a thread. Instead, it is
more like a JS <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" rel="nofollow">setTimeout</a> (or a Go <code>time.Sleep</code> or a
Rust Tokio <code>sleep</code>, etc.) in that it instructs the underlying scheduler or event loop to yield to other work and only
resume after that time has passed.</p>
<p>In Python as of this writing, here’s what <code>sleep(delay, result=None)</code> looks like:</p>
<pre tabindex="0"><code><span><span>loop </span><span>=</span><span> events.get_running_loop()</span></span>
<span><span>future </span><span>=</span><span> loop.create_future()</span></span>
<span><span>h </span><span>=</span><span> loop.call_later(delay,</span></span>
<span><span>                    futures._set_result_unless_cancelled,</span></span>
<span><span>                    future, result)</span></span>
<span><span>try</span><span>:</span></span>
<span><span>    return</span><span> await</span><span> future</span></span>
<span><span>finally</span><span>:</span></span>
<span><span>    h.cancel()</span></span></code></pre>
<p>So it obtains the current event loop, creates a future on it, then tells the event loop via
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_later" rel="nofollow">call_later</a> to invoke the future
result setter after a certain amount of time. How <code>call_later</code> is implemented is up to the event loop. The default event
loop just puts a timer on a heap of scheduled things to be checked against event loop “time” on each single event loop
iteration.</p>
<p>Asyncio event loops are simply classes that implement
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop" rel="nofollow">asyncio.AbstractEventLoop</a>. In most
normal cases, developers will use
<a href="https://docs.python.org/3/library/asyncio-runner.html#asyncio.run" rel="nofollow"><code>asyncio.run</code></a><code>(my_async_func())</code> or similar which
will create the default event loop for that system and
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_until_complete" rel="nofollow">run_until_complete</a>.
<code>run_until_complete</code> is implemented by default as
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_forever" rel="nofollow">run_forever</a> with
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.stop" rel="nofollow">stop</a> invoked when the task is done.</p>
<p>So how is <code>run_forever</code> implemented? Exactly as one might expect for an event loop — with a loop:</p>
<pre tabindex="0"><code><span><span>while</span><span> True</span><span>:</span></span>
<span><span>    self</span><span>._run_once()</span></span>
<span><span>    if</span><span> self</span><span>._stopping:</span></span>
<span><span>        break</span></span></code></pre>
<p>This just repeatedly calls <code>_run_once</code> which just processes all things that are ready to be processed (e.g. futures that
have become ready, timers that have passed their time, etc.) waiting to be woken up by the underlying system to
run an iteration again.</p>
<p>So, an event loop is just a triggered “loop” that executes all ready tasks until all are yielded and then waits to be
triggered again.</p>
<h3>Temporal’s Asyncio Event Loop</h3>
<p>In all Temporal SDK languages workflows work similarly. When triggered, they continually run all coroutines individually
and cooperatively until they are all yielded waiting on updates from the Temporal server. Then we send the
since-collected commands of that most recent iteration to the server. Once the server sends us events back (e.g. a
completed timer, a completed activity, a received signal, etc.), we populate yielded values and trigger the workflow to
do the same processing again.</p>
<p>So, a Temporal workflow is just a triggered “loop” that executes all ready tasks until all are yielded and then waits to
be triggered again. Just like an event loop. Therefore it feels very natural to develop Temporal workflow coroutines as
asyncio coroutines.</p>
<p>We have created our own instance of <code>asyncio.AbstractEventLoop</code> that is set as the currently running loop for Temporal
workflows. We don’t even need to implement <code>run_until_complete</code> or <code>run_forever</code>, because we always only ever want to
run one iteration of the event loop.</p>
<h4>Durability</h4>
<p>When we sleep or start a task in normal Python asyncio code and the process crashes, our state and ability to pick up
where we left off are lost. Temporal workflows however are built to be durable and resumable. Since workflow code is
deterministic and all of these constructs are durable, a worker/process crash is no problem. Temporal is built to replay
existing events/code to get to where it left off. Another worker can easily resume the workflow with no data or
functionality loss. Once a workflow is accepted by Temporal, it is ensured to run to completion.</p>
<h4>Timers</h4>
<p>Asyncio timers are built as Temporal timers. For example, inside a workflow if we run:</p>
<pre tabindex="0"><code><span><span>await</span><span> asyncio.sleep(</span><span>10</span><span>)</span></span></code></pre>
<p>We are actually starting a Temporal durable timer. The timer will be visible in the UI. This is the same for everything
that ends up calling <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_later" rel="nofollow">call_later</a>. So
if we have:</p>
<pre tabindex="0"><code><span><span>await</span><span> asyncio.wait_for(workflow.execute_child_workflow(MyChildWorkflow.run), </span><span>timeout</span><span>=</span><span>10</span><span>)</span></span></code></pre>
<p>We have started a child workflow and a 10-second timer which behaves just like Python does. That means if the 10-second
timeout occurs before the completion of the child workflow, this will cancel the child workflow and raise a
<code>TimeoutError</code>.</p>
<p>We can even get the current loop time via:</p>
<pre tabindex="0"><code><span><span>asyncio.get_running_loop().time()</span></span></code></pre>
<p>This effectively the same as <code>workflow.now()</code> but shows that the event loop is at a deterministic point in time. We can
even use a time-skipping test workflow environment and control the time manually.</p>
<h4>Tasks</h4>
<p>Creating a task on the event loop is the proper way to start a Temporal coroutine in a workflow. So we can easily have
something like:</p>
<pre tabindex="0"><code><span><span>async</span><span> with</span><span> asyncio.TaskGroup() </span><span>as</span><span> tg:</span></span>
<span><span>    for</span><span> activity_param </span><span>in</span><span> range</span><span>(</span><span>20</span><span>):</span></span>
<span><span>        tg.create_task(</span></span>
<span><span>            workflow.execute_activity(</span></span>
<span><span>                my_activity,</span></span>
<span><span>                activity_param,</span></span>
<span><span>                start_to_close_timeout</span><span>=</span><span>timedelta(</span><span>minutes</span><span>=</span><span>5</span><span>),</span></span>
<span><span>            ),</span></span>
<span><span>        )</span></span></code></pre>
<p>This uses the new <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup" rel="nofollow">TaskGroup</a> functionality in
Python 3.11 to start 20 activities and wait for them all to complete.</p>
<p>In fact Temporal Python was developed before task groups were made available, but since we leverage native asyncio
constructs, newer features automatically work.</p>
<p>Activities and child workflow handles are actually implemented as extensions of asyncio tasks. So starting an activity
or a started child workflow can be used as tasks. This is acceptable:</p>
<pre tabindex="0"><code><span><span>handle </span><span>=</span><span> workflow.start_activity(my_activity, </span><span>start_to_close_timeout</span><span>=</span><span>timedelta(</span><span>minutes</span><span>=</span><span>5</span><span>))</span></span>
<span><span>handle.set_name(</span><span>&#34;</span><span>my-task-name-for-stack-traces</span><span>&#34;</span><span>)</span></span>
<span><span>workflow.logger.info(</span><span>&#34;</span><span>Result: %s</span><span>&#34;</span><span>, </span><span>await</span><span> handle)</span></span></code></pre>
<h4>Cancellation</h4>
<p>Luckily for us, Python cancellation and Temporal cancellation work almost exactly the same. An asyncio cancellation and
a Temporal cancellation are merely requests that raise errors in the underlying code, but can be caught and ignored.
This means if we cancel a workflow from a client, Temporal will relay that to the workflow as
<a href="https://docs.python.org/3/library/asyncio-task.html#task-cancellation" rel="nofollow">task cancellation</a> which causes an
<code>asyncio.CancelledError</code> to be raised.</p>
<p>We can even use <a href="https://docs.python.org/3/library/asyncio-task.html#shielding-from-cancellation" rel="nofollow">shielding</a> to ensure
something like a really important activity cannot be cancelled, for example:</p>
<pre tabindex="0"><code><span><span>await</span><span> asyncio.shield(workflow.execute_activity(</span></span>
<span><span>    do_not_cancel_me,</span></span>
<span><span>    start_to_close_timeout</span><span>=</span><span>timedelta(</span><span>minutes</span><span>=</span><span>5</span><span>),</span></span>
<span><span>))</span></span></code></pre>
<p>Note, this will not stop the outer part from still raising a cancelled error which, if uncaught, will cancel the
workflow thereby cancelling the activity anyways. See
<a href="https://docs.python.org/3/library/asyncio-task.html#shielding-from-cancellation" rel="nofollow">Python shielding</a> docs on how to
ignore cancellation altogether.</p>
<p>This means task cancellation also works. Say we want to be able to cancel activities as a group after 3 seconds:</p>
<pre tabindex="0"><code><span><span>multiple_activities </span><span>=</span><span> asyncio.create_task(asyncio.gather(</span></span>
<span><span>    workflow.execute_activity(my_activity1, </span><span>start_to_close_timeout</span><span>=</span><span>timedelta(</span><span>minutes</span><span>=</span><span>5</span><span>)),</span></span>
<span><span>    workflow.execute_activity(my_activity2, </span><span>start_to_close_timeout</span><span>=</span><span>timedelta(</span><span>minutes</span><span>=</span><span>5</span><span>)),</span></span>
<span><span>))</span></span>
<span><span>await</span><span> asyncio.sleep(</span><span>3</span><span>)</span></span>
<span><span>multiple_activities.cancel()</span></span>
<span><span>await</span><span> multiple_activities</span></span></code></pre>
<p>This actually issues durable cancellation requests to the activities wherever they may be running if they have started.</p>
<h4>Synchronization Primitives</h4>
<p>We can also use most deterministic asyncio synchronization primitives. For example, it is very common to use
<a href="https://docs.python.org/3/library/asyncio-queue.html" rel="nofollow">asyncio.Queue</a> or
<a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Event" rel="nofollow">asyncio.Event</a>. There are often workflows written
like:</p>
<pre tabindex="0"><code><span><span>@</span><span>workflow</span><span>.</span><span>defn</span></span>
<span><span>class</span><span> MyWorkflow</span><span>:</span></span>
<span><span>    def</span><span> __init__(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        self</span><span>.should_proceed </span><span>=</span><span> asyncio.Event()</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>run</span></span>
<span><span>    async</span><span> def</span><span> run</span><span>(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        workflow.logger.info(</span><span>&#34;</span><span>Waiting...</span><span>&#34;</span><span>)</span></span>
<span><span>        await</span><span> self</span><span>.should_proceed.wait()</span></span>
<span><span>        workflow.logger.info(</span><span>&#34;</span><span>Completing!</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>signal</span></span>
<span><span>    def</span><span> proceed</span><span>(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        self</span><span>.should_proceed.set()</span></span></code></pre>
<p>Then a client may signal the workflow to proceed.</p>
<h4>Wait Condition</h4>
<p>Since we control each event loop iteration, we can do more advanced things than normal Python code. For example, we
offer a <code>wait_condition</code> that does not return until a callback is true. We invoke that callback on each iteration. So
the same above signal example could be written as:</p>
<pre tabindex="0"><code><span><span>@</span><span>workflow</span><span>.</span><span>defn</span></span>
<span><span>class</span><span> MyWorkflow</span><span>:</span></span>
<span><span>    def</span><span> __init__(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        self</span><span>.should_proceed </span><span>=</span><span> False</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>run</span></span>
<span><span>    async</span><span> def</span><span> run</span><span>(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        workflow.logger.info(</span><span>&#34;</span><span>Waiting...</span><span>&#34;</span><span>)</span></span>
<span><span>        await</span><span> workflow.wait_condition(</span><span>lambda</span><span>: </span><span>self</span><span>.should_proceed)</span></span>
<span><span>        workflow.logger.info(</span><span>&#34;</span><span>Completing!</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>signal</span></span>
<span><span>    def</span><span> proceed</span><span>(</span><span>self</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        self</span><span>.should_proceed </span><span>=</span><span> True</span></span></code></pre>
<p>This type of feature isn’t normally available in Python asyncio loops because there is not an easy way to run a callback
every iteration of the event loop.</p>
<h4>Limitations</h4>
<p>Only deterministic asyncio constructs are implemented. So everything relating to subprocesses, disk/network IO, etc.
will fail if invoked.</p>
<p>Currently, only relative-time-based functionality is implemented with the Temporal event loop. Therefore using
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_at" rel="nofollow">call_at</a> will fail. Unfortunately the
newer high-level <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.timeout" rel="nofollow">asyncio.timeout</a> is implemented
via <code>call_at</code> even though it takes a relative time, so it cannot be used yet either. It is possible we may one day
remove this limitation and allow absolute time relative to workflow time, but it can lead to confusing code for a user.</p>
<h2>Other Temporal Python Features</h2>
<p>While this post focused on how Temporal workflows are durable asyncio event loops, there are some other interesting
aspects about Temporal Python worth noting.</p>
<h3>Fully Typed</h3>
<p>The entire library is fully typed with the latest Python type hinting capabilities. The library was designed with typing
in mind and many calls were developed as generics to help developers catch mistakes. For example, given a workflow:</p>
<pre tabindex="0"><code><span><span>@</span><span>workflow</span><span>.</span><span>defn</span></span>
<span><span>class</span><span> MyWorkflow</span></span>
<span><span>    @</span><span>workflow</span><span>.</span><span>run</span></span>
<span><span>    async</span><span> def</span><span> run</span><span>(</span><span>self</span><span>, </span><span>param</span><span>: </span><span>int</span><span>) -&gt; </span><span>None</span><span>:</span></span>
<span><span>        ...</span></span></code></pre>
<p>MyPy (or other type checkers) would report an error if we did:</p>
<pre tabindex="0"><code><span><span>await</span><span> my_client.execute_workflow(MyWorkflow.run, </span><span>&#34;</span><span>some param</span><span>&#34;</span><span>, </span><span>id</span><span>=</span><span>&#34;</span><span>id</span><span>&#34;</span><span>, </span><span>task_queue</span><span>=</span><span>&#34;</span><span>tq</span><span>&#34;</span><span>)</span></span></code></pre>
<p>This fails because the workflow doesn’t take a string argument, it takes an integer one. This type safety is prevalent
throughout the library. See the <a href="https://python.temporal.io/" rel="nofollow">API documentation</a> for all of the types and overloads.</p>
<h3>Multiple Activity Styles</h3>
<p>We have only shown <code>async def</code> activities which are the most common and recommended way to develop activities. But many
Python uses require non-async invocations and calling those in an async context will block the event loop.</p>
<p>Developers can use
<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" rel="nofollow">run_in_executor</a> from their
async activity if they’d like (and this is a very common approach), but we also support non-async activities. For
threaded activities, a worker can be given a
<a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" rel="nofollow">ThreadPoolExecutor</a> to run activities.
We even support multiprocess activities with a
<a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor" rel="nofollow">ProcessPoolExecutor</a>. Extra effort was
made to support activity heartbeating and cancellation of activities across threads and even processes. See the
repository documentation for more info.</p>
<h3>Workflow Sandboxing</h3>
<p>All workflows run in a <a href="https://docs.temporal.io/kb/python-sandbox-environment" rel="nofollow">sandbox</a> by default. For each workflow
run, the sandbox essentially re-imports the file the workflow is in to ensure no global state pollution. Also, it
proxies known non-deterministic standard library calls to prevent accidental things like accessing disk or random inside
a workflow. Most non-standard-library imports should be marked as pass through at import, e.g.:</p>
<pre tabindex="0"><code><span><span>with</span><span> workflow.unsafe.imports_passed_through():</span></span>
<span><span>    import</span><span> pydantic</span></span></code></pre>
<p>This keeps them from being re-imported which saves memory and performance. The sandbox is not foolproof or secure. There
are some known caveats and the sandbox can be disabled per workflow or for the entire worker. See the repository
documentation for more details.</p>
<p>There will be a future blog post on how the sandbox works in detail and how we built it.</p>
<h3>Rust Core</h3>
<p>Both this Python SDK and the <a href="https://github.com/temporalio/sdk-typescript" rel="nofollow">TypeScript SDK</a> (and the upcoming
<a href="https://github.com/temporalio/sdk-ruby" rel="nofollow">Ruby</a> and <a href="https://github.com/temporalio/sdk-dotnet/" rel="nofollow">.NET</a> SDKs) are backed by
the same <a href="https://github.com/temporalio/sdk-core" rel="nofollow">Rust core</a>. Unlike many “SDKs”, the Temporal SDKs are not just simple
smart clients. Rather, they are entire complex state machines. In Temporal, users run the workers and all workflow and
activity code happens on the worker, so advanced machinations are needed to ensure these run properly.</p>
<p>In Python we use <a href="https://github.com/PyO3/PyO3" rel="nofollow">PyO3</a> and <a href="https://github.com/awestlake87/pyo3-asyncio" rel="nofollow">PyO3 Asyncio</a>
with some custom Rust bridge code to make this work with the Rust core. This means code not only runs fast, but
automatically incorporates state machine fixes and improvements as the core is improved.</p>
<p>Also see the post <a href="https://temporal.io/blog/why-rust-powers-core-sdk" rel="nofollow">Why Rust powers Temporal’s new Core SDK</a>.</p>
<h3>Replaying</h3>
<p>One of the most powerful yet often overlooked features of Temporal is the ability to replay workflow code using
historical runs. We can fetch workflow histories from the Temporal server and run them on our local workflow code using
a replayer.</p>
<p>Replaying past workflows on newer workflow code can help catch incompatible/non-deterministic changes and other
unexpected bugs before deployment.</p>
<p>Also, replaying a past workflow history on local workflow code allows us to debug that code. Simply disable the deadlock
detector on the replayer via <code>debug_mode=True</code>, and we can put breakpoints in our workflow code and step through a
workflow exactly how it originally ran.</p>
<h3>Test Environments</h3>
<p>Temporal Python offers two test server implementations to make testing easy.</p>
<p>A full Temporal server running locally on SQLite can be started via
<code>await temporalio.testing.WorkflowEnvironment.start_local()</code>. This downloads an executable into a temporary location if
not already present and starts it rather quickly. This has all features a standard Temporal server has since it is a
full, single-binary Temporal server. The UI can even be enabled.</p>
<p>We also provide a time-skipping server implementation.
<code>await temporalio.testing.WorkflowEnvironment.start_time_skipping()</code> starts a server that can skip time to the next
workflow event. Using this, time can also be manually skipped. This is the perfect solution for testing workflows that
sleep for a long time or in cases where we want to check how a timeout may affect the system. Like the full Temporal
server, this one also downloads a binary lazily on first call then executes. It is actually written in Java as part of
our <a href="https://github.com/temporalio/sdk-java/" rel="nofollow">Java SDK</a> and compiled natively via GraalVM.</p>
<h2>Wrap-up</h2>
<p>So that’s a basic introduction to Temporal Python, how it tightly integrates with asyncio, and some of its other
features. There are many more features not covered in this post.</p>
<p>Check out <a href="https://github.com/temporalio/sdk-python" rel="nofollow">the repository</a> and give it a try! Also, join us on the
<code>#python-sdk</code> channel in <a href="https://t.mp/slack" rel="nofollow">Temporal Slack</a>, the <a href="https://community.temporal.io/" rel="nofollow">Community Forum</a>,
on <a href="https://twitter.com/temporalio" rel="nofollow">Twitter</a>, etc. Our <a href="https://temporal.io/community" rel="nofollow">community</a> has meetups,
workshops, conferences, and more. In particular, our
<a href="https://youtube.com/Temporalio" rel="nofollow">YouTube Channel</a> has lots of good content from past presentations.</p>
<!-- HTML_TAG_END --></div></div> </article></div>
  </body>
</html>
